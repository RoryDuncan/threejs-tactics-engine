(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

/*
    three-js Tactics Engine
*/


(function() {
  var Clock, Stage, ThreeTacticsEngine, utils;

  utils = require("./_utils");

  Stage = require("./_stage");

  Clock = require("./_clock");

  ThreeTacticsEngine = function() {
    /*
      @PRIVATES
    */

    var THREE, configLoaded, eventMethods, log, name, scene, that, _i, _len;
    if (self.THREE === void 0 || self.$ === void 0) {
      throw new Error("The engine is dependent on THREE.js and jQuery, which one of was not found, or not in the global scope.");
    }
    THREE = self.THREE;
    configLoaded = false;
    scene = false;
    that = this;
    this.debug = true;
    this.logs = [];
    log = (function(msg) {
      return utils.log.call(this, msg, this.logs);
    }).bind(this);
    this.log = log;
    /*
      @PUBLICS
    */

    this.load = function() {};
    this.renderQueue = [];
    this.stage = new Stage(this);
    this.clock = new Clock();
    /* 
      Dynamically add event methods from the clock object (which has an event emitter built into it.)
      this array is the names of the methods that will be added to the events object
    */

    eventMethods = ["on", "off", "defer", "getEvents", "trigger", "remove"];
    this.events = {};
    for (_i = 0, _len = eventMethods.length; _i < _len; _i++) {
      name = eventMethods[_i];
      this.events[name] = this.clock[name];
    }
    this.init = function(options) {
      var config;
      config = $.getJSON((options || {}).config);
      if (typeof config === void 0) {
        return;
      }
      that = this;
      return config.complete(function() {
        var renderer;
        try {
          that.config = $.parseJSON(config.responseText);
        } catch (e) {
          log(e);
          throw new Error("JSON was not parsed.");
        }
        configLoaded = true;
        log("Configuration Loaded.");
        renderer = new THREE.WebGLRenderer({
          antialias: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        that.renderer = renderer;
        log("Initialized.");
        if ((options || {}).autostart === true) {
          return that.start();
        }
      });
    };
    this.start = function() {
      var stage;
      if (!configLoaded) {
        return;
      }
      return stage = this.stage.create("test", {
        "url": "json/test.json",
        "camera": new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100000),
        "scene": new THREE.Scene()
      });
    };
    return this;
  };

  self.Engine = new ThreeTacticsEngine();

  Engine.init({
    "config": "json/config.json",
    "autostart": true
  });

  console.log(Engine);

}).call(this);

// Generated by CoffeeScript 1.5.0-pre

},{"./_clock":2,"./_stage":5,"./_utils":6}],2:[function(require,module,exports){

  /*
    Modified version from

    +-+- GITHUB -+-+
  unmodified version located at:
    https://github.com/RoryDuncan/ClockEventAggreggator
    
    +-+- DOCUMENTATION -+-+
    http://roryduncan.github.io/ClockEventAggreggator/

  */

var utils = require("./_utils");

var Clock = function(args) {

  /* Helpers */

  // Helper for merging objects
  extend = utils.extend;

  var isArray = function(thing){
    // assume 'thing' is not undefined or null as it will throw a TypeError.
    if (typeof thing === "string") return false;
    if ( (thing).length === undefined) return false;
    else return true; 
  }


  /*  Timeline related variables  */

  var defaults = {useRAF: true, tickInterval: 16, autostart: false},
      options = extend(defaults, args),
      ticks = 0,
      lastTick = 0,
      startTime = 0,

      // the 'clock' time, calculated with delta and clockSpeed variables.
      elapsedTime = 0,

      // id for requestAnimationFrame
      rAFID = null,

      // whether this is every other tick
      tick_n = false,

      // the amount of real-time that has passed between ticks
      delta = 0,
      actualElapsedTime = 0;

      // fallback time for setTimeout
      this.tickInterval = options.tickInterval,

      running = false,

      // speed at which the clock runs
      clockspeed = 1,

      // reference
      self = this,

      // wether or not to use request Animation Frame
      useRAF = options.useRAF,

      // dynamic function for rAF or setTimeout functionality,
      tickCallee = function() {
        // set to start() initially in case called before start somehow.
        this.start();
      };

      
      


  /*  Event Aggregator related variables  */

  var events = {};
      events.nominal = {};
      events.ordinal = {};
      events.loops = {};

  
  /*  Internal Functions */

  //  clock's tick mechanism
  var tick = function() {
    
    var now = new Date().getTime(); //cache
    if (!running) return;
    
    ticks += 1 * clockspeed;
    tick_n = !tick_n;
    if (this.debug && tick_n) this.log();

    
    this.delta = delta = (now - lastTick) * clockspeed;

    lastTick = now;

    elapsedTime += delta;

    actualElapsedTime = ( now - startTime );

    this.errorMargin = actualElapsedTime - elapsedTime; 


    // singular events take precedence over loop events.
    triggerCurrentEvents();
    triggerLoopEvents();

    this.trigger("tick");

    
    rAFID = tickCallee();

    return ticks;
  };
  
  var buildDefaultEvents = function() {

    var defaultEvents = ["tick", "start", "after:start", "pause", "resume"],
        addEvent = function(name){

          events.ordinal[name] = [];
        };

    defaultEvents.forEach(addEvent);

  };
  buildDefaultEvents();

  var triggerOrdinalEvents = function() {

    var now = ~~(elapsedTime / 100) * 100;

    if ( events.ordinal[ now ] === undefined ) {return false;}  // return false in case of checks

    
    var eot = events.ordinal[ now ];

    // events.ordinal will be an array, so loop over each function in it.
    for (var _x = 0, _xx = eot.length; _x < _xx; _x++) {

      var fn = eot[_x].fn,
          ctx = eot[_x].context,
          args = eot[_x].args;

      fn.apply(ctx, args);
    }

    // delete it, so that it won't trigger the next ticks that round down to this time.
    delete events.ordinal[ now ];

    return true; // return true in case of checks
  };

  var triggerLoopEvents = function() {

    var now = ~~elapsedTime;

    var expired = [];

    for (var key in events.loops) {

      var loop = events.loops[ key ]

      if (loop.start <= now &&          // Check if it is 'allowed' to start.
          loop.checkInterval( now ) &&  // Check whether the loop should fire at the current time
          loop.delete === false ) {      // Check if it is to be deleted
          
          // there is a reference to _this_ inside of loop,
          // so sending the loop itself as context is enough.
          loop.calledAt.push( now );
          loop.now = now;
          
          loop.fn.apply( loop.scope, loop.args );
          
          loop.lastCall = now;
          loop.calls++;
      }
      // check whether it has expired
      if (loop.stop === now || loop.calls === loop.maxIntervals || loop.delete === true) {
        // put it in the box where bad loops go.
        expired.push( key );
      }
    }

    // Delete any loops marked
    for (var i = 0, ii = expired.length; i < ii; i++) {
      var name = expired[i];
      delete events.loops[name];
    }
  };


  /*  Bindings  */

  this.tick = tick.bind(this);
  var triggerLoopEvents = triggerLoopEvents.bind(this);
  var  triggerCurrentEvents = triggerOrdinalEvents.bind(this);
  


  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
  /* * * * * * * * * * * * *   API   * * * * * * * * * * * * */
  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


  /*  Clock-related methods  */

  this.start = function() {

    if (running === true) { return this; } // simple tests to prevent multiple starts

    // tickLoop is a dynamically constructed function to remove an 'if' statement inside of tick() .
    var tickLoop;  

    if (useRAF === true) {
      tickLoop = new Function(" var id = window.requestAnimationFrame( this.tick ); return id;");
    }
    else {
      tickLoop = new Function(" var id = window.setTimeout(this.tick, this.tickInterval);return id;" );
    }
    // bind into this context
    tickCallee = tickLoop.bind(this);

    this.trigger("before:start");

    var now = new Date().getTime();
    this.startTime = startTime = now;
    running = true;
    lastTick = now;
    this.tick();

    this.enablePauseOnBlur();
    this.trigger("start");

    return this;
  }.bind(this);

  this.stop = function(){

    running = false;
    //reset event lists
    events.nominal = {};
    events.ordinal = [];
    events.loops = {};

    buildDefaultEvents();

    //reset counters
    ticks = 0;
    elapsedTime = 0;
    this.startTime = startTime = 0;

    return this;
  }.bind(this);

  this.reset = function(){

    this.reset();
    this.start();
    return this;
  }.bind(this);

  this.pause = function() {
    running = false;
    this.trigger("pause");
    return this;
  }.bind(this);

  this.resume = function() {
    if (running === true) return this;
    running = true;
    lastTick = new Date().getTime();
    this.tick();
    this.trigger("resume");
    return this;
  }.bind(this);

  this.clockScalar = function(multiplier) {
    // a relative way to affect the clock
    clockspeed *= multiplier || 1;
  };

  this.setClockSpeed = function(value) {
    // for manually entering a speed value
    clockspeed = value || clockspeed;
  };

  this.enablePauseOnBlur = function() {
    // called on start
    // requestAnimationFrame natively pauses onblur, but, this clock doesn't
    // so I've programmed the functionality into it. 

    window.onblur = function(){self.pause();}
    window.onfocus = function(){self.resume();};
  };

  this.disablePauseOnBlur = function(){
    window.onblur = function(){return null};
    window.onfocus = function(){return null};
  };
  
  this.ticks = function(){ return ticks; };

  this.milliseconds = function(){ return elapsedTime;};

  this.seconds = function(){ return elapsedTime / 1000 ; };

  this.minutes = function(){ return (this.seconds() / 60); };

  this.debug = options.debug || false;

  // if debug is true, log is automatically called each tick
  this.log = function() {

    console.clear();
    if (useRAF) console.log("<Using requestAnimationFrame>");
    else console.log("<Using setTimeout>");
    console.log("ticks:", ticks);
    console.log("delta:", delta);
    console.log("lastTick(should change)", ~~lastTick)
    console.log("elapsed time:", elapsedTime / 1000);
    console.log("elapsed seconds:", ~~(elapsedTime / 1000));
    console.log("actual elapsed time:", actualElapsedTime / 1000);
    console.warn("%cdifference (in seconds): " + (this.errorMargin / 1000), "color: #a00" );
    console.log("Ignore differences if you have called pause at any time.");
    console.log("Estimated FPS:", ~~(ticks / ( elapsedTime / 1000 )));
  };

  this.time = this.now = function(){ return elapsedTime; };



  /*  Event-related methods  */
  
  this.trigger = function(eventName) {

    if (events.nominal[eventName] === undefined) return this;

    var l = events.nominal[eventName].length

    for (var _x = 0, _xx = l; _x < _xx; _x++) {

      // wow, much length, many chars, such scary.
      var fn = events.nominal[eventName][_x].fn,
          ctx = events.nominal[eventName][_x].context,
          args = events.nominal[eventName][_x].args;

      fn.apply(ctx, args);

    }
    return this;
  };

  this.on = function( eventName, fn /* [, args, context ] */ ) {

    var context = arguments[3] || this, args = arguments[2] || [];

    // create an array for the event
    events.nominal[eventName] = events.nominal[eventName] || []

    var scope = this; // all events default to the scope of the Timeline object.

    events.nominal[eventName].push({
      'fn': fn,
      'args': args,
      'context': context
    });
    return this;
  };

  this.at = function( elapsedMS, fn /* [, args, context ] */ ) {
    if (elapsedMS === undefined) {throw new Error("at() method requires a clock-time passed in as first parameter."); return;}
    if (fn === undefined) {throw new Error("at() method requires a function passed in as second parameter."); return;}

    var context = arguments[3] || null, args = arguments[2] || this;

    var addTime = function( time ) {

      var t = time.toString();
      events.ordinal[ time ] = events.ordinal[ time ] || [];
      events.ordinal[ time ].push({
        "fn": fn,
        "context": context,
        "args": args
      });

    };

    if ( !isArray(elapsedMS) ) {
      addTime( elapsedMS );
      
      return this;

    }

      elapsedMS.forEach( addTime );


      return this;
  };

  this.after = function( milliseconds, fn /* [, args, context ] */ ) {
    var args = arguments[2], context = arguments[3];
    this.at( elapsedTime + milliseconds, fn, args, context );
  };

  this.loop = function( uniqueName, fn, args, scope ) {

    /*
        this.loop() returns a new loop object, which to alter timing-related options
        you call it's .for() method. 
        
        EX:
        var x = this.loop(*args).for(*args);
    */

    if (!uniqueName) return this;

    var self = this,
        defaults = {
          "autostart": true,
          "start": ~~elapsedTime,
          "stop": Infinity, 
          "interval": Infinity, 
          "maxIntervals": Infinity, 
          "duration": 0, 
          "calledAt": [],
          "startDelay": 0
        },
        required = {
          "name":uniqueName,
          "fn": fn,
          "scope": scope || self,
          "calls": 0,
          "parent": self,
          "args": args || []
        };

    // the loop object that will be returned
    var Loop = function(options) {


      extend(this, defaults, required);

      // the check to determine if the loop is called
      this.checkInterval = function(now) {
        var start = this.start,
            interval = this.interval,
            duration = this.duration,
            doesIntervalMatchNow = (now - (start + this.startDelay))  % (interval + duration),
            intervalHasPassed = now - (this.lastCall === undefined ? start : this.lastCall);
  
        /*
        console.clear();
        console.log("name:", this.name);
        console.log("Delta:", self.delta );
        console.log("-----");
        console.log("start:", start);
        console.log("doesIntervalMatchNow", doesIntervalMatchNow);
        console.log("interval:", interval);
        console.log("now:", now);
        console.log("lastCall'ed:", this.lastCall);
        */
        
        if ( doesIntervalMatchNow >= 0 && doesIntervalMatchNow <= delta && (now - this.lastCall) > (interval*0.99) ) return true;
        else return false;
      };

      this.for = function(options) {
        extend(this, options);
        this.lastCall = this.start - this.interval;
        return this;
      };

      this.delete = false;
      return this;
    };
    var l = new Loop();

    events.loops[ l.name ] = l;

    return l;
  };

  this.remove =  this.off = function(event) {

    if (typeof event === "number") {

      if (events.ordinal[event] === undefined) return {"removed":false, "ctx": this};

      delete events.ordinal[event];
      return {"removed":true, "ctx": this};
    }

    if (typeof event === "string") {

      // if it is a event set with on():
      if (events.nominal[eventName] === undefined) {

        //if it is a loop event 
        if (events.loops[eventName] === undefined) return {"removed":false, "ctx": this};

        // loops terminate themselves automatically when set to delete
        events.loops[eventName].delete = true;
        return {"removed":true, "ctx": this};
      }

      delete events.nominal[eventName];
      return {"removed":true, "ctx": this};
    } 
  };

  this.defer = function(fn){
    // waits for the current stack to clear
    window.setTimeout(0, fn)
  };

  this.getEvents = function() {
    // in case someone wants to view the internally set events
    return events;
  };

  /* * * * * * * * * * * * * *

    bindToFunction:

    Attach 'wait' method to the Function.prototype,
    delegating to the timeline's <this>.after() method.
    Useful? Could be. Invasive of global prototypes? Def.

  * * * * * * * * * * * * * */
  
  if (options.bindToFunction === true) {

      var _t = this; // reference, since wait is in the context of the callee

      var wait = function(seconds, args, context) {
        _t.after(seconds, this, args, context); 
      };
      
      Function.prototype.wait = wait;
  }

  if (options.autostart === true) this.start();
  else return this;
};
   

module.exports = Clock;

},{"./_utils":6}],3:[function(require,module,exports){

/*
# @InputInterface
#
*/


(function() {
  var utils;

  utils = require("./_utils");

  module.exports.Interface = function(canvas, parent, engine) {
    var $el, bound, handler, key, mousemoveHandler, scope;
    if (!$) {
      return;
    }
    if (arguments.length === 3) {
      $el = $(canvas);
      this.parent = parent;
      this.engine = engine;
      scope = engine;
    } else {
      $el = $(parent.renderer.domElement);
      this.parent = canvas;
      this.engine = parent;
      scope = parent;
    }
    key = {
      "leftClick": 1,
      "scrollwheel": 2,
      "rightClick": 3,
      'backspace': 8,
      'tab': 9,
      'enter': 13,
      'shift': 16,
      'ctrl': 17,
      'alt': 18,
      'pause': 19,
      'capslock': 20,
      'esc': 27,
      'pageup': 33,
      'pagedown': 34,
      'end': 35,
      'home': 36,
      'left': 37,
      'up': 38,
      'right': 39,
      'down': 40,
      'insert': 45,
      'delete': 46,
      '0': 48,
      '1': 49,
      '2': 50,
      '3': 51,
      '4': 52,
      '5': 53,
      '6': 54,
      '7': 55,
      '8': 56,
      '9': 57,
      'a': 65,
      'b': 66,
      'c': 67,
      'd': 68,
      'e': 69,
      'f': 70,
      'g': 71,
      'h': 72,
      'i': 73,
      'j': 74,
      'k': 75,
      'l': 76,
      'm': 77,
      'n': 78,
      'o': 79,
      'p': 80,
      'q': 81,
      'r': 82,
      's': 83,
      't': 84,
      'u': 85,
      'v': 86,
      'w': 87,
      'x': 88,
      'y': 89,
      'z': 90,
      'numpad0': 96,
      'numpad1': 97,
      'numpad2': 98,
      'numpad3': 99,
      'numpad4': 100,
      'numpad5': 101,
      'numpad6': 102,
      'numpad7': 103,
      'numpad8': 104,
      'numpad9': 105,
      'multiply': 106,
      'plus': 107,
      'minut': 109,
      'dot': 110,
      'slash1': 111,
      'F1': 112,
      'F2': 113,
      'F3': 114,
      'F4': 115,
      'F5': 116,
      'F6': 117,
      'F7': 118,
      'F8': 119,
      'F9': 120,
      'F10': 121,
      'F11': 122,
      'F12': 123,
      'equal': 187,
      'coma': 188,
      'slash': 191,
      'backslash': 220
    };
    bound = {};
    handler = function(e) {
      var b, keyname;
      e.preventDefault();
      e.position = utils.getMousePosition(e);
      b = bound[e.type];
      if (!b) {
        return;
      }
      for (keyname in b) {
        if (key[keyname] === e.which) {
          b[keyname].callback.call(b[keyname], e, b[keyname].data);
          return;
        }
      }
    };
    mousemoveHandler = function(e) {
      var b, data;
      e.preventDefault();
      e.position = utils.getMousePosition(e);
      b = bound["mousemove"];
      data = b.data || {};
      b.callback.call(parent, e, data);
    };
    this.bind = this.on = function(events, keyname, callback, data) {
      var b, eventType, _events, _i, _len;
      if (!(arguments.length >= 2)) {
        return;
      }
      _events = events.split(" ");
      if (_events[0] === "mousemove") {
        bound["mousemove"] = {
          "callback": keyname,
          "data": callback
        };
        $el.on("mousemove", mousemoveHandler);
      }
      for (_i = 0, _len = _events.length; _i < _len; _i++) {
        eventType = _events[_i];
        b = bound[eventType] = bound[eventType] || {};
        b[keyname] = {
          callback: callback,
          data: data
        };
        $el.on(eventType, handler);
      }
      return this;
    };
    this.unbind = this.off = function(events, keyname) {
      var eventType, _events, _i, _len;
      _events = events.split(" ");
      for (_i = 0, _len = _events.length; _i < _len; _i++) {
        eventType = _events[_i];
        $el.off(eventType, handler);
        delete bound[eventType][keyname];
      }
      return this;
    };
    this.trigger = function(event) {
      $el.trigger(event);
      return bound[event];
    };
    return this;
  };

  module.exports.MouseDetection = function(parent, engine, multiselect, clearAfterEmptySelection) {
    var camera, clickHandler, enabled, handler, input, lastClickIntersect, lastHoverIntersect, mousemoveHandler, projector, selectedObjects, stage, that;
    if (multiselect == null) {
      multiselect = false;
    }
    if (clearAfterEmptySelection == null) {
      clearAfterEmptySelection = false;
    }
    enabled = false;
    stage = parent;
    input = parent.Input;
    camera = parent.camera;
    projector = new THREE.Projector();
    this.intersections = null;
    lastHoverIntersect = null;
    lastClickIntersect = null;
    selectedObjects = [];
    that = this;
    this.mousemove = true;
    this.click = true;
    this.multiselect = multiselect;
    this.clearAfterEmptySelection = clearAfterEmptySelection;
    this.getIntersections = function(mouse, camera) {
      var direction, intersections, raycaster, vector;
      vector = new THREE.Vector3(mouse.normalized.x, mouse.normalized.y, 1);
      projector.unprojectVector(vector, camera);
      direction = vector.sub(camera.position).normalize();
      raycaster = new THREE.Raycaster(camera.position, direction);
      intersections = raycaster.intersectObjects(stage.meshes);
      return intersections;
    };
    handler = function(e, camera) {
      var intersections, mouse;
      mouse = e.position;
      intersections = that.getIntersections(mouse, camera);
      if (e.type === "mousemove") {
        if (that.mousemove !== true) {
          return;
        }
        mousemoveHandler(intersections, mouse, camera, e);
      } else if (e.type === "click") {
        if (that.click !== true) {
          return;
        }
        clickHandler(intersections, mouse, camera, e);
      }
      return e;
    };
    mousemoveHandler = function(intersections, mouse, camera, e) {
      var intersect;
      if (intersections.length === 0) {
        if (lastHoverIntersect === null) {
          return;
        }
        lastHoverIntersect.dispatchEvent({
          type: "leave"
        });
        lastHoverIntersect = null;
        return;
      }
      intersect = intersections[0].object;
      intersect.dispatchEvent({
        type: "hover"
      });
      if (lastHoverIntersect === null) {
        return lastHoverIntersect = intersect;
      } else if (lastHoverIntersect !== intersect) {
        lastHoverIntersect.dispatchEvent({
          type: "leave"
        });
        return lastHoverIntersect = intersect;
      }
    };
    clickHandler = function(intersections, mouse, camera, e) {
      /* deal with things that weren't selected
      */

      var intersect;
      if (intersections.length === 0) {
        if (lastClickIntersect === null) {
          return;
        }
        if (that.clearAfterEmptySelection === false) {
          return;
        }
        that.clear();
        return;
      }
      intersect = intersections[0].object;
      intersect.dispatchEvent({
        type: "click"
      });
      if (lastClickIntersect === null) {
        lastClickIntersect = intersect;
        selectedObjects.push(intersect);
      } else if (lastClickIntersect !== intersect) {
        if (that.multiselect === false) {
          lastClickIntersect.dispatchEvent({
            type: "clear"
          });
        }
        lastClickIntersect = intersect;
        selectedObjects.push(intersect);
      }
    };
    this.clear = function() {
      selectedObjects.forEach(function(el) {
        return el.dispatchEvent({
          type: "clear"
        });
      });
      selectedObjects = [];
      return this;
    };
    this.toggle = function() {
      if (enabled) {
        return this.disable();
      } else {
        return this.enable();
      }
    };
    this.off = function() {
      if (enabled) {
        enabled = false;
        input.off("mousemove", handler, camera);
        input.off("click", handler, camera);
      }
    };
    this.on = function() {
      if (!enabled) {
        enabled = true;
        input.on("mousemove", handler, camera);
        input.on("click", "leftClick", handler, camera);
      }
    };
    this.on();
    return this;
  };

}).call(this);

// Generated by CoffeeScript 1.5.0-pre

},{"./_utils":6}],4:[function(require,module,exports){
(function() {
  var BackgroundPlane, LowPolyTerrain, Selector, utils,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  utils = require("./_utils");

  module.exports.Selector = Selector = (function(_super) {

    __extends(Selector, _super);

    function Selector(options, scene) {
      var number, that;
      this.scene = scene;
      if (!(options.size && options.position)) {
        return;
      }
      if (typeof options.size === "number") {
        number = options.size;
      }
      this.parent = options.parent;
      this.position = new THREE.Vector3(options.position.x, options.position.y, options.position.z);
      this.geometry = new THREE.BoxGeometry(options.size.x, options.size.y, options.size.z);
      this.isSelected = false;
      this.disableHover = false;
      /*
      
        eventMaterials is a hash of the different states, named based on the event triggered
      */

      this.currentState = "default";
      this.mesh = new THREE.Mesh(this.geometry, this.eventMaterials["default"]);
      this.mesh.position = this.position;
      this.mesh.wrapper = this;
      that = this;
      this.mesh.addEventListener("hover", that._hover);
      this.mesh.addEventListener("leave", that._leave);
      this.mesh.addEventListener("click", that._click);
      this.mesh.addEventListener("clear", that._clear);
      if (this.scene !== void 0) {
        this.addToScene(this.scene);
      }
    }

    Selector.prototype.eventMaterials = {
      "default": new THREE.MeshBasicMaterial({
        opacity: 1,
        transparent: true,
        color: 0x444455,
        wireframe: false
      }),
      "hover": new THREE.MeshBasicMaterial({
        opacity: 0.45,
        transparent: true
      }),
      "click": new THREE.MeshBasicMaterial({
        color: 0xcccccc
      }),
      "leave": new THREE.MeshBasicMaterial({
        color: 0x00cc99
      }),
      "range": new THREE.MeshBasicMaterial({
        color: 0x0033aa
      }),
      "range-hover": new THREE.MeshBasicMaterial({
        color: 0xaa4444
      })
    };

    Selector.prototype.addToScene = function(scene) {
      this.scene = scene;
      return scene.add(this.mesh);
    };

    /*  The method to propogate events upwards to the SelectionGrid
    */


    Selector.prototype.callSuperEvent = function(name, args) {
      return this.parent.trigger(name, args);
    };

    /* use changeMaterialState to change the material appearance
    */


    Selector.prototype.changeMaterialState = function(name, disableHover) {
      if (disableHover == null) {
        disableHover = false;
      }
      this.mesh.disableHover = disableHover;
      this.mesh.isSelected = false;
      this.currentState = name;
      return this.mesh.material = this.eventMaterials[name] || this.eventMaterials["default"];
    };

    Selector.prototype.resetMaterial = function() {
      this.disableHover = false;
      return this.changeMaterialState("default");
    };

    /* specific event responses
    */


    Selector.prototype._hover = function(e) {
      if (this.wrapper.currentState === "range") {
        this.material = this.wrapper.eventMaterials["range-hover"];
      }
      if (this.disableHover) {
        return;
      }
      this.wrapper.trigger(e.type);
      this.wrapper.callSuperEvent.call(this.wrapper, e.type, [this.wrapper]);
      if (this.isSelected === true) {
        return;
      }
      this.material = this.wrapper.eventMaterials.hover;
      return this.wrapper.currentState = e.type;
    };

    Selector.prototype._leave = function(e) {
      this.wrapper.trigger(e.type);
      this.wrapper.callSuperEvent.call(this.wrapper, e.type, [this.wrapper]);
      if (this.wrapper.currentState === "range") {
        this.material = this.wrapper.eventMaterials["range"];
      }
      if (this.isSelected || this.disableHover || this.wrapper.currentState === "range") {

      } else {
        this.material = this.wrapper.eventMaterials["default"];
        return this.wrapper.currentState = e.type;
      }
    };

    Selector.prototype._click = function(e) {
      this.wrapper.trigger(e.type);
      this.wrapper.callSuperEvent.call(this.wrapper, e.type, [this.wrapper]);
      this.isSelected = !this.isSelected;
      if (this.isSelected) {
        this.material = this.wrapper.eventMaterials.click;
        return this.wrapper.currentState = e.type;
      } else {
        this.material = this.wrapper.eventMaterials.hover;
        return this.wrapper.currentState = "hover";
      }
    };

    Selector.prototype._clear = function(e) {
      this.wrapper.trigger(e.type);
      this.wrapper.callSuperEvent.call(this.wrapper, e.type, [this.wrapper]);
      if (this.wrapper.currentState = "range") {
        return;
      } else {
        this.material = this.wrapper.eventMaterials["default"];
        this.wrapper.currentState = "default";
      }
      return this.isSelected = false;
    };

    return Selector;

  })(utils.EventEmitter);

  module.exports.Skybox = BackgroundPlane = (function() {

    function BackgroundPlane() {
      console.log("wow");
    }

    return BackgroundPlane;

  })();

  module.exports.LowPolyTerrain = LowPolyTerrain = (function() {

    function LowPolyTerrain() {
      console.log("wow");
    }

    return LowPolyTerrain;

  })();

}).call(this);

// Generated by CoffeeScript 1.5.0-pre

},{"./_utils":6}],5:[function(require,module,exports){

/*

  Stages is an object to manage, well, stages.
  which a stage is the equivalent to the game concept of a 'level.'
  but someone could use multiple stages in one level, so I don't want to be pushy and call it a 'level' manager
*/


(function() {
  var Input, SelectionGrid, Selector, Stage, StageManager, utils,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  utils = require("./_utils");

  Input = require("./_input");

  Selector = require("./_objects").Selector;

  /*
      SelectionGrid Class
      Helper class for selecting objects / entities from a grid
      Should be automatically created when
  */


  SelectionGrid = (function(_super) {

    __extends(SelectionGrid, _super);

    function SelectionGrid(data, engine, stage) {
      var centerIndex, evenOffset, hm, o, x, x0, z, z0, _ref;
      this.engine = engine;
      this.stage = stage;
      this.width = data.width;
      this.height = data.length;
      this.padding = data.padding || 2;
      this.x = data.x;
      this.z = data.z;
      this.on("click", function(selector) {
        return this.displayRange(selector, 5);
      }, this);
      /* Convert the data into a normalized grid data
      */

      evenOffset = (_ref = utils.isInt(data.x / 2)) != null ? _ref : {
        0: 1
      };
      x0 = ~~(data.x / 2);
      z0 = ~~(data.z / 2);
      centerIndex = null;
      x = -1 * x0;
      z = -1 * z0;
      hm = utils.isArray(data.heightmap) ? data.heightmap : (function() {
        var _i, _ref1, _results;
        _results = [];
        for (o = _i = 1, _ref1 = data.x * data.z; 1 <= _ref1 ? _i <= _ref1 : _i >= _ref1; o = 1 <= _ref1 ? ++_i : --_i) {
          _results.push(data.heightmap);
        }
        return _results;
      })();
      data = hm.map(function(el, index, arr) {
        var node;
        node = {
          "z": z,
          "x": x,
          "y": el,
          "id": index
        };
        if (x === 0 && z === 0) {
          node.center = true;
          centerIndex = index;
        }
        if (x === (x0 - evenOffset)) {
          x = -1 * x0;
          z += 1;
        } else {
          x++;
        }
        return node;
      });
      this.centerIndex = centerIndex;
      this.data = data;
      this.createGrid();
    }

    SelectionGrid.prototype.createGrid = function(showHelper) {
      var datum, h, material, padding, parent, position, scene, selector, size, w, _i, _len, _ref;
      if (showHelper == null) {
        showHelper = true;
      }
      if (this.data === void 0) {
        return;
      }
      this.selectors = [];
      w = this.width;
      h = this.height;
      padding = this.padding || 2;
      parent = this;
      _ref = this.data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        datum = _ref[_i];
        size = {
          x: w,
          y: 0,
          z: w
        };
        position = {
          x: datum.x * (w + padding),
          y: datum.y * (h + padding),
          z: datum.z * (w + padding)
        };
        material = this.material;
        scene = this.stage.scene;
        selector = new Selector({
          parent: parent,
          size: size,
          position: position,
          material: material
        }, scene);
        datum.selector = selector;
        selector.datum = datum;
        this.selectors.push(selector);
        this.stage.meshes.push(selector.mesh);
      }
      return this.helper.grid.call(this, showHelper);
    };

    SelectionGrid.prototype.filterData = function(vec3) {
      /*
        argument 'vec3' can be an object or a THREE.Vector3 instance
        ! Vector3 instances don't allow you to have 'undefined' as a value, so using '*' is used
        ie:   filterData( new THREE.Vector3(0, "*", "*") );
      
        Plain objects do allow undefined though, so you can pass in an object with all the values you want
        ie:   filterData({ x: 2});
      */

      var results;
      if (!vec3) {
        return;
      }
      results = [];
      results = results.concat(this.data.filter(function(el, i, arr) {
        if (el.x === vec3.x || vec3.x === "*" || vec3.x === void 0) {
          if (el.y === vec3.y || vec3.y === "*" || vec3.y === void 0) {
            if (el.z === vec3.z || vec3.z === "*" || vec3.z === void 0) {
              return el;
            }
          }
        }
      }));
      return results;
    };

    SelectionGrid.prototype.getRange = function(vec3, steps) {
      var count, getStepCount, results, x, _i, _len, _ref;
      if (steps == null) {
        steps = 4;
      }
      getStepCount = utils.steps;
      results = [];
      _ref = this.data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        x = _ref[_i];
        count = getStepCount(vec3, x);
        if (count < steps + 1) {
          results.push(x);
        }
      }
      return results;
    };

    SelectionGrid.prototype.getRangeFromSelector = function(selector, steps) {
      if (!(selector instanceof Selector)) {
        return;
      }
      return this.getRange(selector.datum, steps);
    };

    SelectionGrid.prototype.displayRange = function(selector, steps, clearOtherRanges) {
      var selectors;
      if (clearOtherRanges == null) {
        clearOtherRanges = true;
      }
      if (!(selector instanceof Selector)) {
        return;
      }
      if (clearOtherRanges) {
        this.clearAllRanges();
      }
      selectors = this.getRangeFromSelector(selector, steps);
      return selectors.forEach(function(el) {
        return el.selector.changeMaterialState.call(el.selector, "range", true);
      });
    };

    SelectionGrid.prototype.clearAllRanges = function() {
      var type;
      type = "default";
      return this.selectors.forEach(function(el) {
        return el.resetMaterial.call(el, type);
      });
    };

    SelectionGrid.prototype.helper = {
      grid: function(remove) {
        var grid, padding, size, step, width;
        if (remove == null) {
          remove = false;
        }
        console.log(this);
        padding = this.padding;
        width = this.width;
        size = ((width + padding) * this.x) / 2;
        step = (size * 2) / (width + (padding / 2));
        grid = new THREE.GridHelper(size, step);
        this._helpergrid = grid;
        grid.setColors("#224", "#224");
        this.stage.scene.add(grid);
        return grid;
      },
      range: function() {}
    };

    return SelectionGrid;

  })(utils.EventEmitter);

  Stage = (function(_super) {

    __extends(Stage, _super);

    function Stage(parent, name, options) {
      var beforeLoaded, callbacks, camera, that;
      this.parent = parent;
      this.renderer = parent.renderer;
      this.name = name.toLowerCase();
      this.scene = options.scene;
      camera = options.camera;
      this.camera = camera;
      this.meshes = [];
      beforeLoaded = function() {
        this.render();
        this.Input = new Input.Interface(this, parent);
        this.MouseDetector = new Input.MouseDetection(this, parent);
        return this.onload.call(this);
      };
      that = this;
      that.on("load", beforeLoaded.bind(that));
      callbacks = {
        scope: that,
        success: function(responseText) {
          that.data = responseText;
          console.log("Engine :: '" + name + "' ajax'd. ");
          that.data.grid = that.grid = new SelectionGrid(that.data.grid, that.parent, that);
          return that.trigger("load");
        },
        error: function() {
          throw new Error("Error retrieving data for Stage");
        }
      };
      if (options.url !== void 0) {
        utils.getJSON(options.url, callbacks);
      }
    }

    Stage.prototype.load = function(urlToJson) {
      /*
        incase wasn't originally passed in
      */

      var callbacks, that;
      that = this;
      callbacks = {
        scope: that,
        success: function(responseText) {
          that.data = responseText;
          console.log("Engine :: '" + name + "' ajax'd. ");
          that.data.grid = that.grid = new SelectionGrid(that.data.grid, that.parent, that);
          return that.trigger("load");
        },
        error: function() {
          throw new Error("Error retrieving data for Stage");
        }
      };
      if (urlToJson !== void 0) {
        return utils.getJSON(urlToJson, callbacks);
      }
    };

    Stage.prototype.onload = function() {
      /*
        meant to be overwritten by the user
        alternative is: 
        | @on "load", fn
        which will be triggered on loading
      */
      return this;
    };

    Stage.prototype.lookAt = function(point) {
      this.camera.up = new THREE.Vector3(0, 0, 1);
      return this.camera.lookAt(point || this.scene);
    };

    Stage.prototype.setCameraToIsometric = function() {
      var distanceFromCenterofGridToEdge, h, w, x, xDistance, yDistance, z, zDistance;
      if (!this.grid) {
        return;
      }
      w = this.grid.width;
      h = this.grid.height;
      x = this.grid.x;
      z = this.grid.z;
      distanceFromCenterofGridToEdge = utils.pythag(w * x, h * z);
      yDistance = distanceFromCenterofGridToEdge / 2;
      zDistance = (w + (this.grid.padding || 2)) * z;
      xDistance = (w + (this.grid.padding || 2)) * x;
      this.camera.position.setZ(zDistance);
      this.camera.position.setY(yDistance);
      this.camera.position.setX(xDistance);
      this.camera.lookAt(new THREE.Vector3(0, 0, 0));
      return this;
      /*
      
      
      @camera.rotation.z = 0.25
      */

    };

    Stage.prototype.render = function() {
      var L, extent, geometry, line, material;
      geometry = new THREE.Geometry();
      extent = 5000;
      geometry.vertices.push(new THREE.Vector3(0, 0, -extent));
      geometry.vertices.push(new THREE.Vector3(0, 0, extent));
      geometry.vertices.push(new THREE.Vector3(-extent, 0, 0));
      geometry.vertices.push(new THREE.Vector3(extent, 0, 0));
      geometry.vertices.push(new THREE.Vector3(0, -extent, 0));
      geometry.vertices.push(new THREE.Vector3(0, extent, 0));
      material = new THREE.LineBasicMaterial({
        color: 0x555555
      });
      line = new THREE.Line(geometry, material);
      this.scene.add(line);
      this.setCameraToIsometric();
      this.parent.renderer.render(this.scene, this.camera);
      L = this.parent.clock.loop("render", function() {
        return this.parent.renderer.render(this.scene, this.camera);
      }, null, this);
      L["for"]({
        interval: 17
      });
      return this.parent.clock.start();
    };

    Stage.prototype.destroy = function() {
      return this.parent.destroy(this.name);
    };

    return Stage;

  })(utils.EventEmitter);

  StageManager = function(engine) {
    /* @PRIVATES
    */

    var list, parent;
    parent = engine;
    /* @PUBLICS
    */

    list = {};
    this.list = [];
    this.create = function(name, options) {
      var o, stage;
      if (!name) {
        return;
      }
      o = options || {};
      stage = new Stage(parent, name, o);
      this.list.push(name);
      list[name.toLowerCase()] = stage;
      return list[name.toLowerCase()];
    };
    this.current = void 0;
    this.destroy = function(name) {
      return delete list[name];
    };
    this.load = function(name, transition) {};
    return this;
  };

  module.exports = StageManager;

}).call(this);

// Generated by CoffeeScript 1.5.0-pre

},{"./_input":3,"./_objects":4,"./_utils":6}],6:[function(require,module,exports){

/*
      utilities
*/


(function() {
  var EventEmitter,
    __slice = [].slice;

  module.exports.log = function(msg) {
    var prefix;
    this.logs.unshift(msg);
    if (!this.debug) {
      return;
    }
    prefix = "Engine :: ";
    if (typeof msg === "string") {
      console.log(prefix + msg);
    } else {
      console.log(msg);
    }
  };

  module.exports.extend = function() {
    var base, extended, key, obj, objs, _i, _len;
    objs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (objs.length < 2) {
      return objs[0];
    }
    extended = objs[0];
    for (_i = 0, _len = objs.length; _i < _len; _i++) {
      obj = objs[_i];
      base = obj;
      for (key in base) {
        extended[key] = base[key];
      }
    }
    return extended;
  };

  module.exports.isArray = Array.isArray || function(thing) {
    return Object.prototype.toString.call(thing === "[object Array]");
  };

  module.exports.isInt = function(num) {
    if (num / Math.floor(num) === 1 || num / Math.floor(num) === -1) {
      return true;
    }
    return false;
  };

  module.exports.pythag = function(A, B, hypotenuse) {
    var a2, b2, result;
    if (!(arguments.length >= 2)) {
      return;
    }
    if (B === null) {
      result = (Math.pow(hypotenuse, 2)) - Math.pow(A, 2);
      result = Math.sqrt(result);
      return result;
    } else {
      a2 = Math.pow(A, 2);
      b2 = Math.pow(B, 2);
      result = Math.sqrt(a2 + b2);
      return result;
    }
  };

  module.exports.steps = function(base, target, yAxis) {
    var x, y, z;
    if (yAxis == null) {
      yAxis = false;
    }
    x = Math.abs(base.x - target.x);
    z = Math.abs(base.z - target.z);
    y = yAxis ? Math.abs(base.y - target.y) : 0;
    return x + y + z;
  };

  module.exports.getJSON = function(url, callbacks) {
    var ajax, data, options;
    options = callbacks || {};
    data = void 0;
    ajax = $.getJSON(url);
    return ajax.complete(function() {
      try {
        data = $.parseJSON(ajax.responseText);
      } catch (e) {
        options.error.call(options.scope || null, e, ajax);
        return;
      }
      options.success.call(options.scope || null, data, ajax);
    });
  };

  module.exports.getMousePosition = function($e) {
    var normalized, x, y;
    if (!($e.type === "click" || $e.type === "mousemove")) {
      return;
    }
    x = $e.clientX;
    y = $e.clientY;
    normalized = {
      "x": (x / window.innerWidth) * 2 - 1,
      "y": -(y / window.innerHeight) * 2 + 1
    };
    return {
      x: x,
      y: y,
      normalized: normalized
    };
  };

  module.exports.EventEmitter = EventEmitter = (function() {

    function EventEmitter() {
      this.__events = {};
    }

    EventEmitter.prototype.on = function(name, fn, context) {
      if (this.__events === void 0) {
        this.__events = {};
      }
      this.__events[name] = {
        fn: fn,
        context: context
      };
      return this;
    };

    EventEmitter.prototype.off = function(name) {
      delete this.__events[name];
      return this;
    };

    EventEmitter.prototype.get = function(name) {
      if (this.__events === void 0) {
        return;
      }
      return this.__events[name];
    };

    EventEmitter.prototype.trigger = function(name, args) {
      var f;
      if (args == null) {
        args = [];
      }
      if (this.__events === void 0) {
        return;
      }
      f = this.get(name);
      if (f === void 0) {
        return;
      }
      f.fn.apply(f.context, args);
      return this;
    };

    return EventEmitter;

  })();

}).call(this);

// Generated by CoffeeScript 1.5.0-pre

},{}],7:[function(require,module,exports){
(function() {

  require("./_base");

  require("./main");

}).call(this);

// Generated by CoffeeScript 1.5.0-pre

},{"./_base":1,"./main":8}],8:[function(require,module,exports){
(function() {



}).call(this);

// Generated by CoffeeScript 1.5.0-pre

},{}]},{},[7])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFJvYXItWWF3blxcc2FuZGJveFxcdGhyZWVqcy10YWN0aWNzLWVuZ2luZVxcbm9kZV9tb2R1bGVzXFxicm93c2VyaWZ5XFxub2RlX21vZHVsZXNcXGJyb3dzZXItcGFja1xcX3ByZWx1ZGUuanMiLCJDOi9Vc2Vycy9Sb2FyLVlhd24vc2FuZGJveC90aHJlZWpzLXRhY3RpY3MtZW5naW5lL3B1YmxpYy9qYXZhc2NyaXB0L3NyYy9fYmFzZS5qcyIsIkM6L1VzZXJzL1JvYXItWWF3bi9zYW5kYm94L3RocmVlanMtdGFjdGljcy1lbmdpbmUvcHVibGljL2phdmFzY3JpcHQvc3JjL19jbG9jay5qcyIsIkM6L1VzZXJzL1JvYXItWWF3bi9zYW5kYm94L3RocmVlanMtdGFjdGljcy1lbmdpbmUvcHVibGljL2phdmFzY3JpcHQvc3JjL19pbnB1dC5qcyIsIkM6L1VzZXJzL1JvYXItWWF3bi9zYW5kYm94L3RocmVlanMtdGFjdGljcy1lbmdpbmUvcHVibGljL2phdmFzY3JpcHQvc3JjL19vYmplY3RzLmpzIiwiQzovVXNlcnMvUm9hci1ZYXduL3NhbmRib3gvdGhyZWVqcy10YWN0aWNzLWVuZ2luZS9wdWJsaWMvamF2YXNjcmlwdC9zcmMvX3N0YWdlLmpzIiwiQzovVXNlcnMvUm9hci1ZYXduL3NhbmRib3gvdGhyZWVqcy10YWN0aWNzLWVuZ2luZS9wdWJsaWMvamF2YXNjcmlwdC9zcmMvX3V0aWxzLmpzIiwiQzovVXNlcnMvUm9hci1ZYXduL3NhbmRib3gvdGhyZWVqcy10YWN0aWNzLWVuZ2luZS9wdWJsaWMvamF2YXNjcmlwdC9zcmMvYnJvd3Nlci5qcyIsIkM6L1VzZXJzL1JvYXItWWF3bi9zYW5kYm94L3RocmVlanMtdGFjdGljcy1lbmdpbmUvcHVibGljL2phdmFzY3JpcHQvc3JjL21haW4uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6aUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIil9dmFyIGY9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGYuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sZixmLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIlxuLypcbiAgICB0aHJlZS1qcyBUYWN0aWNzIEVuZ2luZVxuKi9cblxuXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBDbG9jaywgU3RhZ2UsIFRocmVlVGFjdGljc0VuZ2luZSwgdXRpbHM7XG5cbiAgdXRpbHMgPSByZXF1aXJlKFwiLi9fdXRpbHNcIik7XG5cbiAgU3RhZ2UgPSByZXF1aXJlKFwiLi9fc3RhZ2VcIik7XG5cbiAgQ2xvY2sgPSByZXF1aXJlKFwiLi9fY2xvY2tcIik7XG5cbiAgVGhyZWVUYWN0aWNzRW5naW5lID0gZnVuY3Rpb24oKSB7XG4gICAgLypcbiAgICAgIEBQUklWQVRFU1xuICAgICovXG5cbiAgICB2YXIgVEhSRUUsIGNvbmZpZ0xvYWRlZCwgZXZlbnRNZXRob2RzLCBsb2csIG5hbWUsIHNjZW5lLCB0aGF0LCBfaSwgX2xlbjtcbiAgICBpZiAoc2VsZi5USFJFRSA9PT0gdm9pZCAwIHx8IHNlbGYuJCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZW5naW5lIGlzIGRlcGVuZGVudCBvbiBUSFJFRS5qcyBhbmQgalF1ZXJ5LCB3aGljaCBvbmUgb2Ygd2FzIG5vdCBmb3VuZCwgb3Igbm90IGluIHRoZSBnbG9iYWwgc2NvcGUuXCIpO1xuICAgIH1cbiAgICBUSFJFRSA9IHNlbGYuVEhSRUU7XG4gICAgY29uZmlnTG9hZGVkID0gZmFsc2U7XG4gICAgc2NlbmUgPSBmYWxzZTtcbiAgICB0aGF0ID0gdGhpcztcbiAgICB0aGlzLmRlYnVnID0gdHJ1ZTtcbiAgICB0aGlzLmxvZ3MgPSBbXTtcbiAgICBsb2cgPSAoZnVuY3Rpb24obXNnKSB7XG4gICAgICByZXR1cm4gdXRpbHMubG9nLmNhbGwodGhpcywgbXNnLCB0aGlzLmxvZ3MpO1xuICAgIH0pLmJpbmQodGhpcyk7XG4gICAgdGhpcy5sb2cgPSBsb2c7XG4gICAgLypcbiAgICAgIEBQVUJMSUNTXG4gICAgKi9cblxuICAgIHRoaXMubG9hZCA9IGZ1bmN0aW9uKCkge307XG4gICAgdGhpcy5yZW5kZXJRdWV1ZSA9IFtdO1xuICAgIHRoaXMuc3RhZ2UgPSBuZXcgU3RhZ2UodGhpcyk7XG4gICAgdGhpcy5jbG9jayA9IG5ldyBDbG9jaygpO1xuICAgIC8qIFxuICAgICAgRHluYW1pY2FsbHkgYWRkIGV2ZW50IG1ldGhvZHMgZnJvbSB0aGUgY2xvY2sgb2JqZWN0ICh3aGljaCBoYXMgYW4gZXZlbnQgZW1pdHRlciBidWlsdCBpbnRvIGl0LilcbiAgICAgIHRoaXMgYXJyYXkgaXMgdGhlIG5hbWVzIG9mIHRoZSBtZXRob2RzIHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgZXZlbnRzIG9iamVjdFxuICAgICovXG5cbiAgICBldmVudE1ldGhvZHMgPSBbXCJvblwiLCBcIm9mZlwiLCBcImRlZmVyXCIsIFwiZ2V0RXZlbnRzXCIsIFwidHJpZ2dlclwiLCBcInJlbW92ZVwiXTtcbiAgICB0aGlzLmV2ZW50cyA9IHt9O1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gZXZlbnRNZXRob2RzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICBuYW1lID0gZXZlbnRNZXRob2RzW19pXTtcbiAgICAgIHRoaXMuZXZlbnRzW25hbWVdID0gdGhpcy5jbG9ja1tuYW1lXTtcbiAgICB9XG4gICAgdGhpcy5pbml0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGNvbmZpZztcbiAgICAgIGNvbmZpZyA9ICQuZ2V0SlNPTigob3B0aW9ucyB8fCB7fSkuY29uZmlnKTtcbiAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhhdCA9IHRoaXM7XG4gICAgICByZXR1cm4gY29uZmlnLmNvbXBsZXRlKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVuZGVyZXI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhhdC5jb25maWcgPSAkLnBhcnNlSlNPTihjb25maWcucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGxvZyhlKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJKU09OIHdhcyBub3QgcGFyc2VkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25maWdMb2FkZWQgPSB0cnVlO1xuICAgICAgICBsb2coXCJDb25maWd1cmF0aW9uIExvYWRlZC5cIik7XG4gICAgICAgIHJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoe1xuICAgICAgICAgIGFudGlhbGlhczogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmVuZGVyZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChyZW5kZXJlci5kb21FbGVtZW50KTtcbiAgICAgICAgdGhhdC5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICBsb2coXCJJbml0aWFsaXplZC5cIik7XG4gICAgICAgIGlmICgob3B0aW9ucyB8fCB7fSkuYXV0b3N0YXJ0ID09PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoYXQuc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc3RhZ2U7XG4gICAgICBpZiAoIWNvbmZpZ0xvYWRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhZ2UgPSB0aGlzLnN0YWdlLmNyZWF0ZShcInRlc3RcIiwge1xuICAgICAgICBcInVybFwiOiBcImpzb24vdGVzdC5qc29uXCIsXG4gICAgICAgIFwiY2FtZXJhXCI6IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSg0NSwgd2luZG93LmlubmVyV2lkdGggLyB3aW5kb3cuaW5uZXJIZWlnaHQsIDAuMSwgMTAwMDAwKSxcbiAgICAgICAgXCJzY2VuZVwiOiBuZXcgVEhSRUUuU2NlbmUoKVxuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBzZWxmLkVuZ2luZSA9IG5ldyBUaHJlZVRhY3RpY3NFbmdpbmUoKTtcblxuICBFbmdpbmUuaW5pdCh7XG4gICAgXCJjb25maWdcIjogXCJqc29uL2NvbmZpZy5qc29uXCIsXG4gICAgXCJhdXRvc3RhcnRcIjogdHJ1ZVxuICB9KTtcblxuICBjb25zb2xlLmxvZyhFbmdpbmUpO1xuXG59KS5jYWxsKHRoaXMpO1xuXG4vLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNS4wLXByZVxuIiwiXG4gIC8qXG4gICAgTW9kaWZpZWQgdmVyc2lvbiBmcm9tXG5cbiAgICArLSstIEdJVEhVQiAtKy0rXG4gIHVubW9kaWZpZWQgdmVyc2lvbiBsb2NhdGVkIGF0OlxuICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9Sb3J5RHVuY2FuL0Nsb2NrRXZlbnRBZ2dyZWdnYXRvclxuICAgIFxuICAgICstKy0gRE9DVU1FTlRBVElPTiAtKy0rXG4gICAgaHR0cDovL3JvcnlkdW5jYW4uZ2l0aHViLmlvL0Nsb2NrRXZlbnRBZ2dyZWdnYXRvci9cblxuICAqL1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKFwiLi9fdXRpbHNcIik7XG5cbnZhciBDbG9jayA9IGZ1bmN0aW9uKGFyZ3MpIHtcblxuICAvKiBIZWxwZXJzICovXG5cbiAgLy8gSGVscGVyIGZvciBtZXJnaW5nIG9iamVjdHNcbiAgZXh0ZW5kID0gdXRpbHMuZXh0ZW5kO1xuXG4gIHZhciBpc0FycmF5ID0gZnVuY3Rpb24odGhpbmcpe1xuICAgIC8vIGFzc3VtZSAndGhpbmcnIGlzIG5vdCB1bmRlZmluZWQgb3IgbnVsbCBhcyBpdCB3aWxsIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmICh0eXBlb2YgdGhpbmcgPT09IFwic3RyaW5nXCIpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoICh0aGluZykubGVuZ3RoID09PSB1bmRlZmluZWQpIHJldHVybiBmYWxzZTtcbiAgICBlbHNlIHJldHVybiB0cnVlOyBcbiAgfVxuXG5cbiAgLyogIFRpbWVsaW5lIHJlbGF0ZWQgdmFyaWFibGVzICAqL1xuXG4gIHZhciBkZWZhdWx0cyA9IHt1c2VSQUY6IHRydWUsIHRpY2tJbnRlcnZhbDogMTYsIGF1dG9zdGFydDogZmFsc2V9LFxuICAgICAgb3B0aW9ucyA9IGV4dGVuZChkZWZhdWx0cywgYXJncyksXG4gICAgICB0aWNrcyA9IDAsXG4gICAgICBsYXN0VGljayA9IDAsXG4gICAgICBzdGFydFRpbWUgPSAwLFxuXG4gICAgICAvLyB0aGUgJ2Nsb2NrJyB0aW1lLCBjYWxjdWxhdGVkIHdpdGggZGVsdGEgYW5kIGNsb2NrU3BlZWQgdmFyaWFibGVzLlxuICAgICAgZWxhcHNlZFRpbWUgPSAwLFxuXG4gICAgICAvLyBpZCBmb3IgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICByQUZJRCA9IG51bGwsXG5cbiAgICAgIC8vIHdoZXRoZXIgdGhpcyBpcyBldmVyeSBvdGhlciB0aWNrXG4gICAgICB0aWNrX24gPSBmYWxzZSxcblxuICAgICAgLy8gdGhlIGFtb3VudCBvZiByZWFsLXRpbWUgdGhhdCBoYXMgcGFzc2VkIGJldHdlZW4gdGlja3NcbiAgICAgIGRlbHRhID0gMCxcbiAgICAgIGFjdHVhbEVsYXBzZWRUaW1lID0gMDtcblxuICAgICAgLy8gZmFsbGJhY2sgdGltZSBmb3Igc2V0VGltZW91dFxuICAgICAgdGhpcy50aWNrSW50ZXJ2YWwgPSBvcHRpb25zLnRpY2tJbnRlcnZhbCxcblxuICAgICAgcnVubmluZyA9IGZhbHNlLFxuXG4gICAgICAvLyBzcGVlZCBhdCB3aGljaCB0aGUgY2xvY2sgcnVuc1xuICAgICAgY2xvY2tzcGVlZCA9IDEsXG5cbiAgICAgIC8vIHJlZmVyZW5jZVxuICAgICAgc2VsZiA9IHRoaXMsXG5cbiAgICAgIC8vIHdldGhlciBvciBub3QgdG8gdXNlIHJlcXVlc3QgQW5pbWF0aW9uIEZyYW1lXG4gICAgICB1c2VSQUYgPSBvcHRpb25zLnVzZVJBRixcblxuICAgICAgLy8gZHluYW1pYyBmdW5jdGlvbiBmb3IgckFGIG9yIHNldFRpbWVvdXQgZnVuY3Rpb25hbGl0eSxcbiAgICAgIHRpY2tDYWxsZWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gc2V0IHRvIHN0YXJ0KCkgaW5pdGlhbGx5IGluIGNhc2UgY2FsbGVkIGJlZm9yZSBzdGFydCBzb21laG93LlxuICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICB9O1xuXG4gICAgICBcbiAgICAgIFxuXG5cbiAgLyogIEV2ZW50IEFnZ3JlZ2F0b3IgcmVsYXRlZCB2YXJpYWJsZXMgICovXG5cbiAgdmFyIGV2ZW50cyA9IHt9O1xuICAgICAgZXZlbnRzLm5vbWluYWwgPSB7fTtcbiAgICAgIGV2ZW50cy5vcmRpbmFsID0ge307XG4gICAgICBldmVudHMubG9vcHMgPSB7fTtcblxuICBcbiAgLyogIEludGVybmFsIEZ1bmN0aW9ucyAqL1xuXG4gIC8vICBjbG9jaydzIHRpY2sgbWVjaGFuaXNtXG4gIHZhciB0aWNrID0gZnVuY3Rpb24oKSB7XG4gICAgXG4gICAgdmFyIG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpOyAvL2NhY2hlXG4gICAgaWYgKCFydW5uaW5nKSByZXR1cm47XG4gICAgXG4gICAgdGlja3MgKz0gMSAqIGNsb2Nrc3BlZWQ7XG4gICAgdGlja19uID0gIXRpY2tfbjtcbiAgICBpZiAodGhpcy5kZWJ1ZyAmJiB0aWNrX24pIHRoaXMubG9nKCk7XG5cbiAgICBcbiAgICB0aGlzLmRlbHRhID0gZGVsdGEgPSAobm93IC0gbGFzdFRpY2spICogY2xvY2tzcGVlZDtcblxuICAgIGxhc3RUaWNrID0gbm93O1xuXG4gICAgZWxhcHNlZFRpbWUgKz0gZGVsdGE7XG5cbiAgICBhY3R1YWxFbGFwc2VkVGltZSA9ICggbm93IC0gc3RhcnRUaW1lICk7XG5cbiAgICB0aGlzLmVycm9yTWFyZ2luID0gYWN0dWFsRWxhcHNlZFRpbWUgLSBlbGFwc2VkVGltZTsgXG5cblxuICAgIC8vIHNpbmd1bGFyIGV2ZW50cyB0YWtlIHByZWNlZGVuY2Ugb3ZlciBsb29wIGV2ZW50cy5cbiAgICB0cmlnZ2VyQ3VycmVudEV2ZW50cygpO1xuICAgIHRyaWdnZXJMb29wRXZlbnRzKCk7XG5cbiAgICB0aGlzLnRyaWdnZXIoXCJ0aWNrXCIpO1xuXG4gICAgXG4gICAgckFGSUQgPSB0aWNrQ2FsbGVlKCk7XG5cbiAgICByZXR1cm4gdGlja3M7XG4gIH07XG4gIFxuICB2YXIgYnVpbGREZWZhdWx0RXZlbnRzID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgZGVmYXVsdEV2ZW50cyA9IFtcInRpY2tcIiwgXCJzdGFydFwiLCBcImFmdGVyOnN0YXJ0XCIsIFwicGF1c2VcIiwgXCJyZXN1bWVcIl0sXG4gICAgICAgIGFkZEV2ZW50ID0gZnVuY3Rpb24obmFtZSl7XG5cbiAgICAgICAgICBldmVudHMub3JkaW5hbFtuYW1lXSA9IFtdO1xuICAgICAgICB9O1xuXG4gICAgZGVmYXVsdEV2ZW50cy5mb3JFYWNoKGFkZEV2ZW50KTtcblxuICB9O1xuICBidWlsZERlZmF1bHRFdmVudHMoKTtcblxuICB2YXIgdHJpZ2dlck9yZGluYWxFdmVudHMgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBub3cgPSB+fihlbGFwc2VkVGltZSAvIDEwMCkgKiAxMDA7XG5cbiAgICBpZiAoIGV2ZW50cy5vcmRpbmFsWyBub3cgXSA9PT0gdW5kZWZpbmVkICkge3JldHVybiBmYWxzZTt9ICAvLyByZXR1cm4gZmFsc2UgaW4gY2FzZSBvZiBjaGVja3NcblxuICAgIFxuICAgIHZhciBlb3QgPSBldmVudHMub3JkaW5hbFsgbm93IF07XG5cbiAgICAvLyBldmVudHMub3JkaW5hbCB3aWxsIGJlIGFuIGFycmF5LCBzbyBsb29wIG92ZXIgZWFjaCBmdW5jdGlvbiBpbiBpdC5cbiAgICBmb3IgKHZhciBfeCA9IDAsIF94eCA9IGVvdC5sZW5ndGg7IF94IDwgX3h4OyBfeCsrKSB7XG5cbiAgICAgIHZhciBmbiA9IGVvdFtfeF0uZm4sXG4gICAgICAgICAgY3R4ID0gZW90W194XS5jb250ZXh0LFxuICAgICAgICAgIGFyZ3MgPSBlb3RbX3hdLmFyZ3M7XG5cbiAgICAgIGZuLmFwcGx5KGN0eCwgYXJncyk7XG4gICAgfVxuXG4gICAgLy8gZGVsZXRlIGl0LCBzbyB0aGF0IGl0IHdvbid0IHRyaWdnZXIgdGhlIG5leHQgdGlja3MgdGhhdCByb3VuZCBkb3duIHRvIHRoaXMgdGltZS5cbiAgICBkZWxldGUgZXZlbnRzLm9yZGluYWxbIG5vdyBdO1xuXG4gICAgcmV0dXJuIHRydWU7IC8vIHJldHVybiB0cnVlIGluIGNhc2Ugb2YgY2hlY2tzXG4gIH07XG5cbiAgdmFyIHRyaWdnZXJMb29wRXZlbnRzID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgbm93ID0gfn5lbGFwc2VkVGltZTtcblxuICAgIHZhciBleHBpcmVkID0gW107XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gZXZlbnRzLmxvb3BzKSB7XG5cbiAgICAgIHZhciBsb29wID0gZXZlbnRzLmxvb3BzWyBrZXkgXVxuXG4gICAgICBpZiAobG9vcC5zdGFydCA8PSBub3cgJiYgICAgICAgICAgLy8gQ2hlY2sgaWYgaXQgaXMgJ2FsbG93ZWQnIHRvIHN0YXJ0LlxuICAgICAgICAgIGxvb3AuY2hlY2tJbnRlcnZhbCggbm93ICkgJiYgIC8vIENoZWNrIHdoZXRoZXIgdGhlIGxvb3Agc2hvdWxkIGZpcmUgYXQgdGhlIGN1cnJlbnQgdGltZVxuICAgICAgICAgIGxvb3AuZGVsZXRlID09PSBmYWxzZSApIHsgICAgICAvLyBDaGVjayBpZiBpdCBpcyB0byBiZSBkZWxldGVkXG4gICAgICAgICAgXG4gICAgICAgICAgLy8gdGhlcmUgaXMgYSByZWZlcmVuY2UgdG8gX3RoaXNfIGluc2lkZSBvZiBsb29wLFxuICAgICAgICAgIC8vIHNvIHNlbmRpbmcgdGhlIGxvb3AgaXRzZWxmIGFzIGNvbnRleHQgaXMgZW5vdWdoLlxuICAgICAgICAgIGxvb3AuY2FsbGVkQXQucHVzaCggbm93ICk7XG4gICAgICAgICAgbG9vcC5ub3cgPSBub3c7XG4gICAgICAgICAgXG4gICAgICAgICAgbG9vcC5mbi5hcHBseSggbG9vcC5zY29wZSwgbG9vcC5hcmdzICk7XG4gICAgICAgICAgXG4gICAgICAgICAgbG9vcC5sYXN0Q2FsbCA9IG5vdztcbiAgICAgICAgICBsb29wLmNhbGxzKys7XG4gICAgICB9XG4gICAgICAvLyBjaGVjayB3aGV0aGVyIGl0IGhhcyBleHBpcmVkXG4gICAgICBpZiAobG9vcC5zdG9wID09PSBub3cgfHwgbG9vcC5jYWxscyA9PT0gbG9vcC5tYXhJbnRlcnZhbHMgfHwgbG9vcC5kZWxldGUgPT09IHRydWUpIHtcbiAgICAgICAgLy8gcHV0IGl0IGluIHRoZSBib3ggd2hlcmUgYmFkIGxvb3BzIGdvLlxuICAgICAgICBleHBpcmVkLnB1c2goIGtleSApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERlbGV0ZSBhbnkgbG9vcHMgbWFya2VkXG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZXhwaXJlZC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICB2YXIgbmFtZSA9IGV4cGlyZWRbaV07XG4gICAgICBkZWxldGUgZXZlbnRzLmxvb3BzW25hbWVdO1xuICAgIH1cbiAgfTtcblxuXG4gIC8qICBCaW5kaW5ncyAgKi9cblxuICB0aGlzLnRpY2sgPSB0aWNrLmJpbmQodGhpcyk7XG4gIHZhciB0cmlnZ2VyTG9vcEV2ZW50cyA9IHRyaWdnZXJMb29wRXZlbnRzLmJpbmQodGhpcyk7XG4gIHZhciAgdHJpZ2dlckN1cnJlbnRFdmVudHMgPSB0cmlnZ2VyT3JkaW5hbEV2ZW50cy5iaW5kKHRoaXMpO1xuICBcblxuXG4gIC8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKi9cbiAgLyogKiAqICogKiAqICogKiAqICogKiAqICogICBBUEkgICAqICogKiAqICogKiAqICogKiAqICogKiAqL1xuICAvKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICovXG5cblxuICAvKiAgQ2xvY2stcmVsYXRlZCBtZXRob2RzICAqL1xuXG4gIHRoaXMuc3RhcnQgPSBmdW5jdGlvbigpIHtcblxuICAgIGlmIChydW5uaW5nID09PSB0cnVlKSB7IHJldHVybiB0aGlzOyB9IC8vIHNpbXBsZSB0ZXN0cyB0byBwcmV2ZW50IG11bHRpcGxlIHN0YXJ0c1xuXG4gICAgLy8gdGlja0xvb3AgaXMgYSBkeW5hbWljYWxseSBjb25zdHJ1Y3RlZCBmdW5jdGlvbiB0byByZW1vdmUgYW4gJ2lmJyBzdGF0ZW1lbnQgaW5zaWRlIG9mIHRpY2soKSAuXG4gICAgdmFyIHRpY2tMb29wOyAgXG5cbiAgICBpZiAodXNlUkFGID09PSB0cnVlKSB7XG4gICAgICB0aWNrTG9vcCA9IG5ldyBGdW5jdGlvbihcIiB2YXIgaWQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCB0aGlzLnRpY2sgKTsgcmV0dXJuIGlkO1wiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aWNrTG9vcCA9IG5ldyBGdW5jdGlvbihcIiB2YXIgaWQgPSB3aW5kb3cuc2V0VGltZW91dCh0aGlzLnRpY2ssIHRoaXMudGlja0ludGVydmFsKTtyZXR1cm4gaWQ7XCIgKTtcbiAgICB9XG4gICAgLy8gYmluZCBpbnRvIHRoaXMgY29udGV4dFxuICAgIHRpY2tDYWxsZWUgPSB0aWNrTG9vcC5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy50cmlnZ2VyKFwiYmVmb3JlOnN0YXJ0XCIpO1xuXG4gICAgdmFyIG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIHRoaXMuc3RhcnRUaW1lID0gc3RhcnRUaW1lID0gbm93O1xuICAgIHJ1bm5pbmcgPSB0cnVlO1xuICAgIGxhc3RUaWNrID0gbm93O1xuICAgIHRoaXMudGljaygpO1xuXG4gICAgdGhpcy5lbmFibGVQYXVzZU9uQmx1cigpO1xuICAgIHRoaXMudHJpZ2dlcihcInN0YXJ0XCIpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0uYmluZCh0aGlzKTtcblxuICB0aGlzLnN0b3AgPSBmdW5jdGlvbigpe1xuXG4gICAgcnVubmluZyA9IGZhbHNlO1xuICAgIC8vcmVzZXQgZXZlbnQgbGlzdHNcbiAgICBldmVudHMubm9taW5hbCA9IHt9O1xuICAgIGV2ZW50cy5vcmRpbmFsID0gW107XG4gICAgZXZlbnRzLmxvb3BzID0ge307XG5cbiAgICBidWlsZERlZmF1bHRFdmVudHMoKTtcblxuICAgIC8vcmVzZXQgY291bnRlcnNcbiAgICB0aWNrcyA9IDA7XG4gICAgZWxhcHNlZFRpbWUgPSAwO1xuICAgIHRoaXMuc3RhcnRUaW1lID0gc3RhcnRUaW1lID0gMDtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LmJpbmQodGhpcyk7XG5cbiAgdGhpcy5yZXNldCA9IGZ1bmN0aW9uKCl7XG5cbiAgICB0aGlzLnJlc2V0KCk7XG4gICAgdGhpcy5zdGFydCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LmJpbmQodGhpcyk7XG5cbiAgdGhpcy5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJ1bm5pbmcgPSBmYWxzZTtcbiAgICB0aGlzLnRyaWdnZXIoXCJwYXVzZVwiKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfS5iaW5kKHRoaXMpO1xuXG4gIHRoaXMucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHJ1bm5pbmcgPT09IHRydWUpIHJldHVybiB0aGlzO1xuICAgIHJ1bm5pbmcgPSB0cnVlO1xuICAgIGxhc3RUaWNrID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgdGhpcy50aWNrKCk7XG4gICAgdGhpcy50cmlnZ2VyKFwicmVzdW1lXCIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LmJpbmQodGhpcyk7XG5cbiAgdGhpcy5jbG9ja1NjYWxhciA9IGZ1bmN0aW9uKG11bHRpcGxpZXIpIHtcbiAgICAvLyBhIHJlbGF0aXZlIHdheSB0byBhZmZlY3QgdGhlIGNsb2NrXG4gICAgY2xvY2tzcGVlZCAqPSBtdWx0aXBsaWVyIHx8IDE7XG4gIH07XG5cbiAgdGhpcy5zZXRDbG9ja1NwZWVkID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAvLyBmb3IgbWFudWFsbHkgZW50ZXJpbmcgYSBzcGVlZCB2YWx1ZVxuICAgIGNsb2Nrc3BlZWQgPSB2YWx1ZSB8fCBjbG9ja3NwZWVkO1xuICB9O1xuXG4gIHRoaXMuZW5hYmxlUGF1c2VPbkJsdXIgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBjYWxsZWQgb24gc3RhcnRcbiAgICAvLyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgbmF0aXZlbHkgcGF1c2VzIG9uYmx1ciwgYnV0LCB0aGlzIGNsb2NrIGRvZXNuJ3RcbiAgICAvLyBzbyBJJ3ZlIHByb2dyYW1tZWQgdGhlIGZ1bmN0aW9uYWxpdHkgaW50byBpdC4gXG5cbiAgICB3aW5kb3cub25ibHVyID0gZnVuY3Rpb24oKXtzZWxmLnBhdXNlKCk7fVxuICAgIHdpbmRvdy5vbmZvY3VzID0gZnVuY3Rpb24oKXtzZWxmLnJlc3VtZSgpO307XG4gIH07XG5cbiAgdGhpcy5kaXNhYmxlUGF1c2VPbkJsdXIgPSBmdW5jdGlvbigpe1xuICAgIHdpbmRvdy5vbmJsdXIgPSBmdW5jdGlvbigpe3JldHVybiBudWxsfTtcbiAgICB3aW5kb3cub25mb2N1cyA9IGZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9O1xuICB9O1xuICBcbiAgdGhpcy50aWNrcyA9IGZ1bmN0aW9uKCl7IHJldHVybiB0aWNrczsgfTtcblxuICB0aGlzLm1pbGxpc2Vjb25kcyA9IGZ1bmN0aW9uKCl7IHJldHVybiBlbGFwc2VkVGltZTt9O1xuXG4gIHRoaXMuc2Vjb25kcyA9IGZ1bmN0aW9uKCl7IHJldHVybiBlbGFwc2VkVGltZSAvIDEwMDAgOyB9O1xuXG4gIHRoaXMubWludXRlcyA9IGZ1bmN0aW9uKCl7IHJldHVybiAodGhpcy5zZWNvbmRzKCkgLyA2MCk7IH07XG5cbiAgdGhpcy5kZWJ1ZyA9IG9wdGlvbnMuZGVidWcgfHwgZmFsc2U7XG5cbiAgLy8gaWYgZGVidWcgaXMgdHJ1ZSwgbG9nIGlzIGF1dG9tYXRpY2FsbHkgY2FsbGVkIGVhY2ggdGlja1xuICB0aGlzLmxvZyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgY29uc29sZS5jbGVhcigpO1xuICAgIGlmICh1c2VSQUYpIGNvbnNvbGUubG9nKFwiPFVzaW5nIHJlcXVlc3RBbmltYXRpb25GcmFtZT5cIik7XG4gICAgZWxzZSBjb25zb2xlLmxvZyhcIjxVc2luZyBzZXRUaW1lb3V0PlwiKTtcbiAgICBjb25zb2xlLmxvZyhcInRpY2tzOlwiLCB0aWNrcyk7XG4gICAgY29uc29sZS5sb2coXCJkZWx0YTpcIiwgZGVsdGEpO1xuICAgIGNvbnNvbGUubG9nKFwibGFzdFRpY2soc2hvdWxkIGNoYW5nZSlcIiwgfn5sYXN0VGljaylcbiAgICBjb25zb2xlLmxvZyhcImVsYXBzZWQgdGltZTpcIiwgZWxhcHNlZFRpbWUgLyAxMDAwKTtcbiAgICBjb25zb2xlLmxvZyhcImVsYXBzZWQgc2Vjb25kczpcIiwgfn4oZWxhcHNlZFRpbWUgLyAxMDAwKSk7XG4gICAgY29uc29sZS5sb2coXCJhY3R1YWwgZWxhcHNlZCB0aW1lOlwiLCBhY3R1YWxFbGFwc2VkVGltZSAvIDEwMDApO1xuICAgIGNvbnNvbGUud2FybihcIiVjZGlmZmVyZW5jZSAoaW4gc2Vjb25kcyk6IFwiICsgKHRoaXMuZXJyb3JNYXJnaW4gLyAxMDAwKSwgXCJjb2xvcjogI2EwMFwiICk7XG4gICAgY29uc29sZS5sb2coXCJJZ25vcmUgZGlmZmVyZW5jZXMgaWYgeW91IGhhdmUgY2FsbGVkIHBhdXNlIGF0IGFueSB0aW1lLlwiKTtcbiAgICBjb25zb2xlLmxvZyhcIkVzdGltYXRlZCBGUFM6XCIsIH5+KHRpY2tzIC8gKCBlbGFwc2VkVGltZSAvIDEwMDAgKSkpO1xuICB9O1xuXG4gIHRoaXMudGltZSA9IHRoaXMubm93ID0gZnVuY3Rpb24oKXsgcmV0dXJuIGVsYXBzZWRUaW1lOyB9O1xuXG5cblxuICAvKiAgRXZlbnQtcmVsYXRlZCBtZXRob2RzICAqL1xuICBcbiAgdGhpcy50cmlnZ2VyID0gZnVuY3Rpb24oZXZlbnROYW1lKSB7XG5cbiAgICBpZiAoZXZlbnRzLm5vbWluYWxbZXZlbnROYW1lXSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcztcblxuICAgIHZhciBsID0gZXZlbnRzLm5vbWluYWxbZXZlbnROYW1lXS5sZW5ndGhcblxuICAgIGZvciAodmFyIF94ID0gMCwgX3h4ID0gbDsgX3ggPCBfeHg7IF94KyspIHtcblxuICAgICAgLy8gd293LCBtdWNoIGxlbmd0aCwgbWFueSBjaGFycywgc3VjaCBzY2FyeS5cbiAgICAgIHZhciBmbiA9IGV2ZW50cy5ub21pbmFsW2V2ZW50TmFtZV1bX3hdLmZuLFxuICAgICAgICAgIGN0eCA9IGV2ZW50cy5ub21pbmFsW2V2ZW50TmFtZV1bX3hdLmNvbnRleHQsXG4gICAgICAgICAgYXJncyA9IGV2ZW50cy5ub21pbmFsW2V2ZW50TmFtZV1bX3hdLmFyZ3M7XG5cbiAgICAgIGZuLmFwcGx5KGN0eCwgYXJncyk7XG5cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdGhpcy5vbiA9IGZ1bmN0aW9uKCBldmVudE5hbWUsIGZuIC8qIFssIGFyZ3MsIGNvbnRleHQgXSAqLyApIHtcblxuICAgIHZhciBjb250ZXh0ID0gYXJndW1lbnRzWzNdIHx8IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHNbMl0gfHwgW107XG5cbiAgICAvLyBjcmVhdGUgYW4gYXJyYXkgZm9yIHRoZSBldmVudFxuICAgIGV2ZW50cy5ub21pbmFsW2V2ZW50TmFtZV0gPSBldmVudHMubm9taW5hbFtldmVudE5hbWVdIHx8IFtdXG5cbiAgICB2YXIgc2NvcGUgPSB0aGlzOyAvLyBhbGwgZXZlbnRzIGRlZmF1bHQgdG8gdGhlIHNjb3BlIG9mIHRoZSBUaW1lbGluZSBvYmplY3QuXG5cbiAgICBldmVudHMubm9taW5hbFtldmVudE5hbWVdLnB1c2goe1xuICAgICAgJ2ZuJzogZm4sXG4gICAgICAnYXJncyc6IGFyZ3MsXG4gICAgICAnY29udGV4dCc6IGNvbnRleHRcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB0aGlzLmF0ID0gZnVuY3Rpb24oIGVsYXBzZWRNUywgZm4gLyogWywgYXJncywgY29udGV4dCBdICovICkge1xuICAgIGlmIChlbGFwc2VkTVMgPT09IHVuZGVmaW5lZCkge3Rocm93IG5ldyBFcnJvcihcImF0KCkgbWV0aG9kIHJlcXVpcmVzIGEgY2xvY2stdGltZSBwYXNzZWQgaW4gYXMgZmlyc3QgcGFyYW1ldGVyLlwiKTsgcmV0dXJuO31cbiAgICBpZiAoZm4gPT09IHVuZGVmaW5lZCkge3Rocm93IG5ldyBFcnJvcihcImF0KCkgbWV0aG9kIHJlcXVpcmVzIGEgZnVuY3Rpb24gcGFzc2VkIGluIGFzIHNlY29uZCBwYXJhbWV0ZXIuXCIpOyByZXR1cm47fVxuXG4gICAgdmFyIGNvbnRleHQgPSBhcmd1bWVudHNbM10gfHwgbnVsbCwgYXJncyA9IGFyZ3VtZW50c1syXSB8fCB0aGlzO1xuXG4gICAgdmFyIGFkZFRpbWUgPSBmdW5jdGlvbiggdGltZSApIHtcblxuICAgICAgdmFyIHQgPSB0aW1lLnRvU3RyaW5nKCk7XG4gICAgICBldmVudHMub3JkaW5hbFsgdGltZSBdID0gZXZlbnRzLm9yZGluYWxbIHRpbWUgXSB8fCBbXTtcbiAgICAgIGV2ZW50cy5vcmRpbmFsWyB0aW1lIF0ucHVzaCh7XG4gICAgICAgIFwiZm5cIjogZm4sXG4gICAgICAgIFwiY29udGV4dFwiOiBjb250ZXh0LFxuICAgICAgICBcImFyZ3NcIjogYXJnc1xuICAgICAgfSk7XG5cbiAgICB9O1xuXG4gICAgaWYgKCAhaXNBcnJheShlbGFwc2VkTVMpICkge1xuICAgICAgYWRkVGltZSggZWxhcHNlZE1TICk7XG4gICAgICBcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfVxuXG4gICAgICBlbGFwc2VkTVMuZm9yRWFjaCggYWRkVGltZSApO1xuXG5cbiAgICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHRoaXMuYWZ0ZXIgPSBmdW5jdGlvbiggbWlsbGlzZWNvbmRzLCBmbiAvKiBbLCBhcmdzLCBjb250ZXh0IF0gKi8gKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHNbMl0sIGNvbnRleHQgPSBhcmd1bWVudHNbM107XG4gICAgdGhpcy5hdCggZWxhcHNlZFRpbWUgKyBtaWxsaXNlY29uZHMsIGZuLCBhcmdzLCBjb250ZXh0ICk7XG4gIH07XG5cbiAgdGhpcy5sb29wID0gZnVuY3Rpb24oIHVuaXF1ZU5hbWUsIGZuLCBhcmdzLCBzY29wZSApIHtcblxuICAgIC8qXG4gICAgICAgIHRoaXMubG9vcCgpIHJldHVybnMgYSBuZXcgbG9vcCBvYmplY3QsIHdoaWNoIHRvIGFsdGVyIHRpbWluZy1yZWxhdGVkIG9wdGlvbnNcbiAgICAgICAgeW91IGNhbGwgaXQncyAuZm9yKCkgbWV0aG9kLiBcbiAgICAgICAgXG4gICAgICAgIEVYOlxuICAgICAgICB2YXIgeCA9IHRoaXMubG9vcCgqYXJncykuZm9yKCphcmdzKTtcbiAgICAqL1xuXG4gICAgaWYgKCF1bmlxdWVOYW1lKSByZXR1cm4gdGhpcztcblxuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgZGVmYXVsdHMgPSB7XG4gICAgICAgICAgXCJhdXRvc3RhcnRcIjogdHJ1ZSxcbiAgICAgICAgICBcInN0YXJ0XCI6IH5+ZWxhcHNlZFRpbWUsXG4gICAgICAgICAgXCJzdG9wXCI6IEluZmluaXR5LCBcbiAgICAgICAgICBcImludGVydmFsXCI6IEluZmluaXR5LCBcbiAgICAgICAgICBcIm1heEludGVydmFsc1wiOiBJbmZpbml0eSwgXG4gICAgICAgICAgXCJkdXJhdGlvblwiOiAwLCBcbiAgICAgICAgICBcImNhbGxlZEF0XCI6IFtdLFxuICAgICAgICAgIFwic3RhcnREZWxheVwiOiAwXG4gICAgICAgIH0sXG4gICAgICAgIHJlcXVpcmVkID0ge1xuICAgICAgICAgIFwibmFtZVwiOnVuaXF1ZU5hbWUsXG4gICAgICAgICAgXCJmblwiOiBmbixcbiAgICAgICAgICBcInNjb3BlXCI6IHNjb3BlIHx8IHNlbGYsXG4gICAgICAgICAgXCJjYWxsc1wiOiAwLFxuICAgICAgICAgIFwicGFyZW50XCI6IHNlbGYsXG4gICAgICAgICAgXCJhcmdzXCI6IGFyZ3MgfHwgW11cbiAgICAgICAgfTtcblxuICAgIC8vIHRoZSBsb29wIG9iamVjdCB0aGF0IHdpbGwgYmUgcmV0dXJuZWRcbiAgICB2YXIgTG9vcCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblxuXG4gICAgICBleHRlbmQodGhpcywgZGVmYXVsdHMsIHJlcXVpcmVkKTtcblxuICAgICAgLy8gdGhlIGNoZWNrIHRvIGRldGVybWluZSBpZiB0aGUgbG9vcCBpcyBjYWxsZWRcbiAgICAgIHRoaXMuY2hlY2tJbnRlcnZhbCA9IGZ1bmN0aW9uKG5vdykge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnN0YXJ0LFxuICAgICAgICAgICAgaW50ZXJ2YWwgPSB0aGlzLmludGVydmFsLFxuICAgICAgICAgICAgZHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgZG9lc0ludGVydmFsTWF0Y2hOb3cgPSAobm93IC0gKHN0YXJ0ICsgdGhpcy5zdGFydERlbGF5KSkgICUgKGludGVydmFsICsgZHVyYXRpb24pLFxuICAgICAgICAgICAgaW50ZXJ2YWxIYXNQYXNzZWQgPSBub3cgLSAodGhpcy5sYXN0Q2FsbCA9PT0gdW5kZWZpbmVkID8gc3RhcnQgOiB0aGlzLmxhc3RDYWxsKTtcbiAgXG4gICAgICAgIC8qXG4gICAgICAgIGNvbnNvbGUuY2xlYXIoKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJuYW1lOlwiLCB0aGlzLm5hbWUpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIkRlbHRhOlwiLCBzZWxmLmRlbHRhICk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiLS0tLS1cIik7XG4gICAgICAgIGNvbnNvbGUubG9nKFwic3RhcnQ6XCIsIHN0YXJ0KTtcbiAgICAgICAgY29uc29sZS5sb2coXCJkb2VzSW50ZXJ2YWxNYXRjaE5vd1wiLCBkb2VzSW50ZXJ2YWxNYXRjaE5vdyk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiaW50ZXJ2YWw6XCIsIGludGVydmFsKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJub3c6XCIsIG5vdyk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwibGFzdENhbGwnZWQ6XCIsIHRoaXMubGFzdENhbGwpO1xuICAgICAgICAqL1xuICAgICAgICBcbiAgICAgICAgaWYgKCBkb2VzSW50ZXJ2YWxNYXRjaE5vdyA+PSAwICYmIGRvZXNJbnRlcnZhbE1hdGNoTm93IDw9IGRlbHRhICYmIChub3cgLSB0aGlzLmxhc3RDYWxsKSA+IChpbnRlcnZhbCowLjk5KSApIHJldHVybiB0cnVlO1xuICAgICAgICBlbHNlIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuZm9yID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBleHRlbmQodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMubGFzdENhbGwgPSB0aGlzLnN0YXJ0IC0gdGhpcy5pbnRlcnZhbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmRlbGV0ZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICB2YXIgbCA9IG5ldyBMb29wKCk7XG5cbiAgICBldmVudHMubG9vcHNbIGwubmFtZSBdID0gbDtcblxuICAgIHJldHVybiBsO1xuICB9O1xuXG4gIHRoaXMucmVtb3ZlID0gIHRoaXMub2ZmID0gZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgIGlmICh0eXBlb2YgZXZlbnQgPT09IFwibnVtYmVyXCIpIHtcblxuICAgICAgaWYgKGV2ZW50cy5vcmRpbmFsW2V2ZW50XSA9PT0gdW5kZWZpbmVkKSByZXR1cm4ge1wicmVtb3ZlZFwiOmZhbHNlLCBcImN0eFwiOiB0aGlzfTtcblxuICAgICAgZGVsZXRlIGV2ZW50cy5vcmRpbmFsW2V2ZW50XTtcbiAgICAgIHJldHVybiB7XCJyZW1vdmVkXCI6dHJ1ZSwgXCJjdHhcIjogdGhpc307XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBldmVudCA9PT0gXCJzdHJpbmdcIikge1xuXG4gICAgICAvLyBpZiBpdCBpcyBhIGV2ZW50IHNldCB3aXRoIG9uKCk6XG4gICAgICBpZiAoZXZlbnRzLm5vbWluYWxbZXZlbnROYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgLy9pZiBpdCBpcyBhIGxvb3AgZXZlbnQgXG4gICAgICAgIGlmIChldmVudHMubG9vcHNbZXZlbnROYW1lXSA9PT0gdW5kZWZpbmVkKSByZXR1cm4ge1wicmVtb3ZlZFwiOmZhbHNlLCBcImN0eFwiOiB0aGlzfTtcblxuICAgICAgICAvLyBsb29wcyB0ZXJtaW5hdGUgdGhlbXNlbHZlcyBhdXRvbWF0aWNhbGx5IHdoZW4gc2V0IHRvIGRlbGV0ZVxuICAgICAgICBldmVudHMubG9vcHNbZXZlbnROYW1lXS5kZWxldGUgPSB0cnVlO1xuICAgICAgICByZXR1cm4ge1wicmVtb3ZlZFwiOnRydWUsIFwiY3R4XCI6IHRoaXN9O1xuICAgICAgfVxuXG4gICAgICBkZWxldGUgZXZlbnRzLm5vbWluYWxbZXZlbnROYW1lXTtcbiAgICAgIHJldHVybiB7XCJyZW1vdmVkXCI6dHJ1ZSwgXCJjdHhcIjogdGhpc307XG4gICAgfSBcbiAgfTtcblxuICB0aGlzLmRlZmVyID0gZnVuY3Rpb24oZm4pe1xuICAgIC8vIHdhaXRzIGZvciB0aGUgY3VycmVudCBzdGFjayB0byBjbGVhclxuICAgIHdpbmRvdy5zZXRUaW1lb3V0KDAsIGZuKVxuICB9O1xuXG4gIHRoaXMuZ2V0RXZlbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gaW4gY2FzZSBzb21lb25lIHdhbnRzIHRvIHZpZXcgdGhlIGludGVybmFsbHkgc2V0IGV2ZW50c1xuICAgIHJldHVybiBldmVudHM7XG4gIH07XG5cbiAgLyogKiAqICogKiAqICogKiAqICogKiAqICogKlxuXG4gICAgYmluZFRvRnVuY3Rpb246XG5cbiAgICBBdHRhY2ggJ3dhaXQnIG1ldGhvZCB0byB0aGUgRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIGRlbGVnYXRpbmcgdG8gdGhlIHRpbWVsaW5lJ3MgPHRoaXM+LmFmdGVyKCkgbWV0aG9kLlxuICAgIFVzZWZ1bD8gQ291bGQgYmUuIEludmFzaXZlIG9mIGdsb2JhbCBwcm90b3R5cGVzPyBEZWYuXG5cbiAgKiAqICogKiAqICogKiAqICogKiAqICogKiAqL1xuICBcbiAgaWYgKG9wdGlvbnMuYmluZFRvRnVuY3Rpb24gPT09IHRydWUpIHtcblxuICAgICAgdmFyIF90ID0gdGhpczsgLy8gcmVmZXJlbmNlLCBzaW5jZSB3YWl0IGlzIGluIHRoZSBjb250ZXh0IG9mIHRoZSBjYWxsZWVcblxuICAgICAgdmFyIHdhaXQgPSBmdW5jdGlvbihzZWNvbmRzLCBhcmdzLCBjb250ZXh0KSB7XG4gICAgICAgIF90LmFmdGVyKHNlY29uZHMsIHRoaXMsIGFyZ3MsIGNvbnRleHQpOyBcbiAgICAgIH07XG4gICAgICBcbiAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZS53YWl0ID0gd2FpdDtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmF1dG9zdGFydCA9PT0gdHJ1ZSkgdGhpcy5zdGFydCgpO1xuICBlbHNlIHJldHVybiB0aGlzO1xufTtcbiAgIFxuXG5tb2R1bGUuZXhwb3J0cyA9IENsb2NrO1xuIiwiXG4vKlxuIyBASW5wdXRJbnRlcmZhY2VcbiNcbiovXG5cblxuKGZ1bmN0aW9uKCkge1xuICB2YXIgdXRpbHM7XG5cbiAgdXRpbHMgPSByZXF1aXJlKFwiLi9fdXRpbHNcIik7XG5cbiAgbW9kdWxlLmV4cG9ydHMuSW50ZXJmYWNlID0gZnVuY3Rpb24oY2FudmFzLCBwYXJlbnQsIGVuZ2luZSkge1xuICAgIHZhciAkZWwsIGJvdW5kLCBoYW5kbGVyLCBrZXksIG1vdXNlbW92ZUhhbmRsZXIsIHNjb3BlO1xuICAgIGlmICghJCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgJGVsID0gJChjYW52YXMpO1xuICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICB0aGlzLmVuZ2luZSA9IGVuZ2luZTtcbiAgICAgIHNjb3BlID0gZW5naW5lO1xuICAgIH0gZWxzZSB7XG4gICAgICAkZWwgPSAkKHBhcmVudC5yZW5kZXJlci5kb21FbGVtZW50KTtcbiAgICAgIHRoaXMucGFyZW50ID0gY2FudmFzO1xuICAgICAgdGhpcy5lbmdpbmUgPSBwYXJlbnQ7XG4gICAgICBzY29wZSA9IHBhcmVudDtcbiAgICB9XG4gICAga2V5ID0ge1xuICAgICAgXCJsZWZ0Q2xpY2tcIjogMSxcbiAgICAgIFwic2Nyb2xsd2hlZWxcIjogMixcbiAgICAgIFwicmlnaHRDbGlja1wiOiAzLFxuICAgICAgJ2JhY2tzcGFjZSc6IDgsXG4gICAgICAndGFiJzogOSxcbiAgICAgICdlbnRlcic6IDEzLFxuICAgICAgJ3NoaWZ0JzogMTYsXG4gICAgICAnY3RybCc6IDE3LFxuICAgICAgJ2FsdCc6IDE4LFxuICAgICAgJ3BhdXNlJzogMTksXG4gICAgICAnY2Fwc2xvY2snOiAyMCxcbiAgICAgICdlc2MnOiAyNyxcbiAgICAgICdwYWdldXAnOiAzMyxcbiAgICAgICdwYWdlZG93bic6IDM0LFxuICAgICAgJ2VuZCc6IDM1LFxuICAgICAgJ2hvbWUnOiAzNixcbiAgICAgICdsZWZ0JzogMzcsXG4gICAgICAndXAnOiAzOCxcbiAgICAgICdyaWdodCc6IDM5LFxuICAgICAgJ2Rvd24nOiA0MCxcbiAgICAgICdpbnNlcnQnOiA0NSxcbiAgICAgICdkZWxldGUnOiA0NixcbiAgICAgICcwJzogNDgsXG4gICAgICAnMSc6IDQ5LFxuICAgICAgJzInOiA1MCxcbiAgICAgICczJzogNTEsXG4gICAgICAnNCc6IDUyLFxuICAgICAgJzUnOiA1MyxcbiAgICAgICc2JzogNTQsXG4gICAgICAnNyc6IDU1LFxuICAgICAgJzgnOiA1NixcbiAgICAgICc5JzogNTcsXG4gICAgICAnYSc6IDY1LFxuICAgICAgJ2InOiA2NixcbiAgICAgICdjJzogNjcsXG4gICAgICAnZCc6IDY4LFxuICAgICAgJ2UnOiA2OSxcbiAgICAgICdmJzogNzAsXG4gICAgICAnZyc6IDcxLFxuICAgICAgJ2gnOiA3MixcbiAgICAgICdpJzogNzMsXG4gICAgICAnaic6IDc0LFxuICAgICAgJ2snOiA3NSxcbiAgICAgICdsJzogNzYsXG4gICAgICAnbSc6IDc3LFxuICAgICAgJ24nOiA3OCxcbiAgICAgICdvJzogNzksXG4gICAgICAncCc6IDgwLFxuICAgICAgJ3EnOiA4MSxcbiAgICAgICdyJzogODIsXG4gICAgICAncyc6IDgzLFxuICAgICAgJ3QnOiA4NCxcbiAgICAgICd1JzogODUsXG4gICAgICAndic6IDg2LFxuICAgICAgJ3cnOiA4NyxcbiAgICAgICd4JzogODgsXG4gICAgICAneSc6IDg5LFxuICAgICAgJ3onOiA5MCxcbiAgICAgICdudW1wYWQwJzogOTYsXG4gICAgICAnbnVtcGFkMSc6IDk3LFxuICAgICAgJ251bXBhZDInOiA5OCxcbiAgICAgICdudW1wYWQzJzogOTksXG4gICAgICAnbnVtcGFkNCc6IDEwMCxcbiAgICAgICdudW1wYWQ1JzogMTAxLFxuICAgICAgJ251bXBhZDYnOiAxMDIsXG4gICAgICAnbnVtcGFkNyc6IDEwMyxcbiAgICAgICdudW1wYWQ4JzogMTA0LFxuICAgICAgJ251bXBhZDknOiAxMDUsXG4gICAgICAnbXVsdGlwbHknOiAxMDYsXG4gICAgICAncGx1cyc6IDEwNyxcbiAgICAgICdtaW51dCc6IDEwOSxcbiAgICAgICdkb3QnOiAxMTAsXG4gICAgICAnc2xhc2gxJzogMTExLFxuICAgICAgJ0YxJzogMTEyLFxuICAgICAgJ0YyJzogMTEzLFxuICAgICAgJ0YzJzogMTE0LFxuICAgICAgJ0Y0JzogMTE1LFxuICAgICAgJ0Y1JzogMTE2LFxuICAgICAgJ0Y2JzogMTE3LFxuICAgICAgJ0Y3JzogMTE4LFxuICAgICAgJ0Y4JzogMTE5LFxuICAgICAgJ0Y5JzogMTIwLFxuICAgICAgJ0YxMCc6IDEyMSxcbiAgICAgICdGMTEnOiAxMjIsXG4gICAgICAnRjEyJzogMTIzLFxuICAgICAgJ2VxdWFsJzogMTg3LFxuICAgICAgJ2NvbWEnOiAxODgsXG4gICAgICAnc2xhc2gnOiAxOTEsXG4gICAgICAnYmFja3NsYXNoJzogMjIwXG4gICAgfTtcbiAgICBib3VuZCA9IHt9O1xuICAgIGhhbmRsZXIgPSBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgYiwga2V5bmFtZTtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGUucG9zaXRpb24gPSB1dGlscy5nZXRNb3VzZVBvc2l0aW9uKGUpO1xuICAgICAgYiA9IGJvdW5kW2UudHlwZV07XG4gICAgICBpZiAoIWIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yIChrZXluYW1lIGluIGIpIHtcbiAgICAgICAgaWYgKGtleVtrZXluYW1lXSA9PT0gZS53aGljaCkge1xuICAgICAgICAgIGJba2V5bmFtZV0uY2FsbGJhY2suY2FsbChiW2tleW5hbWVdLCBlLCBiW2tleW5hbWVdLmRhdGEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgbW91c2Vtb3ZlSGFuZGxlciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciBiLCBkYXRhO1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZS5wb3NpdGlvbiA9IHV0aWxzLmdldE1vdXNlUG9zaXRpb24oZSk7XG4gICAgICBiID0gYm91bmRbXCJtb3VzZW1vdmVcIl07XG4gICAgICBkYXRhID0gYi5kYXRhIHx8IHt9O1xuICAgICAgYi5jYWxsYmFjay5jYWxsKHBhcmVudCwgZSwgZGF0YSk7XG4gICAgfTtcbiAgICB0aGlzLmJpbmQgPSB0aGlzLm9uID0gZnVuY3Rpb24oZXZlbnRzLCBrZXluYW1lLCBjYWxsYmFjaywgZGF0YSkge1xuICAgICAgdmFyIGIsIGV2ZW50VHlwZSwgX2V2ZW50cywgX2ksIF9sZW47XG4gICAgICBpZiAoIShhcmd1bWVudHMubGVuZ3RoID49IDIpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIF9ldmVudHMgPSBldmVudHMuc3BsaXQoXCIgXCIpO1xuICAgICAgaWYgKF9ldmVudHNbMF0gPT09IFwibW91c2Vtb3ZlXCIpIHtcbiAgICAgICAgYm91bmRbXCJtb3VzZW1vdmVcIl0gPSB7XG4gICAgICAgICAgXCJjYWxsYmFja1wiOiBrZXluYW1lLFxuICAgICAgICAgIFwiZGF0YVwiOiBjYWxsYmFja1xuICAgICAgICB9O1xuICAgICAgICAkZWwub24oXCJtb3VzZW1vdmVcIiwgbW91c2Vtb3ZlSGFuZGxlcik7XG4gICAgICB9XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9ldmVudHMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgZXZlbnRUeXBlID0gX2V2ZW50c1tfaV07XG4gICAgICAgIGIgPSBib3VuZFtldmVudFR5cGVdID0gYm91bmRbZXZlbnRUeXBlXSB8fCB7fTtcbiAgICAgICAgYltrZXluYW1lXSA9IHtcbiAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICB9O1xuICAgICAgICAkZWwub24oZXZlbnRUeXBlLCBoYW5kbGVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgdGhpcy51bmJpbmQgPSB0aGlzLm9mZiA9IGZ1bmN0aW9uKGV2ZW50cywga2V5bmFtZSkge1xuICAgICAgdmFyIGV2ZW50VHlwZSwgX2V2ZW50cywgX2ksIF9sZW47XG4gICAgICBfZXZlbnRzID0gZXZlbnRzLnNwbGl0KFwiIFwiKTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX2V2ZW50cy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBldmVudFR5cGUgPSBfZXZlbnRzW19pXTtcbiAgICAgICAgJGVsLm9mZihldmVudFR5cGUsIGhhbmRsZXIpO1xuICAgICAgICBkZWxldGUgYm91bmRbZXZlbnRUeXBlXVtrZXluYW1lXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgdGhpcy50cmlnZ2VyID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICRlbC50cmlnZ2VyKGV2ZW50KTtcbiAgICAgIHJldHVybiBib3VuZFtldmVudF07XG4gICAgfTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cy5Nb3VzZURldGVjdGlvbiA9IGZ1bmN0aW9uKHBhcmVudCwgZW5naW5lLCBtdWx0aXNlbGVjdCwgY2xlYXJBZnRlckVtcHR5U2VsZWN0aW9uKSB7XG4gICAgdmFyIGNhbWVyYSwgY2xpY2tIYW5kbGVyLCBlbmFibGVkLCBoYW5kbGVyLCBpbnB1dCwgbGFzdENsaWNrSW50ZXJzZWN0LCBsYXN0SG92ZXJJbnRlcnNlY3QsIG1vdXNlbW92ZUhhbmRsZXIsIHByb2plY3Rvciwgc2VsZWN0ZWRPYmplY3RzLCBzdGFnZSwgdGhhdDtcbiAgICBpZiAobXVsdGlzZWxlY3QgPT0gbnVsbCkge1xuICAgICAgbXVsdGlzZWxlY3QgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGNsZWFyQWZ0ZXJFbXB0eVNlbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICBjbGVhckFmdGVyRW1wdHlTZWxlY3Rpb24gPSBmYWxzZTtcbiAgICB9XG4gICAgZW5hYmxlZCA9IGZhbHNlO1xuICAgIHN0YWdlID0gcGFyZW50O1xuICAgIGlucHV0ID0gcGFyZW50LklucHV0O1xuICAgIGNhbWVyYSA9IHBhcmVudC5jYW1lcmE7XG4gICAgcHJvamVjdG9yID0gbmV3IFRIUkVFLlByb2plY3RvcigpO1xuICAgIHRoaXMuaW50ZXJzZWN0aW9ucyA9IG51bGw7XG4gICAgbGFzdEhvdmVySW50ZXJzZWN0ID0gbnVsbDtcbiAgICBsYXN0Q2xpY2tJbnRlcnNlY3QgPSBudWxsO1xuICAgIHNlbGVjdGVkT2JqZWN0cyA9IFtdO1xuICAgIHRoYXQgPSB0aGlzO1xuICAgIHRoaXMubW91c2Vtb3ZlID0gdHJ1ZTtcbiAgICB0aGlzLmNsaWNrID0gdHJ1ZTtcbiAgICB0aGlzLm11bHRpc2VsZWN0ID0gbXVsdGlzZWxlY3Q7XG4gICAgdGhpcy5jbGVhckFmdGVyRW1wdHlTZWxlY3Rpb24gPSBjbGVhckFmdGVyRW1wdHlTZWxlY3Rpb247XG4gICAgdGhpcy5nZXRJbnRlcnNlY3Rpb25zID0gZnVuY3Rpb24obW91c2UsIGNhbWVyYSkge1xuICAgICAgdmFyIGRpcmVjdGlvbiwgaW50ZXJzZWN0aW9ucywgcmF5Y2FzdGVyLCB2ZWN0b3I7XG4gICAgICB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMyhtb3VzZS5ub3JtYWxpemVkLngsIG1vdXNlLm5vcm1hbGl6ZWQueSwgMSk7XG4gICAgICBwcm9qZWN0b3IudW5wcm9qZWN0VmVjdG9yKHZlY3RvciwgY2FtZXJhKTtcbiAgICAgIGRpcmVjdGlvbiA9IHZlY3Rvci5zdWIoY2FtZXJhLnBvc2l0aW9uKS5ub3JtYWxpemUoKTtcbiAgICAgIHJheWNhc3RlciA9IG5ldyBUSFJFRS5SYXljYXN0ZXIoY2FtZXJhLnBvc2l0aW9uLCBkaXJlY3Rpb24pO1xuICAgICAgaW50ZXJzZWN0aW9ucyA9IHJheWNhc3Rlci5pbnRlcnNlY3RPYmplY3RzKHN0YWdlLm1lc2hlcyk7XG4gICAgICByZXR1cm4gaW50ZXJzZWN0aW9ucztcbiAgICB9O1xuICAgIGhhbmRsZXIgPSBmdW5jdGlvbihlLCBjYW1lcmEpIHtcbiAgICAgIHZhciBpbnRlcnNlY3Rpb25zLCBtb3VzZTtcbiAgICAgIG1vdXNlID0gZS5wb3NpdGlvbjtcbiAgICAgIGludGVyc2VjdGlvbnMgPSB0aGF0LmdldEludGVyc2VjdGlvbnMobW91c2UsIGNhbWVyYSk7XG4gICAgICBpZiAoZS50eXBlID09PSBcIm1vdXNlbW92ZVwiKSB7XG4gICAgICAgIGlmICh0aGF0Lm1vdXNlbW92ZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBtb3VzZW1vdmVIYW5kbGVyKGludGVyc2VjdGlvbnMsIG1vdXNlLCBjYW1lcmEsIGUpO1xuICAgICAgfSBlbHNlIGlmIChlLnR5cGUgPT09IFwiY2xpY2tcIikge1xuICAgICAgICBpZiAodGhhdC5jbGljayAhPT0gdHJ1ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjbGlja0hhbmRsZXIoaW50ZXJzZWN0aW9ucywgbW91c2UsIGNhbWVyYSwgZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIG1vdXNlbW92ZUhhbmRsZXIgPSBmdW5jdGlvbihpbnRlcnNlY3Rpb25zLCBtb3VzZSwgY2FtZXJhLCBlKSB7XG4gICAgICB2YXIgaW50ZXJzZWN0O1xuICAgICAgaWYgKGludGVyc2VjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlmIChsYXN0SG92ZXJJbnRlcnNlY3QgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGFzdEhvdmVySW50ZXJzZWN0LmRpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgIHR5cGU6IFwibGVhdmVcIlxuICAgICAgICB9KTtcbiAgICAgICAgbGFzdEhvdmVySW50ZXJzZWN0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaW50ZXJzZWN0ID0gaW50ZXJzZWN0aW9uc1swXS5vYmplY3Q7XG4gICAgICBpbnRlcnNlY3QuZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgIHR5cGU6IFwiaG92ZXJcIlxuICAgICAgfSk7XG4gICAgICBpZiAobGFzdEhvdmVySW50ZXJzZWN0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBsYXN0SG92ZXJJbnRlcnNlY3QgPSBpbnRlcnNlY3Q7XG4gICAgICB9IGVsc2UgaWYgKGxhc3RIb3ZlckludGVyc2VjdCAhPT0gaW50ZXJzZWN0KSB7XG4gICAgICAgIGxhc3RIb3ZlckludGVyc2VjdC5kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICB0eXBlOiBcImxlYXZlXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBsYXN0SG92ZXJJbnRlcnNlY3QgPSBpbnRlcnNlY3Q7XG4gICAgICB9XG4gICAgfTtcbiAgICBjbGlja0hhbmRsZXIgPSBmdW5jdGlvbihpbnRlcnNlY3Rpb25zLCBtb3VzZSwgY2FtZXJhLCBlKSB7XG4gICAgICAvKiBkZWFsIHdpdGggdGhpbmdzIHRoYXQgd2VyZW4ndCBzZWxlY3RlZFxuICAgICAgKi9cblxuICAgICAgdmFyIGludGVyc2VjdDtcbiAgICAgIGlmIChpbnRlcnNlY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZiAobGFzdENsaWNrSW50ZXJzZWN0ID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGF0LmNsZWFyQWZ0ZXJFbXB0eVNlbGVjdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhhdC5jbGVhcigpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpbnRlcnNlY3QgPSBpbnRlcnNlY3Rpb25zWzBdLm9iamVjdDtcbiAgICAgIGludGVyc2VjdC5kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgdHlwZTogXCJjbGlja1wiXG4gICAgICB9KTtcbiAgICAgIGlmIChsYXN0Q2xpY2tJbnRlcnNlY3QgPT09IG51bGwpIHtcbiAgICAgICAgbGFzdENsaWNrSW50ZXJzZWN0ID0gaW50ZXJzZWN0O1xuICAgICAgICBzZWxlY3RlZE9iamVjdHMucHVzaChpbnRlcnNlY3QpO1xuICAgICAgfSBlbHNlIGlmIChsYXN0Q2xpY2tJbnRlcnNlY3QgIT09IGludGVyc2VjdCkge1xuICAgICAgICBpZiAodGhhdC5tdWx0aXNlbGVjdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBsYXN0Q2xpY2tJbnRlcnNlY3QuZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICB0eXBlOiBcImNsZWFyXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0Q2xpY2tJbnRlcnNlY3QgPSBpbnRlcnNlY3Q7XG4gICAgICAgIHNlbGVjdGVkT2JqZWN0cy5wdXNoKGludGVyc2VjdCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICBzZWxlY3RlZE9iamVjdHMuZm9yRWFjaChmdW5jdGlvbihlbCkge1xuICAgICAgICByZXR1cm4gZWwuZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgdHlwZTogXCJjbGVhclwiXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBzZWxlY3RlZE9iamVjdHMgPSBbXTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgdGhpcy50b2dnbGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc2FibGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuYWJsZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5vZmYgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgIGVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgaW5wdXQub2ZmKFwibW91c2Vtb3ZlXCIsIGhhbmRsZXIsIGNhbWVyYSk7XG4gICAgICAgIGlucHV0Lm9mZihcImNsaWNrXCIsIGhhbmRsZXIsIGNhbWVyYSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLm9uID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgICAgZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIGlucHV0Lm9uKFwibW91c2Vtb3ZlXCIsIGhhbmRsZXIsIGNhbWVyYSk7XG4gICAgICAgIGlucHV0Lm9uKFwiY2xpY2tcIiwgXCJsZWZ0Q2xpY2tcIiwgaGFuZGxlciwgY2FtZXJhKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMub24oKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxufSkuY2FsbCh0aGlzKTtcblxuLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjUuMC1wcmVcbiIsIihmdW5jdGlvbigpIHtcbiAgdmFyIEJhY2tncm91bmRQbGFuZSwgTG93UG9seVRlcnJhaW4sIFNlbGVjdG9yLCB1dGlscyxcbiAgICBfX2hhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSxcbiAgICBfX2V4dGVuZHMgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKF9faGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfTtcblxuICB1dGlscyA9IHJlcXVpcmUoXCIuL191dGlsc1wiKTtcblxuICBtb2R1bGUuZXhwb3J0cy5TZWxlY3RvciA9IFNlbGVjdG9yID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuXG4gICAgX19leHRlbmRzKFNlbGVjdG9yLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gU2VsZWN0b3Iob3B0aW9ucywgc2NlbmUpIHtcbiAgICAgIHZhciBudW1iZXIsIHRoYXQ7XG4gICAgICB0aGlzLnNjZW5lID0gc2NlbmU7XG4gICAgICBpZiAoIShvcHRpb25zLnNpemUgJiYgb3B0aW9ucy5wb3NpdGlvbikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnNpemUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgbnVtYmVyID0gb3B0aW9ucy5zaXplO1xuICAgICAgfVxuICAgICAgdGhpcy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgICAgIHRoaXMucG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMyhvcHRpb25zLnBvc2l0aW9uLngsIG9wdGlvbnMucG9zaXRpb24ueSwgb3B0aW9ucy5wb3NpdGlvbi56KTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQm94R2VvbWV0cnkob3B0aW9ucy5zaXplLngsIG9wdGlvbnMuc2l6ZS55LCBvcHRpb25zLnNpemUueik7XG4gICAgICB0aGlzLmlzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGlzYWJsZUhvdmVyID0gZmFsc2U7XG4gICAgICAvKlxuICAgICAgXG4gICAgICAgIGV2ZW50TWF0ZXJpYWxzIGlzIGEgaGFzaCBvZiB0aGUgZGlmZmVyZW50IHN0YXRlcywgbmFtZWQgYmFzZWQgb24gdGhlIGV2ZW50IHRyaWdnZXJlZFxuICAgICAgKi9cblxuICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSBcImRlZmF1bHRcIjtcbiAgICAgIHRoaXMubWVzaCA9IG5ldyBUSFJFRS5NZXNoKHRoaXMuZ2VvbWV0cnksIHRoaXMuZXZlbnRNYXRlcmlhbHNbXCJkZWZhdWx0XCJdKTtcbiAgICAgIHRoaXMubWVzaC5wb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgICB0aGlzLm1lc2gud3JhcHBlciA9IHRoaXM7XG4gICAgICB0aGF0ID0gdGhpcztcbiAgICAgIHRoaXMubWVzaC5hZGRFdmVudExpc3RlbmVyKFwiaG92ZXJcIiwgdGhhdC5faG92ZXIpO1xuICAgICAgdGhpcy5tZXNoLmFkZEV2ZW50TGlzdGVuZXIoXCJsZWF2ZVwiLCB0aGF0Ll9sZWF2ZSk7XG4gICAgICB0aGlzLm1lc2guYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoYXQuX2NsaWNrKTtcbiAgICAgIHRoaXMubWVzaC5hZGRFdmVudExpc3RlbmVyKFwiY2xlYXJcIiwgdGhhdC5fY2xlYXIpO1xuICAgICAgaWYgKHRoaXMuc2NlbmUgIT09IHZvaWQgMCkge1xuICAgICAgICB0aGlzLmFkZFRvU2NlbmUodGhpcy5zY2VuZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgU2VsZWN0b3IucHJvdG90eXBlLmV2ZW50TWF0ZXJpYWxzID0ge1xuICAgICAgXCJkZWZhdWx0XCI6IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7XG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgICBjb2xvcjogMHg0NDQ0NTUsXG4gICAgICAgIHdpcmVmcmFtZTogZmFsc2VcbiAgICAgIH0pLFxuICAgICAgXCJob3ZlclwiOiBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICAgICAgICBvcGFjaXR5OiAwLjQ1LFxuICAgICAgICB0cmFuc3BhcmVudDogdHJ1ZVxuICAgICAgfSksXG4gICAgICBcImNsaWNrXCI6IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7XG4gICAgICAgIGNvbG9yOiAweGNjY2NjY1xuICAgICAgfSksXG4gICAgICBcImxlYXZlXCI6IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7XG4gICAgICAgIGNvbG9yOiAweDAwY2M5OVxuICAgICAgfSksXG4gICAgICBcInJhbmdlXCI6IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7XG4gICAgICAgIGNvbG9yOiAweDAwMzNhYVxuICAgICAgfSksXG4gICAgICBcInJhbmdlLWhvdmVyXCI6IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7XG4gICAgICAgIGNvbG9yOiAweGFhNDQ0NFxuICAgICAgfSlcbiAgICB9O1xuXG4gICAgU2VsZWN0b3IucHJvdG90eXBlLmFkZFRvU2NlbmUgPSBmdW5jdGlvbihzY2VuZSkge1xuICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xuICAgICAgcmV0dXJuIHNjZW5lLmFkZCh0aGlzLm1lc2gpO1xuICAgIH07XG5cbiAgICAvKiAgVGhlIG1ldGhvZCB0byBwcm9wb2dhdGUgZXZlbnRzIHVwd2FyZHMgdG8gdGhlIFNlbGVjdGlvbkdyaWRcbiAgICAqL1xuXG5cbiAgICBTZWxlY3Rvci5wcm90b3R5cGUuY2FsbFN1cGVyRXZlbnQgPSBmdW5jdGlvbihuYW1lLCBhcmdzKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQudHJpZ2dlcihuYW1lLCBhcmdzKTtcbiAgICB9O1xuXG4gICAgLyogdXNlIGNoYW5nZU1hdGVyaWFsU3RhdGUgdG8gY2hhbmdlIHRoZSBtYXRlcmlhbCBhcHBlYXJhbmNlXG4gICAgKi9cblxuXG4gICAgU2VsZWN0b3IucHJvdG90eXBlLmNoYW5nZU1hdGVyaWFsU3RhdGUgPSBmdW5jdGlvbihuYW1lLCBkaXNhYmxlSG92ZXIpIHtcbiAgICAgIGlmIChkaXNhYmxlSG92ZXIgPT0gbnVsbCkge1xuICAgICAgICBkaXNhYmxlSG92ZXIgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWVzaC5kaXNhYmxlSG92ZXIgPSBkaXNhYmxlSG92ZXI7XG4gICAgICB0aGlzLm1lc2guaXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSBuYW1lO1xuICAgICAgcmV0dXJuIHRoaXMubWVzaC5tYXRlcmlhbCA9IHRoaXMuZXZlbnRNYXRlcmlhbHNbbmFtZV0gfHwgdGhpcy5ldmVudE1hdGVyaWFsc1tcImRlZmF1bHRcIl07XG4gICAgfTtcblxuICAgIFNlbGVjdG9yLnByb3RvdHlwZS5yZXNldE1hdGVyaWFsID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRpc2FibGVIb3ZlciA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlTWF0ZXJpYWxTdGF0ZShcImRlZmF1bHRcIik7XG4gICAgfTtcblxuICAgIC8qIHNwZWNpZmljIGV2ZW50IHJlc3BvbnNlc1xuICAgICovXG5cblxuICAgIFNlbGVjdG9yLnByb3RvdHlwZS5faG92ZXIgPSBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAodGhpcy53cmFwcGVyLmN1cnJlbnRTdGF0ZSA9PT0gXCJyYW5nZVwiKSB7XG4gICAgICAgIHRoaXMubWF0ZXJpYWwgPSB0aGlzLndyYXBwZXIuZXZlbnRNYXRlcmlhbHNbXCJyYW5nZS1ob3ZlclwiXTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmRpc2FibGVIb3Zlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLndyYXBwZXIudHJpZ2dlcihlLnR5cGUpO1xuICAgICAgdGhpcy53cmFwcGVyLmNhbGxTdXBlckV2ZW50LmNhbGwodGhpcy53cmFwcGVyLCBlLnR5cGUsIFt0aGlzLndyYXBwZXJdKTtcbiAgICAgIGlmICh0aGlzLmlzU2VsZWN0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5tYXRlcmlhbCA9IHRoaXMud3JhcHBlci5ldmVudE1hdGVyaWFscy5ob3ZlcjtcbiAgICAgIHJldHVybiB0aGlzLndyYXBwZXIuY3VycmVudFN0YXRlID0gZS50eXBlO1xuICAgIH07XG5cbiAgICBTZWxlY3Rvci5wcm90b3R5cGUuX2xlYXZlID0gZnVuY3Rpb24oZSkge1xuICAgICAgdGhpcy53cmFwcGVyLnRyaWdnZXIoZS50eXBlKTtcbiAgICAgIHRoaXMud3JhcHBlci5jYWxsU3VwZXJFdmVudC5jYWxsKHRoaXMud3JhcHBlciwgZS50eXBlLCBbdGhpcy53cmFwcGVyXSk7XG4gICAgICBpZiAodGhpcy53cmFwcGVyLmN1cnJlbnRTdGF0ZSA9PT0gXCJyYW5nZVwiKSB7XG4gICAgICAgIHRoaXMubWF0ZXJpYWwgPSB0aGlzLndyYXBwZXIuZXZlbnRNYXRlcmlhbHNbXCJyYW5nZVwiXTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzU2VsZWN0ZWQgfHwgdGhpcy5kaXNhYmxlSG92ZXIgfHwgdGhpcy53cmFwcGVyLmN1cnJlbnRTdGF0ZSA9PT0gXCJyYW5nZVwiKSB7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubWF0ZXJpYWwgPSB0aGlzLndyYXBwZXIuZXZlbnRNYXRlcmlhbHNbXCJkZWZhdWx0XCJdO1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwcGVyLmN1cnJlbnRTdGF0ZSA9IGUudHlwZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgU2VsZWN0b3IucHJvdG90eXBlLl9jbGljayA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHRoaXMud3JhcHBlci50cmlnZ2VyKGUudHlwZSk7XG4gICAgICB0aGlzLndyYXBwZXIuY2FsbFN1cGVyRXZlbnQuY2FsbCh0aGlzLndyYXBwZXIsIGUudHlwZSwgW3RoaXMud3JhcHBlcl0pO1xuICAgICAgdGhpcy5pc1NlbGVjdGVkID0gIXRoaXMuaXNTZWxlY3RlZDtcbiAgICAgIGlmICh0aGlzLmlzU2VsZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5tYXRlcmlhbCA9IHRoaXMud3JhcHBlci5ldmVudE1hdGVyaWFscy5jbGljaztcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcHBlci5jdXJyZW50U3RhdGUgPSBlLnR5cGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm1hdGVyaWFsID0gdGhpcy53cmFwcGVyLmV2ZW50TWF0ZXJpYWxzLmhvdmVyO1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwcGVyLmN1cnJlbnRTdGF0ZSA9IFwiaG92ZXJcIjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgU2VsZWN0b3IucHJvdG90eXBlLl9jbGVhciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHRoaXMud3JhcHBlci50cmlnZ2VyKGUudHlwZSk7XG4gICAgICB0aGlzLndyYXBwZXIuY2FsbFN1cGVyRXZlbnQuY2FsbCh0aGlzLndyYXBwZXIsIGUudHlwZSwgW3RoaXMud3JhcHBlcl0pO1xuICAgICAgaWYgKHRoaXMud3JhcHBlci5jdXJyZW50U3RhdGUgPSBcInJhbmdlXCIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tYXRlcmlhbCA9IHRoaXMud3JhcHBlci5ldmVudE1hdGVyaWFsc1tcImRlZmF1bHRcIl07XG4gICAgICAgIHRoaXMud3JhcHBlci5jdXJyZW50U3RhdGUgPSBcImRlZmF1bHRcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmlzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNlbGVjdG9yO1xuXG4gIH0pKHV0aWxzLkV2ZW50RW1pdHRlcik7XG5cbiAgbW9kdWxlLmV4cG9ydHMuU2t5Ym94ID0gQmFja2dyb3VuZFBsYW5lID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgZnVuY3Rpb24gQmFja2dyb3VuZFBsYW5lKCkge1xuICAgICAgY29uc29sZS5sb2coXCJ3b3dcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIEJhY2tncm91bmRQbGFuZTtcblxuICB9KSgpO1xuXG4gIG1vZHVsZS5leHBvcnRzLkxvd1BvbHlUZXJyYWluID0gTG93UG9seVRlcnJhaW4gPSAoZnVuY3Rpb24oKSB7XG5cbiAgICBmdW5jdGlvbiBMb3dQb2x5VGVycmFpbigpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwid293XCIpO1xuICAgIH1cblxuICAgIHJldHVybiBMb3dQb2x5VGVycmFpbjtcblxuICB9KSgpO1xuXG59KS5jYWxsKHRoaXMpO1xuXG4vLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNS4wLXByZVxuIiwiXG4vKlxuXG4gIFN0YWdlcyBpcyBhbiBvYmplY3QgdG8gbWFuYWdlLCB3ZWxsLCBzdGFnZXMuXG4gIHdoaWNoIGEgc3RhZ2UgaXMgdGhlIGVxdWl2YWxlbnQgdG8gdGhlIGdhbWUgY29uY2VwdCBvZiBhICdsZXZlbC4nXG4gIGJ1dCBzb21lb25lIGNvdWxkIHVzZSBtdWx0aXBsZSBzdGFnZXMgaW4gb25lIGxldmVsLCBzbyBJIGRvbid0IHdhbnQgdG8gYmUgcHVzaHkgYW5kIGNhbGwgaXQgYSAnbGV2ZWwnIG1hbmFnZXJcbiovXG5cblxuKGZ1bmN0aW9uKCkge1xuICB2YXIgSW5wdXQsIFNlbGVjdGlvbkdyaWQsIFNlbGVjdG9yLCBTdGFnZSwgU3RhZ2VNYW5hZ2VyLCB1dGlscyxcbiAgICBfX2hhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSxcbiAgICBfX2V4dGVuZHMgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKF9faGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfTtcblxuICB1dGlscyA9IHJlcXVpcmUoXCIuL191dGlsc1wiKTtcblxuICBJbnB1dCA9IHJlcXVpcmUoXCIuL19pbnB1dFwiKTtcblxuICBTZWxlY3RvciA9IHJlcXVpcmUoXCIuL19vYmplY3RzXCIpLlNlbGVjdG9yO1xuXG4gIC8qXG4gICAgICBTZWxlY3Rpb25HcmlkIENsYXNzXG4gICAgICBIZWxwZXIgY2xhc3MgZm9yIHNlbGVjdGluZyBvYmplY3RzIC8gZW50aXRpZXMgZnJvbSBhIGdyaWRcbiAgICAgIFNob3VsZCBiZSBhdXRvbWF0aWNhbGx5IGNyZWF0ZWQgd2hlblxuICAqL1xuXG5cbiAgU2VsZWN0aW9uR3JpZCA9IChmdW5jdGlvbihfc3VwZXIpIHtcblxuICAgIF9fZXh0ZW5kcyhTZWxlY3Rpb25HcmlkLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gU2VsZWN0aW9uR3JpZChkYXRhLCBlbmdpbmUsIHN0YWdlKSB7XG4gICAgICB2YXIgY2VudGVySW5kZXgsIGV2ZW5PZmZzZXQsIGhtLCBvLCB4LCB4MCwgeiwgejAsIF9yZWY7XG4gICAgICB0aGlzLmVuZ2luZSA9IGVuZ2luZTtcbiAgICAgIHRoaXMuc3RhZ2UgPSBzdGFnZTtcbiAgICAgIHRoaXMud2lkdGggPSBkYXRhLndpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSBkYXRhLmxlbmd0aDtcbiAgICAgIHRoaXMucGFkZGluZyA9IGRhdGEucGFkZGluZyB8fCAyO1xuICAgICAgdGhpcy54ID0gZGF0YS54O1xuICAgICAgdGhpcy56ID0gZGF0YS56O1xuICAgICAgdGhpcy5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BsYXlSYW5nZShzZWxlY3RvciwgNSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICAgIC8qIENvbnZlcnQgdGhlIGRhdGEgaW50byBhIG5vcm1hbGl6ZWQgZ3JpZCBkYXRhXG4gICAgICAqL1xuXG4gICAgICBldmVuT2Zmc2V0ID0gKF9yZWYgPSB1dGlscy5pc0ludChkYXRhLnggLyAyKSkgIT0gbnVsbCA/IF9yZWYgOiB7XG4gICAgICAgIDA6IDFcbiAgICAgIH07XG4gICAgICB4MCA9IH5+KGRhdGEueCAvIDIpO1xuICAgICAgejAgPSB+fihkYXRhLnogLyAyKTtcbiAgICAgIGNlbnRlckluZGV4ID0gbnVsbDtcbiAgICAgIHggPSAtMSAqIHgwO1xuICAgICAgeiA9IC0xICogejA7XG4gICAgICBobSA9IHV0aWxzLmlzQXJyYXkoZGF0YS5oZWlnaHRtYXApID8gZGF0YS5oZWlnaHRtYXAgOiAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfaSwgX3JlZjEsIF9yZXN1bHRzO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKG8gPSBfaSA9IDEsIF9yZWYxID0gZGF0YS54ICogZGF0YS56OyAxIDw9IF9yZWYxID8gX2kgPD0gX3JlZjEgOiBfaSA+PSBfcmVmMTsgbyA9IDEgPD0gX3JlZjEgPyArK19pIDogLS1faSkge1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2goZGF0YS5oZWlnaHRtYXApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH0pKCk7XG4gICAgICBkYXRhID0gaG0ubWFwKGZ1bmN0aW9uKGVsLCBpbmRleCwgYXJyKSB7XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICBub2RlID0ge1xuICAgICAgICAgIFwielwiOiB6LFxuICAgICAgICAgIFwieFwiOiB4LFxuICAgICAgICAgIFwieVwiOiBlbCxcbiAgICAgICAgICBcImlkXCI6IGluZGV4XG4gICAgICAgIH07XG4gICAgICAgIGlmICh4ID09PSAwICYmIHogPT09IDApIHtcbiAgICAgICAgICBub2RlLmNlbnRlciA9IHRydWU7XG4gICAgICAgICAgY2VudGVySW5kZXggPSBpbmRleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCA9PT0gKHgwIC0gZXZlbk9mZnNldCkpIHtcbiAgICAgICAgICB4ID0gLTEgKiB4MDtcbiAgICAgICAgICB6ICs9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeCsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmNlbnRlckluZGV4ID0gY2VudGVySW5kZXg7XG4gICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgdGhpcy5jcmVhdGVHcmlkKCk7XG4gICAgfVxuXG4gICAgU2VsZWN0aW9uR3JpZC5wcm90b3R5cGUuY3JlYXRlR3JpZCA9IGZ1bmN0aW9uKHNob3dIZWxwZXIpIHtcbiAgICAgIHZhciBkYXR1bSwgaCwgbWF0ZXJpYWwsIHBhZGRpbmcsIHBhcmVudCwgcG9zaXRpb24sIHNjZW5lLCBzZWxlY3Rvciwgc2l6ZSwgdywgX2ksIF9sZW4sIF9yZWY7XG4gICAgICBpZiAoc2hvd0hlbHBlciA9PSBudWxsKSB7XG4gICAgICAgIHNob3dIZWxwZXIgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZGF0YSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2VsZWN0b3JzID0gW107XG4gICAgICB3ID0gdGhpcy53aWR0aDtcbiAgICAgIGggPSB0aGlzLmhlaWdodDtcbiAgICAgIHBhZGRpbmcgPSB0aGlzLnBhZGRpbmcgfHwgMjtcbiAgICAgIHBhcmVudCA9IHRoaXM7XG4gICAgICBfcmVmID0gdGhpcy5kYXRhO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGRhdHVtID0gX3JlZltfaV07XG4gICAgICAgIHNpemUgPSB7XG4gICAgICAgICAgeDogdyxcbiAgICAgICAgICB5OiAwLFxuICAgICAgICAgIHo6IHdcbiAgICAgICAgfTtcbiAgICAgICAgcG9zaXRpb24gPSB7XG4gICAgICAgICAgeDogZGF0dW0ueCAqICh3ICsgcGFkZGluZyksXG4gICAgICAgICAgeTogZGF0dW0ueSAqIChoICsgcGFkZGluZyksXG4gICAgICAgICAgejogZGF0dW0ueiAqICh3ICsgcGFkZGluZylcbiAgICAgICAgfTtcbiAgICAgICAgbWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsO1xuICAgICAgICBzY2VuZSA9IHRoaXMuc3RhZ2Uuc2NlbmU7XG4gICAgICAgIHNlbGVjdG9yID0gbmV3IFNlbGVjdG9yKHtcbiAgICAgICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAgICAgICBzaXplOiBzaXplLFxuICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgICAgICBtYXRlcmlhbDogbWF0ZXJpYWxcbiAgICAgICAgfSwgc2NlbmUpO1xuICAgICAgICBkYXR1bS5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICBzZWxlY3Rvci5kYXR1bSA9IGRhdHVtO1xuICAgICAgICB0aGlzLnNlbGVjdG9ycy5wdXNoKHNlbGVjdG9yKTtcbiAgICAgICAgdGhpcy5zdGFnZS5tZXNoZXMucHVzaChzZWxlY3Rvci5tZXNoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmhlbHBlci5ncmlkLmNhbGwodGhpcywgc2hvd0hlbHBlcik7XG4gICAgfTtcblxuICAgIFNlbGVjdGlvbkdyaWQucHJvdG90eXBlLmZpbHRlckRhdGEgPSBmdW5jdGlvbih2ZWMzKSB7XG4gICAgICAvKlxuICAgICAgICBhcmd1bWVudCAndmVjMycgY2FuIGJlIGFuIG9iamVjdCBvciBhIFRIUkVFLlZlY3RvcjMgaW5zdGFuY2VcbiAgICAgICAgISBWZWN0b3IzIGluc3RhbmNlcyBkb24ndCBhbGxvdyB5b3UgdG8gaGF2ZSAndW5kZWZpbmVkJyBhcyBhIHZhbHVlLCBzbyB1c2luZyAnKicgaXMgdXNlZFxuICAgICAgICBpZTogICBmaWx0ZXJEYXRhKCBuZXcgVEhSRUUuVmVjdG9yMygwLCBcIipcIiwgXCIqXCIpICk7XG4gICAgICBcbiAgICAgICAgUGxhaW4gb2JqZWN0cyBkbyBhbGxvdyB1bmRlZmluZWQgdGhvdWdoLCBzbyB5b3UgY2FuIHBhc3MgaW4gYW4gb2JqZWN0IHdpdGggYWxsIHRoZSB2YWx1ZXMgeW91IHdhbnRcbiAgICAgICAgaWU6ICAgZmlsdGVyRGF0YSh7IHg6IDJ9KTtcbiAgICAgICovXG5cbiAgICAgIHZhciByZXN1bHRzO1xuICAgICAgaWYgKCF2ZWMzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgIHJlc3VsdHMgPSByZXN1bHRzLmNvbmNhdCh0aGlzLmRhdGEuZmlsdGVyKGZ1bmN0aW9uKGVsLCBpLCBhcnIpIHtcbiAgICAgICAgaWYgKGVsLnggPT09IHZlYzMueCB8fCB2ZWMzLnggPT09IFwiKlwiIHx8IHZlYzMueCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgaWYgKGVsLnkgPT09IHZlYzMueSB8fCB2ZWMzLnkgPT09IFwiKlwiIHx8IHZlYzMueSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBpZiAoZWwueiA9PT0gdmVjMy56IHx8IHZlYzMueiA9PT0gXCIqXCIgfHwgdmVjMy56ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcblxuICAgIFNlbGVjdGlvbkdyaWQucHJvdG90eXBlLmdldFJhbmdlID0gZnVuY3Rpb24odmVjMywgc3RlcHMpIHtcbiAgICAgIHZhciBjb3VudCwgZ2V0U3RlcENvdW50LCByZXN1bHRzLCB4LCBfaSwgX2xlbiwgX3JlZjtcbiAgICAgIGlmIChzdGVwcyA9PSBudWxsKSB7XG4gICAgICAgIHN0ZXBzID0gNDtcbiAgICAgIH1cbiAgICAgIGdldFN0ZXBDb3VudCA9IHV0aWxzLnN0ZXBzO1xuICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgX3JlZiA9IHRoaXMuZGF0YTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICB4ID0gX3JlZltfaV07XG4gICAgICAgIGNvdW50ID0gZ2V0U3RlcENvdW50KHZlYzMsIHgpO1xuICAgICAgICBpZiAoY291bnQgPCBzdGVwcyArIDEpIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2goeCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG5cbiAgICBTZWxlY3Rpb25HcmlkLnByb3RvdHlwZS5nZXRSYW5nZUZyb21TZWxlY3RvciA9IGZ1bmN0aW9uKHNlbGVjdG9yLCBzdGVwcykge1xuICAgICAgaWYgKCEoc2VsZWN0b3IgaW5zdGFuY2VvZiBTZWxlY3RvcikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZ2V0UmFuZ2Uoc2VsZWN0b3IuZGF0dW0sIHN0ZXBzKTtcbiAgICB9O1xuXG4gICAgU2VsZWN0aW9uR3JpZC5wcm90b3R5cGUuZGlzcGxheVJhbmdlID0gZnVuY3Rpb24oc2VsZWN0b3IsIHN0ZXBzLCBjbGVhck90aGVyUmFuZ2VzKSB7XG4gICAgICB2YXIgc2VsZWN0b3JzO1xuICAgICAgaWYgKGNsZWFyT3RoZXJSYW5nZXMgPT0gbnVsbCkge1xuICAgICAgICBjbGVhck90aGVyUmFuZ2VzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghKHNlbGVjdG9yIGluc3RhbmNlb2YgU2VsZWN0b3IpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChjbGVhck90aGVyUmFuZ2VzKSB7XG4gICAgICAgIHRoaXMuY2xlYXJBbGxSYW5nZXMoKTtcbiAgICAgIH1cbiAgICAgIHNlbGVjdG9ycyA9IHRoaXMuZ2V0UmFuZ2VGcm9tU2VsZWN0b3Ioc2VsZWN0b3IsIHN0ZXBzKTtcbiAgICAgIHJldHVybiBzZWxlY3RvcnMuZm9yRWFjaChmdW5jdGlvbihlbCkge1xuICAgICAgICByZXR1cm4gZWwuc2VsZWN0b3IuY2hhbmdlTWF0ZXJpYWxTdGF0ZS5jYWxsKGVsLnNlbGVjdG9yLCBcInJhbmdlXCIsIHRydWUpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIFNlbGVjdGlvbkdyaWQucHJvdG90eXBlLmNsZWFyQWxsUmFuZ2VzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdHlwZTtcbiAgICAgIHR5cGUgPSBcImRlZmF1bHRcIjtcbiAgICAgIHJldHVybiB0aGlzLnNlbGVjdG9ycy5mb3JFYWNoKGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIHJldHVybiBlbC5yZXNldE1hdGVyaWFsLmNhbGwoZWwsIHR5cGUpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIFNlbGVjdGlvbkdyaWQucHJvdG90eXBlLmhlbHBlciA9IHtcbiAgICAgIGdyaWQ6IGZ1bmN0aW9uKHJlbW92ZSkge1xuICAgICAgICB2YXIgZ3JpZCwgcGFkZGluZywgc2l6ZSwgc3RlcCwgd2lkdGg7XG4gICAgICAgIGlmIChyZW1vdmUgPT0gbnVsbCkge1xuICAgICAgICAgIHJlbW92ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXMpO1xuICAgICAgICBwYWRkaW5nID0gdGhpcy5wYWRkaW5nO1xuICAgICAgICB3aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICAgIHNpemUgPSAoKHdpZHRoICsgcGFkZGluZykgKiB0aGlzLngpIC8gMjtcbiAgICAgICAgc3RlcCA9IChzaXplICogMikgLyAod2lkdGggKyAocGFkZGluZyAvIDIpKTtcbiAgICAgICAgZ3JpZCA9IG5ldyBUSFJFRS5HcmlkSGVscGVyKHNpemUsIHN0ZXApO1xuICAgICAgICB0aGlzLl9oZWxwZXJncmlkID0gZ3JpZDtcbiAgICAgICAgZ3JpZC5zZXRDb2xvcnMoXCIjMjI0XCIsIFwiIzIyNFwiKTtcbiAgICAgICAgdGhpcy5zdGFnZS5zY2VuZS5hZGQoZ3JpZCk7XG4gICAgICAgIHJldHVybiBncmlkO1xuICAgICAgfSxcbiAgICAgIHJhbmdlOiBmdW5jdGlvbigpIHt9XG4gICAgfTtcblxuICAgIHJldHVybiBTZWxlY3Rpb25HcmlkO1xuXG4gIH0pKHV0aWxzLkV2ZW50RW1pdHRlcik7XG5cbiAgU3RhZ2UgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG5cbiAgICBfX2V4dGVuZHMoU3RhZ2UsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBTdGFnZShwYXJlbnQsIG5hbWUsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBiZWZvcmVMb2FkZWQsIGNhbGxiYWNrcywgY2FtZXJhLCB0aGF0O1xuICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICB0aGlzLnJlbmRlcmVyID0gcGFyZW50LnJlbmRlcmVyO1xuICAgICAgdGhpcy5uYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdGhpcy5zY2VuZSA9IG9wdGlvbnMuc2NlbmU7XG4gICAgICBjYW1lcmEgPSBvcHRpb25zLmNhbWVyYTtcbiAgICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuICAgICAgdGhpcy5tZXNoZXMgPSBbXTtcbiAgICAgIGJlZm9yZUxvYWRlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICB0aGlzLklucHV0ID0gbmV3IElucHV0LkludGVyZmFjZSh0aGlzLCBwYXJlbnQpO1xuICAgICAgICB0aGlzLk1vdXNlRGV0ZWN0b3IgPSBuZXcgSW5wdXQuTW91c2VEZXRlY3Rpb24odGhpcywgcGFyZW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXMub25sb2FkLmNhbGwodGhpcyk7XG4gICAgICB9O1xuICAgICAgdGhhdCA9IHRoaXM7XG4gICAgICB0aGF0Lm9uKFwibG9hZFwiLCBiZWZvcmVMb2FkZWQuYmluZCh0aGF0KSk7XG4gICAgICBjYWxsYmFja3MgPSB7XG4gICAgICAgIHNjb3BlOiB0aGF0LFxuICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihyZXNwb25zZVRleHQpIHtcbiAgICAgICAgICB0aGF0LmRhdGEgPSByZXNwb25zZVRleHQ7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJFbmdpbmUgOjogJ1wiICsgbmFtZSArIFwiJyBhamF4J2QuIFwiKTtcbiAgICAgICAgICB0aGF0LmRhdGEuZ3JpZCA9IHRoYXQuZ3JpZCA9IG5ldyBTZWxlY3Rpb25HcmlkKHRoYXQuZGF0YS5ncmlkLCB0aGF0LnBhcmVudCwgdGhhdCk7XG4gICAgICAgICAgcmV0dXJuIHRoYXQudHJpZ2dlcihcImxvYWRcIik7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciByZXRyaWV2aW5nIGRhdGEgZm9yIFN0YWdlXCIpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKG9wdGlvbnMudXJsICE9PSB2b2lkIDApIHtcbiAgICAgICAgdXRpbHMuZ2V0SlNPTihvcHRpb25zLnVybCwgY2FsbGJhY2tzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBTdGFnZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uKHVybFRvSnNvbikge1xuICAgICAgLypcbiAgICAgICAgaW5jYXNlIHdhc24ndCBvcmlnaW5hbGx5IHBhc3NlZCBpblxuICAgICAgKi9cblxuICAgICAgdmFyIGNhbGxiYWNrcywgdGhhdDtcbiAgICAgIHRoYXQgPSB0aGlzO1xuICAgICAgY2FsbGJhY2tzID0ge1xuICAgICAgICBzY29wZTogdGhhdCxcbiAgICAgICAgc3VjY2VzczogZnVuY3Rpb24ocmVzcG9uc2VUZXh0KSB7XG4gICAgICAgICAgdGhhdC5kYXRhID0gcmVzcG9uc2VUZXh0O1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiRW5naW5lIDo6ICdcIiArIG5hbWUgKyBcIicgYWpheCdkLiBcIik7XG4gICAgICAgICAgdGhhdC5kYXRhLmdyaWQgPSB0aGF0LmdyaWQgPSBuZXcgU2VsZWN0aW9uR3JpZCh0aGF0LmRhdGEuZ3JpZCwgdGhhdC5wYXJlbnQsIHRoYXQpO1xuICAgICAgICAgIHJldHVybiB0aGF0LnRyaWdnZXIoXCJsb2FkXCIpO1xuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgcmV0cmlldmluZyBkYXRhIGZvciBTdGFnZVwiKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmICh1cmxUb0pzb24gIT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gdXRpbHMuZ2V0SlNPTih1cmxUb0pzb24sIGNhbGxiYWNrcyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFN0YWdlLnByb3RvdHlwZS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIC8qXG4gICAgICAgIG1lYW50IHRvIGJlIG92ZXJ3cml0dGVuIGJ5IHRoZSB1c2VyXG4gICAgICAgIGFsdGVybmF0aXZlIGlzOiBcbiAgICAgICAgfCBAb24gXCJsb2FkXCIsIGZuXG4gICAgICAgIHdoaWNoIHdpbGwgYmUgdHJpZ2dlcmVkIG9uIGxvYWRpbmdcbiAgICAgICovXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgU3RhZ2UucHJvdG90eXBlLmxvb2tBdCA9IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICB0aGlzLmNhbWVyYS51cCA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDEpO1xuICAgICAgcmV0dXJuIHRoaXMuY2FtZXJhLmxvb2tBdChwb2ludCB8fCB0aGlzLnNjZW5lKTtcbiAgICB9O1xuXG4gICAgU3RhZ2UucHJvdG90eXBlLnNldENhbWVyYVRvSXNvbWV0cmljID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZGlzdGFuY2VGcm9tQ2VudGVyb2ZHcmlkVG9FZGdlLCBoLCB3LCB4LCB4RGlzdGFuY2UsIHlEaXN0YW5jZSwgeiwgekRpc3RhbmNlO1xuICAgICAgaWYgKCF0aGlzLmdyaWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdyA9IHRoaXMuZ3JpZC53aWR0aDtcbiAgICAgIGggPSB0aGlzLmdyaWQuaGVpZ2h0O1xuICAgICAgeCA9IHRoaXMuZ3JpZC54O1xuICAgICAgeiA9IHRoaXMuZ3JpZC56O1xuICAgICAgZGlzdGFuY2VGcm9tQ2VudGVyb2ZHcmlkVG9FZGdlID0gdXRpbHMucHl0aGFnKHcgKiB4LCBoICogeik7XG4gICAgICB5RGlzdGFuY2UgPSBkaXN0YW5jZUZyb21DZW50ZXJvZkdyaWRUb0VkZ2UgLyAyO1xuICAgICAgekRpc3RhbmNlID0gKHcgKyAodGhpcy5ncmlkLnBhZGRpbmcgfHwgMikpICogejtcbiAgICAgIHhEaXN0YW5jZSA9ICh3ICsgKHRoaXMuZ3JpZC5wYWRkaW5nIHx8IDIpKSAqIHg7XG4gICAgICB0aGlzLmNhbWVyYS5wb3NpdGlvbi5zZXRaKHpEaXN0YW5jZSk7XG4gICAgICB0aGlzLmNhbWVyYS5wb3NpdGlvbi5zZXRZKHlEaXN0YW5jZSk7XG4gICAgICB0aGlzLmNhbWVyYS5wb3NpdGlvbi5zZXRYKHhEaXN0YW5jZSk7XG4gICAgICB0aGlzLmNhbWVyYS5sb29rQXQobmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgMCkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAvKlxuICAgICAgXG4gICAgICBcbiAgICAgIEBjYW1lcmEucm90YXRpb24ueiA9IDAuMjVcbiAgICAgICovXG5cbiAgICB9O1xuXG4gICAgU3RhZ2UucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIEwsIGV4dGVudCwgZ2VvbWV0cnksIGxpbmUsIG1hdGVyaWFsO1xuICAgICAgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcbiAgICAgIGV4dGVudCA9IDUwMDA7XG4gICAgICBnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIC1leHRlbnQpKTtcbiAgICAgIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2gobmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgZXh0ZW50KSk7XG4gICAgICBnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKG5ldyBUSFJFRS5WZWN0b3IzKC1leHRlbnQsIDAsIDApKTtcbiAgICAgIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2gobmV3IFRIUkVFLlZlY3RvcjMoZXh0ZW50LCAwLCAwKSk7XG4gICAgICBnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKG5ldyBUSFJFRS5WZWN0b3IzKDAsIC1leHRlbnQsIDApKTtcbiAgICAgIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2gobmV3IFRIUkVFLlZlY3RvcjMoMCwgZXh0ZW50LCAwKSk7XG4gICAgICBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCh7XG4gICAgICAgIGNvbG9yOiAweDU1NTU1NVxuICAgICAgfSk7XG4gICAgICBsaW5lID0gbmV3IFRIUkVFLkxpbmUoZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgICAgIHRoaXMuc2NlbmUuYWRkKGxpbmUpO1xuICAgICAgdGhpcy5zZXRDYW1lcmFUb0lzb21ldHJpYygpO1xuICAgICAgdGhpcy5wYXJlbnQucmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKTtcbiAgICAgIEwgPSB0aGlzLnBhcmVudC5jbG9jay5sb29wKFwicmVuZGVyXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQucmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKTtcbiAgICAgIH0sIG51bGwsIHRoaXMpO1xuICAgICAgTFtcImZvclwiXSh7XG4gICAgICAgIGludGVydmFsOiAxN1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQuY2xvY2suc3RhcnQoKTtcbiAgICB9O1xuXG4gICAgU3RhZ2UucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5kZXN0cm95KHRoaXMubmFtZSk7XG4gICAgfTtcblxuICAgIHJldHVybiBTdGFnZTtcblxuICB9KSh1dGlscy5FdmVudEVtaXR0ZXIpO1xuXG4gIFN0YWdlTWFuYWdlciA9IGZ1bmN0aW9uKGVuZ2luZSkge1xuICAgIC8qIEBQUklWQVRFU1xuICAgICovXG5cbiAgICB2YXIgbGlzdCwgcGFyZW50O1xuICAgIHBhcmVudCA9IGVuZ2luZTtcbiAgICAvKiBAUFVCTElDU1xuICAgICovXG5cbiAgICBsaXN0ID0ge307XG4gICAgdGhpcy5saXN0ID0gW107XG4gICAgdGhpcy5jcmVhdGUgPSBmdW5jdGlvbihuYW1lLCBvcHRpb25zKSB7XG4gICAgICB2YXIgbywgc3RhZ2U7XG4gICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbyA9IG9wdGlvbnMgfHwge307XG4gICAgICBzdGFnZSA9IG5ldyBTdGFnZShwYXJlbnQsIG5hbWUsIG8pO1xuICAgICAgdGhpcy5saXN0LnB1c2gobmFtZSk7XG4gICAgICBsaXN0W25hbWUudG9Mb3dlckNhc2UoKV0gPSBzdGFnZTtcbiAgICAgIHJldHVybiBsaXN0W25hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgfTtcbiAgICB0aGlzLmN1cnJlbnQgPSB2b2lkIDA7XG4gICAgdGhpcy5kZXN0cm95ID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgcmV0dXJuIGRlbGV0ZSBsaXN0W25hbWVdO1xuICAgIH07XG4gICAgdGhpcy5sb2FkID0gZnVuY3Rpb24obmFtZSwgdHJhbnNpdGlvbikge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBTdGFnZU1hbmFnZXI7XG5cbn0pLmNhbGwodGhpcyk7XG5cbi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS41LjAtcHJlXG4iLCJcbi8qXG4gICAgICB1dGlsaXRpZXNcbiovXG5cblxuKGZ1bmN0aW9uKCkge1xuICB2YXIgRXZlbnRFbWl0dGVyLFxuICAgIF9fc2xpY2UgPSBbXS5zbGljZTtcblxuICBtb2R1bGUuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbihtc2cpIHtcbiAgICB2YXIgcHJlZml4O1xuICAgIHRoaXMubG9ncy51bnNoaWZ0KG1zZyk7XG4gICAgaWYgKCF0aGlzLmRlYnVnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHByZWZpeCA9IFwiRW5naW5lIDo6IFwiO1xuICAgIGlmICh0eXBlb2YgbXNnID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zb2xlLmxvZyhwcmVmaXggKyBtc2cpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhtc2cpO1xuICAgIH1cbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cy5leHRlbmQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYmFzZSwgZXh0ZW5kZWQsIGtleSwgb2JqLCBvYmpzLCBfaSwgX2xlbjtcbiAgICBvYmpzID0gMSA8PSBhcmd1bWVudHMubGVuZ3RoID8gX19zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkgOiBbXTtcbiAgICBpZiAob2Jqcy5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm4gb2Jqc1swXTtcbiAgICB9XG4gICAgZXh0ZW5kZWQgPSBvYmpzWzBdO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gb2Jqcy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgb2JqID0gb2Jqc1tfaV07XG4gICAgICBiYXNlID0gb2JqO1xuICAgICAgZm9yIChrZXkgaW4gYmFzZSkge1xuICAgICAgICBleHRlbmRlZFtrZXldID0gYmFzZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXh0ZW5kZWQ7XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMuaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24odGhpbmcpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRoaW5nID09PSBcIltvYmplY3QgQXJyYXldXCIpO1xuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzLmlzSW50ID0gZnVuY3Rpb24obnVtKSB7XG4gICAgaWYgKG51bSAvIE1hdGguZmxvb3IobnVtKSA9PT0gMSB8fCBudW0gLyBNYXRoLmZsb29yKG51bSkgPT09IC0xKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzLnB5dGhhZyA9IGZ1bmN0aW9uKEEsIEIsIGh5cG90ZW51c2UpIHtcbiAgICB2YXIgYTIsIGIyLCByZXN1bHQ7XG4gICAgaWYgKCEoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoQiA9PT0gbnVsbCkge1xuICAgICAgcmVzdWx0ID0gKE1hdGgucG93KGh5cG90ZW51c2UsIDIpKSAtIE1hdGgucG93KEEsIDIpO1xuICAgICAgcmVzdWx0ID0gTWF0aC5zcXJ0KHJlc3VsdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICBhMiA9IE1hdGgucG93KEEsIDIpO1xuICAgICAgYjIgPSBNYXRoLnBvdyhCLCAyKTtcbiAgICAgIHJlc3VsdCA9IE1hdGguc3FydChhMiArIGIyKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzLnN0ZXBzID0gZnVuY3Rpb24oYmFzZSwgdGFyZ2V0LCB5QXhpcykge1xuICAgIHZhciB4LCB5LCB6O1xuICAgIGlmICh5QXhpcyA9PSBudWxsKSB7XG4gICAgICB5QXhpcyA9IGZhbHNlO1xuICAgIH1cbiAgICB4ID0gTWF0aC5hYnMoYmFzZS54IC0gdGFyZ2V0LngpO1xuICAgIHogPSBNYXRoLmFicyhiYXNlLnogLSB0YXJnZXQueik7XG4gICAgeSA9IHlBeGlzID8gTWF0aC5hYnMoYmFzZS55IC0gdGFyZ2V0LnkpIDogMDtcbiAgICByZXR1cm4geCArIHkgKyB6O1xuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzLmdldEpTT04gPSBmdW5jdGlvbih1cmwsIGNhbGxiYWNrcykge1xuICAgIHZhciBhamF4LCBkYXRhLCBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSBjYWxsYmFja3MgfHwge307XG4gICAgZGF0YSA9IHZvaWQgMDtcbiAgICBhamF4ID0gJC5nZXRKU09OKHVybCk7XG4gICAgcmV0dXJuIGFqYXguY29tcGxldGUoZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkYXRhID0gJC5wYXJzZUpTT04oYWpheC5yZXNwb25zZVRleHQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBvcHRpb25zLmVycm9yLmNhbGwob3B0aW9ucy5zY29wZSB8fCBudWxsLCBlLCBhamF4KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgb3B0aW9ucy5zdWNjZXNzLmNhbGwob3B0aW9ucy5zY29wZSB8fCBudWxsLCBkYXRhLCBhamF4KTtcbiAgICB9KTtcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cy5nZXRNb3VzZVBvc2l0aW9uID0gZnVuY3Rpb24oJGUpIHtcbiAgICB2YXIgbm9ybWFsaXplZCwgeCwgeTtcbiAgICBpZiAoISgkZS50eXBlID09PSBcImNsaWNrXCIgfHwgJGUudHlwZSA9PT0gXCJtb3VzZW1vdmVcIikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgeCA9ICRlLmNsaWVudFg7XG4gICAgeSA9ICRlLmNsaWVudFk7XG4gICAgbm9ybWFsaXplZCA9IHtcbiAgICAgIFwieFwiOiAoeCAvIHdpbmRvdy5pbm5lcldpZHRoKSAqIDIgLSAxLFxuICAgICAgXCJ5XCI6IC0oeSAvIHdpbmRvdy5pbm5lckhlaWdodCkgKiAyICsgMVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5LFxuICAgICAgbm9ybWFsaXplZDogbm9ybWFsaXplZFxuICAgIH07XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICAgICAgdGhpcy5fX2V2ZW50cyA9IHt9O1xuICAgIH1cblxuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbihuYW1lLCBmbiwgY29udGV4dCkge1xuICAgICAgaWYgKHRoaXMuX19ldmVudHMgPT09IHZvaWQgMCkge1xuICAgICAgICB0aGlzLl9fZXZlbnRzID0ge307XG4gICAgICB9XG4gICAgICB0aGlzLl9fZXZlbnRzW25hbWVdID0ge1xuICAgICAgICBmbjogZm4sXG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICAgIH07XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICBkZWxldGUgdGhpcy5fX2V2ZW50c1tuYW1lXTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIGlmICh0aGlzLl9fZXZlbnRzID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX19ldmVudHNbbmFtZV07XG4gICAgfTtcblxuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uKG5hbWUsIGFyZ3MpIHtcbiAgICAgIHZhciBmO1xuICAgICAgaWYgKGFyZ3MgPT0gbnVsbCkge1xuICAgICAgICBhcmdzID0gW107XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fX2V2ZW50cyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGYgPSB0aGlzLmdldChuYW1lKTtcbiAgICAgIGlmIChmID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZi5mbi5hcHBseShmLmNvbnRleHQsIGFyZ3MpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHJldHVybiBFdmVudEVtaXR0ZXI7XG5cbiAgfSkoKTtcblxufSkuY2FsbCh0aGlzKTtcblxuLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjUuMC1wcmVcbiIsIihmdW5jdGlvbigpIHtcblxuICByZXF1aXJlKFwiLi9fYmFzZVwiKTtcblxuICByZXF1aXJlKFwiLi9tYWluXCIpO1xuXG59KS5jYWxsKHRoaXMpO1xuXG4vLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNS4wLXByZVxuIiwiKGZ1bmN0aW9uKCkge1xuXG5cblxufSkuY2FsbCh0aGlzKTtcblxuLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjUuMC1wcmVcbiJdfQ==
