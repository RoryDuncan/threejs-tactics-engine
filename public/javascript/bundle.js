(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

/*
    three-js Tactics Engine
*/


(function() {
  var Clock, Stage, ThreeTacticsEngine, utils;

  console.log("_base");

  utils = require("./_utils");

  Stage = require("./_stage");

  Clock = require("./_clock");

  ThreeTacticsEngine = function() {
    /*
      @PRIVATES
    */

    var THREE, configLoaded, eventMethods, log, name, scene, that, _i, _len;
    if (self.THREE === void 0 || self.$ === void 0) {
      throw new Error("The engine is dependent on THREE.js and jQuery, which one of was not found, or not in the global scope.");
    }
    THREE = self.THREE;
    configLoaded = false;
    scene = false;
    that = this;
    this.debug = true;
    this.logs = [];
    log = (function(msg) {
      return utils.log.call(this, msg, this.logs);
    }).bind(this);
    this.log = log;
    /*
      @PUBLICS
    */

    this.load = function() {};
    this.renderQueue = [];
    this.stage = new Stage(this);
    this.clock = new Clock();
    /* 
      Dynamically add event methods from the clock object (which has an event emitter built into it.)
      this array is the names of the methods that will be added to the events object
    */

    eventMethods = ["on", "off", "defer", "getEvents", "trigger", "remove"];
    this.events = {};
    for (_i = 0, _len = eventMethods.length; _i < _len; _i++) {
      name = eventMethods[_i];
      this.events[name] = this.clock[name];
    }
    this.init = function(options) {
      var config;
      config = $.getJSON((options || {}).config);
      if (typeof config === void 0) {
        return;
      }
      that = this;
      return config.complete(function() {
        var renderer;
        try {
          that.config = $.parseJSON(config.responseText);
        } catch (e) {
          log(e);
          throw new Error("JSON was not parsed.");
        }
        configLoaded = true;
        log("Configuration Loaded.");
        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        that.renderer = renderer;
        log("Initialized.");
        if ((options || {}).autostart === true) {
          return that.start();
        }
      });
    };
    this.start = function() {
      var stage;
      if (!configLoaded) {
        return;
      }
      stage = this.stage.create("test", {
        "url": "json/test.json"
      });
      stage.camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 0.1, 10000);
      return stage.scene = new THREE.Scene();
    };
    return this;
  };

  self.Engine = new ThreeTacticsEngine();

  Engine.init({
    "config": "json/config.json",
    "autostart": true
  });

  console.log(Engine);

}).call(this);

// Generated by CoffeeScript 1.5.0-pre

},{"./_clock":2,"./_stage":4,"./_utils":5}],2:[function(require,module,exports){

  /*
    Modified version from

    +-+- GITHUB -+-+
  unmodified version located at:
    https://github.com/RoryDuncan/ClockEventAggreggator
    
    +-+- DOCUMENTATION -+-+
    http://roryduncan.github.io/ClockEventAggreggator/

  */

var utils = require("./_utils");

var Clock = function(args) {

  /* Helpers */

  // Helper for merging objects
  extend = utils.extend;

  var isArray = function(thing){
    // assume 'thing' is not undefined or null as it will throw a TypeError.
    if (typeof thing === "string") return false;
    if ( (thing).length === undefined) return false;
    else return true; 
  }


  /*  Timeline related variables  */

  var defaults = {useRAF: true, tickInterval: 16, autostart: false},
      options = extend(defaults, args),
      ticks = 0,
      lastTick = 0,
      startTime = 0,

      // the 'clock' time, calculated with delta and clockSpeed variables.
      elapsedTime = 0,

      // id for requestAnimationFrame
      rAFID = null,

      // whether this is every other tick
      tick_n = false,

      // the amount of real-time that has passed between ticks
      delta = 0,
      actualElapsedTime = 0;

      // fallback time for setTimeout
      this.tickInterval = options.tickInterval,

      running = false,

      // speed at which the clock runs
      clockspeed = 1,

      // reference
      self = this,

      // wether or not to use request Animation Frame
      useRAF = options.useRAF,

      // dynamic function for rAF or setTimeout functionality,
      tickCallee = function() {
        // set to start() initially in case called before start somehow.
        this.start();
      };

      
      


  /*  Event Aggregator related variables  */

  var events = {};
      events.nominal = {};
      events.ordinal = {};
      events.loops = {};

  
  /*  Internal Functions */

  //  clock's tick mechanism
  var tick = function() {
    
    var now = new Date().getTime(); //cache
    if (!running) return;
    
    ticks += 1 * clockspeed;
    tick_n = !tick_n;
    if (this.debug && tick_n) this.log();

    
    this.delta = delta = (now - lastTick) * clockspeed;

    lastTick = now;

    elapsedTime += delta;

    actualElapsedTime = ( now - startTime );

    this.errorMargin = actualElapsedTime - elapsedTime; 


    // singular events take precedence over loop events.
    triggerCurrentEvents();
    triggerLoopEvents();

    this.trigger("tick");

    
    rAFID = tickCallee();

    return ticks;
  };
  
  var buildDefaultEvents = function() {

    var defaultEvents = ["tick", "start", "after:start", "pause", "resume"],
        addEvent = function(name){

          events.ordinal[name] = [];
        };

    defaultEvents.forEach(addEvent);

  };
  buildDefaultEvents();

  var triggerOrdinalEvents = function() {

    var now = ~~(elapsedTime / 100) * 100;

    if ( events.ordinal[ now ] === undefined ) {return false;}  // return false in case of checks

    
    var eot = events.ordinal[ now ];

    // events.ordinal will be an array, so loop over each function in it.
    for (var _x = 0, _xx = eot.length; _x < _xx; _x++) {

      var fn = eot[_x].fn,
          ctx = eot[_x].context,
          args = eot[_x].args;

      fn.apply(ctx, args);
    }

    // delete it, so that it won't trigger the next ticks that round down to this time.
    delete events.ordinal[ now ];

    return true; // return true in case of checks
  };

  var triggerLoopEvents = function() {

    var now = ~~elapsedTime;

    var expired = [];

    for (var key in events.loops) {

      var loop = events.loops[ key ]

      if (loop.start <= now &&          // Check if it is 'allowed' to start.
          loop.checkInterval( now ) &&  // Check whether the loop should fire at the current time
          loop.delete === false ) {      // Check if it is to be deleted
          
          // there is a reference to _this_ inside of loop,
          // so sending the loop itself as context is enough.
          loop.calledAt.push( now );
          loop.now = now;
          
          loop.fn.apply( loop.scope, loop.args );
          
          loop.lastCall = now;
          loop.calls++;
      }
      // check whether it has expired
      if (loop.stop === now || loop.calls === loop.maxIntervals || loop.delete === true) {
        // put it in the box where bad loops go.
        expired.push( key );
      }
    }

    // Delete any loops marked
    for (var i = 0, ii = expired.length; i < ii; i++) {
      var name = expired[i];
      delete events.loops[name];
    }
  };


  /*  Bindings  */

  this.tick = tick.bind(this);
  var triggerLoopEvents = triggerLoopEvents.bind(this);
  var  triggerCurrentEvents = triggerOrdinalEvents.bind(this);
  


  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
  /* * * * * * * * * * * * *   API   * * * * * * * * * * * * */
  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


  /*  Clock-related methods  */

  this.start = function() {

    if (running === true) { return this; } // simple tests to prevent multiple starts

    // tickLoop is a dynamically constructed function to remove an 'if' statement inside of tick() .
    var tickLoop;  

    if (useRAF === true) {
      tickLoop = new Function(" var id = window.requestAnimationFrame( this.tick ); return id;");
    }
    else {
      tickLoop = new Function(" var id = window.setTimeout(this.tick, this.tickInterval);return id;" );
    }
    // bind into this context
    tickCallee = tickLoop.bind(this);

    this.trigger("before:start");

    var now = new Date().getTime();
    this.startTime = startTime = now;
    running = true;
    lastTick = now;
    this.tick();

    this.enablePauseOnBlur();
    this.trigger("start");

    return this;
  }.bind(this);

  this.stop = function(){

    running = false;
    //reset event lists
    events.nominal = {};
    events.ordinal = [];
    events.loops = {};

    buildDefaultEvents();

    //reset counters
    ticks = 0;
    elapsedTime = 0;
    this.startTime = startTime = 0;

    return this;
  }.bind(this);

  this.reset = function(){

    this.reset();
    this.start();
    return this;
  }.bind(this);

  this.pause = function() {
    running = false;
    this.trigger("pause");
    return this;
  }.bind(this);

  this.resume = function() {
    if (running === true) return this;
    running = true;
    lastTick = new Date().getTime();
    this.tick();
    this.trigger("resume");
    return this;
  }.bind(this);

  this.clockScalar = function(multiplier) {
    // a relative way to affect the clock
    clockspeed *= multiplier || 1;
  };

  this.setClockSpeed = function(value) {
    // for manually entering a speed value
    clockspeed = value || clockspeed;
  };

  this.enablePauseOnBlur = function() {
    // called on start
    // requestAnimationFrame natively pauses onblur, but, this clock doesn't
    // so I've programmed the functionality into it. 

    window.onblur = function(){self.pause();}
    window.onfocus = function(){self.resume();};
  };

  this.disablePauseOnBlur = function(){
    window.onblur = function(){return null};
    window.onfocus = function(){return null};
  };
  
  this.ticks = function(){ return ticks; };

  this.milliseconds = function(){ return elapsedTime;};

  this.seconds = function(){ return elapsedTime / 1000 ; };

  this.minutes = function(){ return (this.seconds() / 60); };

  this.debug = options.debug || false;

  // if debug is true, log is automatically called each tick
  this.log = function() {

    console.clear();
    if (useRAF) console.log("<Using requestAnimationFrame>");
    else console.log("<Using setTimeout>");
    console.log("ticks:", ticks);
    console.log("delta:", delta);
    console.log("lastTick(should change)", ~~lastTick)
    console.log("elapsed time:", elapsedTime / 1000);
    console.log("elapsed seconds:", ~~(elapsedTime / 1000));
    console.log("actual elapsed time:", actualElapsedTime / 1000);
    console.warn("%cdifference (in seconds): " + (this.errorMargin / 1000), "color: #a00" );
    console.log("Ignore differences if you have called pause at any time.");
    console.log("Estimated FPS:", ~~(ticks / ( elapsedTime / 1000 )));
  };

  this.time = this.now = function(){ return elapsedTime; };



  /*  Event-related methods  */
  
  this.trigger = function(eventName) {

    if (events.nominal[eventName] === undefined) return this;

    var l = events.nominal[eventName].length

    for (var _x = 0, _xx = l; _x < _xx; _x++) {

      // wow, much length, many chars, such scary.
      var fn = events.nominal[eventName][_x].fn,
          ctx = events.nominal[eventName][_x].context,
          args = events.nominal[eventName][_x].args;

      fn.apply(ctx, args);

    }
    return this;
  };

  this.on = function( eventName, fn /* [, args, context ] */ ) {

    var context = arguments[3] || this, args = arguments[2] || [];

    // create an array for the event
    events.nominal[eventName] = events.nominal[eventName] || []

    var scope = this; // all events default to the scope of the Timeline object.

    events.nominal[eventName].push({
      'fn': fn,
      'args': args,
      'context': context
    });
    return this;
  };

  this.at = function( elapsedMS, fn /* [, args, context ] */ ) {
    if (elapsedMS === undefined) {throw new Error("at() method requires a clock-time passed in as first parameter."); return;}
    if (fn === undefined) {throw new Error("at() method requires a function passed in as second parameter."); return;}

    var context = arguments[3] || null, args = arguments[2] || this;

    var addTime = function( time ) {

      var t = time.toString();
      events.ordinal[ time ] = events.ordinal[ time ] || [];
      events.ordinal[ time ].push({
        "fn": fn,
        "context": context,
        "args": args
      });

    };

    if ( !isArray(elapsedMS) ) {
      addTime( elapsedMS );
      
      return this;

    }

      elapsedMS.forEach( addTime );


      return this;
  };

  this.after = function( milliseconds, fn /* [, args, context ] */ ) {
    var args = arguments[2], context = arguments[3];
    this.at( elapsedTime + milliseconds, fn, args, context );
  };

  this.loop = function( uniqueName, fn, args, scope ) {

    /*
        this.loop() returns a new loop object, which to alter timing-related options
        you call it's .for() method. 
        
        EX:
        var x = this.loop(*args).for(*args);
    */

    if (!uniqueName) return this;

    var self = this,
        defaults = {
          "autostart": true,
          "start": ~~elapsedTime,
          "stop": Infinity, 
          "interval": Infinity, 
          "maxIntervals": Infinity, 
          "duration": 0, 
          "calledAt": [],
          "startDelay": 0
        },
        required = {
          "name":uniqueName,
          "fn": fn,
          "scope": scope || self,
          "calls": 0,
          "parent": self,
          "args": args || []
        };

    // the loop object that will be returned
    var Loop = function(options) {


      extend(this, defaults, required);

      // the check to determine if the loop is called
      this.checkInterval = function(now) {
        var start = this.start,
            interval = this.interval,
            duration = this.duration,
            doesIntervalMatchNow = (now - (start + this.startDelay))  % (interval + duration),
            intervalHasPassed = now - (this.lastCall === undefined ? start : this.lastCall);
  
        /*
        console.clear();
        console.log("name:", this.name);
        console.log("Delta:", self.delta );
        console.log("-----");
        console.log("start:", start);
        console.log("doesIntervalMatchNow", doesIntervalMatchNow);
        console.log("interval:", interval);
        console.log("now:", now);
        console.log("lastCall'ed:", this.lastCall);
        */
        
        if ( doesIntervalMatchNow >= 0 && doesIntervalMatchNow <= delta && (now - this.lastCall) > (interval*0.99) ) return true;
        else return false;
      };

      this.for = function(options) {
        extend(this, options);
        this.lastCall = this.start - this.interval;
        return this;
      };

      this.delete = false;
      return this;
    };
    var l = new Loop();

    events.loops[ l.name ] = l;

    return l;
  };

  this.remove =  this.off = function(event) {

    if (typeof event === "number") {

      if (events.ordinal[event] === undefined) return {"removed":false, "ctx": this};

      delete events.ordinal[event];
      return {"removed":true, "ctx": this};
    }

    if (typeof event === "string") {

      // if it is a event set with on():
      if (events.nominal[eventName] === undefined) {

        //if it is a loop event 
        if (events.loops[eventName] === undefined) return {"removed":false, "ctx": this};

        // loops terminate themselves automatically when set to delete
        events.loops[eventName].delete = true;
        return {"removed":true, "ctx": this};
      }

      delete events.nominal[eventName];
      return {"removed":true, "ctx": this};
    } 
  };

  this.defer = function(fn){
    // waits for the current stack to clear
    window.setTimeout(0, fn)
  };

  this.getEvents = function() {
    // in case someone wants to view the internally set events
    return events;
  };

  /* * * * * * * * * * * * * *

    bindToFunction:

    Attach 'wait' method to the Function.prototype,
    delegating to the timeline's <this>.after() method.
    Useful? Could be. Invasive of global prototypes? Def.

  * * * * * * * * * * * * * */
  
  if (options.bindToFunction === true) {

      var _t = this; // reference, since wait is in the context of the callee

      var wait = function(seconds, args, context) {
        _t.after(seconds, this, args, context); 
      };
      
      Function.prototype.wait = wait;
  }

  if (options.autostart === true) this.start();
  else return this;
};
   

module.exports = Clock;

},{"./_utils":5}],3:[function(require,module,exports){
(function() {
  var Cube, Skybox, _class;

  module.exports.Cube = Cube = (function() {

    function Cube(size, position, material, scene) {
      var number;
      this.scene = scene;
      if (typeof size === "number") {
        number = size;
      }
      this.position = new THREE.Vector3(position.x, position.y, position.z);
      this.geometry = new THREE.BoxGeometry(number || size.x, number || size.y, number || size.z);
      if (!material) {
        this.material = new THREE.MeshBasicMaterial({
          color: 0x008888,
          wireframe: true
        });
      } else if (material.id === void 0) {
        this.material = material || new THREE.MeshBasicMaterial({
          color: 0x008888,
          wireframe: false
        });
      }
      this.cube = new THREE.Mesh(this.geometry, this.material);
      this.cube.position = this.position;
      if (this.scene !== void 0) {
        this.addToScene(this.scene);
      }
    }

    Cube.prototype.addToScene = function(scene) {
      this.scene = scene;
      return scene.add(this.cube);
    };

    return Cube;

  })();

  module.exports.Skybox = Skybox = (function() {

    function Skybox() {
      _class.apply(this, arguments);
    }

    _class = console.log("wow");

    return Skybox;

  })();

}).call(this);

// Generated by CoffeeScript 1.5.0-pre

},{}],4:[function(require,module,exports){

/*

  Stages is an object to manage, well, stages.
  which a stage is the equivalent to the game concept of a 'level.'
  but someone could use multiple stages in one level, so I don't want to be pushy and call it a 'level' manager
*/


(function() {
  var Cube, SelectionGrid, Stage, StageManager, utils,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  utils = require("./_utils");

  Cube = require("./_objects").Cube;

  SelectionGrid = (function() {

    function SelectionGrid(data, engine, stage) {
      var centerIndex, hm, x, x0, y, y0;
      this.engine = engine;
      this.stage = stage;
      this.width = data.width;
      this.height = data.length;
      this.x = data.x;
      this.y = data.y;
      x0 = Math.floor(data.x / 2);
      y0 = Math.floor(data.y / 2);
      centerIndex = null;
      x = -1 * x0;
      y = -1 * y0;
      hm = data.heightmap.map(function(el, index, arr) {
        var node;
        node = {
          "z": el,
          "x": x,
          "y": y
        };
        if (x === 0 && y === 0) {
          node.center = true;
          centerIndex = index;
        }
        x++;
        if (x === x0) {
          x = -1 * x0;
          y++;
        }
        return node;
      });
      this.centerIndex = centerIndex;
      this.data = hm;
      console.log(this);
      this.createGrid();
    }

    SelectionGrid.prototype.createGrid = function() {
      var datum, h, margin, padding, w, x, y, _i, _len, _ref, _results;
      if (this.data === void 0) {
        return;
      }
      margin = 2;
      this.objects = [];
      x = 0;
      y = 0;
      w = this.width;
      h = this.height;
      padding = 2;
      _ref = this.data;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        datum = _ref[_i];
        _results.push(this.objects.push(new Cube({
          x: w,
          y: 1 * w,
          z: 1
        }, {
          x: datum.x * (w + padding),
          y: datum.y * (w + padding),
          z: datum.z * (h + padding)
        }, null, this.stage.scene)));
      }
      return _results;
    };

    SelectionGrid.prototype.filterData = function(vec3) {
      /*
        argument 'vec3' can be an object or a THREE.Vector3 instance
        ! Vector3 instances don't allow you to have 'undefined' as a value, so using '*' is used
        ie:   filterData( new THREE.Vector3(0, "*", "*") );
      
        Plain objects do allow undefined though, so you can pass in an object with all the values you want
        ie:   filterData({ x: 2});
      */
      console.log(vec3);
      if (!vec3) {
        return;
      }
      return this.data.filter(function(el, i, arr) {
        if (el.x === vec3.x || vec3.x === "*" || vec3.x === void 0) {
          if (el.y === vec3.y || vec3.y === "*" || vec3.y === void 0) {
            if (el.z === vec3.z || vec3.z === "*" || vec3.z === void 0) {
              return el;
            }
          }
        }
      });
    };

    return SelectionGrid;

  })();

  Stage = (function(_super) {

    __extends(Stage, _super);

    function Stage(parent, name, options) {
      var callbacks, camera, that;
      this.parent = parent;
      this.name = name.toLowerCase();
      this.scene = options.scene;
      camera = options.camera;
      this.camera = camera;
      that = this;
      that.on("load", that.onload.bind(that));
      callbacks = {
        scope: that,
        success: function(responseText) {
          that.data = responseText;
          console.log("Engine :: '" + name + "' ajax'd. ");
          that.data.grid = that.grid = new SelectionGrid(that.data.grid, that.parent, that);
          return that.trigger("load");
        },
        error: function() {
          throw new Error("Error retrieving data for Stage");
        }
      };
      if (options.url !== void 0) {
        utils.getJSON(options.url, callbacks);
      }
    }

    Stage.prototype.onload = function() {
      this.render();
    };

    Stage.prototype.lookAt = function(point) {
      return this.camera.lookAt(point || this.scene);
    };

    Stage.prototype.setCameraToIsometric = function() {
      var amt, h, w, x, y;
      if (!this.grid) {
        return;
      }
      w = this.grid.width;
      h = this.grid.height;
      x = this.grid.x;
      y = this.grid.y;
      amt = Math.pow(w * x / 2, 1.35);
      this.camera.position.z = amt / 2;
      this.camera.position.y = -1 * amt * 1.1;
      this.camera.position.x = amt;
      this.camera.rotation.x = 1.2;
      this.camera.rotation.y = 0.75;
      return this.camera.rotation.z = 0.25;
    };

    Stage.prototype.render = function() {
      var L, cube, geometry, material;
      geometry = new THREE.BoxGeometry(2, 2, 20);
      material = new THREE.MeshBasicMaterial({
        color: 0xffffff
      });
      cube = new THREE.Mesh(geometry, material);
      this.scene.add(cube);
      this.setCameraToIsometric();
      this.parent.renderer.render(this.scene, this.camera);
      L = this.parent.clock.loop("render", function() {
        return this.parent.renderer.render(this.scene, this.camera);
      }, null, this);
      L["for"]({
        interval: 17
      });
      return this.parent.clock.start();
    };

    Stage.prototype.destroy = function() {
      return this.parent.destroy(this.name);
    };

    return Stage;

  })(utils.EventEmitter);

  StageManager = function(engine) {
    /* @PRIVATES
    */

    var list, parent;
    parent = engine;
    /* @PUBLICS
    */

    list = {};
    this.list = [];
    this.create = function(name, options) {
      var o, stage;
      if (!name) {
        return;
      }
      o = options || {};
      stage = new Stage(parent, name, o);
      this.list.push(name);
      list[name.toLowerCase()] = stage;
      return list[name.toLowerCase()];
    };
    this.current = void 0;
    this.destroy = function(name) {
      return delete list[name];
    };
    this.load = function(name, transition) {};
    return this;
  };

  module.exports = StageManager;

}).call(this);

// Generated by CoffeeScript 1.5.0-pre

},{"./_objects":3,"./_utils":5}],5:[function(require,module,exports){

/*
      utilities
*/


(function() {
  var EventEmitter,
    __slice = [].slice;

  module.exports.log = function(msg) {
    var prefix;
    this.logs.unshift(msg);
    if (!this.debug) {
      return;
    }
    prefix = "Engine :: ";
    if (typeof msg === "string") {
      console.log(prefix + msg);
    } else {
      console.log(msg);
    }
  };

  module.exports.extend = function() {
    var base, extended, key, obj, objs, _i, _len;
    objs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (objs.length < 2) {
      return objs[0];
    }
    extended = objs[0];
    for (_i = 0, _len = objs.length; _i < _len; _i++) {
      obj = objs[_i];
      base = obj;
      for (key in base) {
        extended[key] = base[key];
      }
    }
    return extended;
  };

  module.exports.isArray = Array.isArray || function(thing) {
    return Object.prototype.toString.call(thing === "[object Array]");
  };

  module.exports.getJSON = function(url, callbacks) {
    var ajax, data, options;
    options = callbacks || {};
    data = void 0;
    ajax = $.getJSON(url);
    return ajax.complete(function() {
      try {
        data = $.parseJSON(ajax.responseText);
      } catch (e) {
        options.error.call(options.scope || null, e, ajax);
        return;
      }
      options.success.call(options.scope || null, data, ajax);
    });
  };

  module.exports.EventEmitter = EventEmitter = (function() {

    function EventEmitter() {}

    EventEmitter.prototype.events = {};

    EventEmitter.prototype.on = function(name, fn) {
      this.events[name] = fn;
      return this;
    };

    EventEmitter.prototype.off = function(name) {
      delete this.events[name];
      return this;
    };

    EventEmitter.prototype.get = function(name) {
      return this.events[name];
    };

    EventEmitter.prototype.trigger = function(name) {
      var fn;
      fn = this.get(name);
      if (fn === void 0) {
        return;
      }
      fn.call();
      return this;
    };

    return EventEmitter;

  })();

}).call(this);

// Generated by CoffeeScript 1.5.0-pre

},{}],6:[function(require,module,exports){
(function() {

  require("./_base");

  require("./main");

}).call(this);

// Generated by CoffeeScript 1.5.0-pre

},{"./_base":1,"./main":7}],7:[function(require,module,exports){
(function() {



}).call(this);

// Generated by CoffeeScript 1.5.0-pre

},{}]},{},[6])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyJjOlxcVXNlcnNcXFJvYXItWWF3blxcc2FuZGJveFxcdGhyZWVqcy10YWN0aWNzLWVuZ2luZVxcbm9kZV9tb2R1bGVzXFxicm93c2VyaWZ5XFxub2RlX21vZHVsZXNcXGJyb3dzZXItcGFja1xcX3ByZWx1ZGUuanMiLCJjOi9Vc2Vycy9Sb2FyLVlhd24vc2FuZGJveC90aHJlZWpzLXRhY3RpY3MtZW5naW5lL3B1YmxpYy9qYXZhc2NyaXB0L3NyYy9fYmFzZS5qcyIsImM6L1VzZXJzL1JvYXItWWF3bi9zYW5kYm94L3RocmVlanMtdGFjdGljcy1lbmdpbmUvcHVibGljL2phdmFzY3JpcHQvc3JjL19jbG9jay5qcyIsImM6L1VzZXJzL1JvYXItWWF3bi9zYW5kYm94L3RocmVlanMtdGFjdGljcy1lbmdpbmUvcHVibGljL2phdmFzY3JpcHQvc3JjL19vYmplY3RzLmpzIiwiYzovVXNlcnMvUm9hci1ZYXduL3NhbmRib3gvdGhyZWVqcy10YWN0aWNzLWVuZ2luZS9wdWJsaWMvamF2YXNjcmlwdC9zcmMvX3N0YWdlLmpzIiwiYzovVXNlcnMvUm9hci1ZYXduL3NhbmRib3gvdGhyZWVqcy10YWN0aWNzLWVuZ2luZS9wdWJsaWMvamF2YXNjcmlwdC9zcmMvX3V0aWxzLmpzIiwiYzovVXNlcnMvUm9hci1ZYXduL3NhbmRib3gvdGhyZWVqcy10YWN0aWNzLWVuZ2luZS9wdWJsaWMvamF2YXNjcmlwdC9zcmMvYnJvd3Nlci5qcyIsImM6L1VzZXJzL1JvYXItWWF3bi9zYW5kYm94L3RocmVlanMtdGFjdGljcy1lbmdpbmUvcHVibGljL2phdmFzY3JpcHQvc3JjL21haW4uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6aUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKX12YXIgZj1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwoZi5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxmLGYuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiXG4vKlxuICAgIHRocmVlLWpzIFRhY3RpY3MgRW5naW5lXG4qL1xuXG5cbihmdW5jdGlvbigpIHtcbiAgdmFyIENsb2NrLCBTdGFnZSwgVGhyZWVUYWN0aWNzRW5naW5lLCB1dGlscztcblxuICBjb25zb2xlLmxvZyhcIl9iYXNlXCIpO1xuXG4gIHV0aWxzID0gcmVxdWlyZShcIi4vX3V0aWxzXCIpO1xuXG4gIFN0YWdlID0gcmVxdWlyZShcIi4vX3N0YWdlXCIpO1xuXG4gIENsb2NrID0gcmVxdWlyZShcIi4vX2Nsb2NrXCIpO1xuXG4gIFRocmVlVGFjdGljc0VuZ2luZSA9IGZ1bmN0aW9uKCkge1xuICAgIC8qXG4gICAgICBAUFJJVkFURVNcbiAgICAqL1xuXG4gICAgdmFyIFRIUkVFLCBjb25maWdMb2FkZWQsIGV2ZW50TWV0aG9kcywgbG9nLCBuYW1lLCBzY2VuZSwgdGhhdCwgX2ksIF9sZW47XG4gICAgaWYgKHNlbGYuVEhSRUUgPT09IHZvaWQgMCB8fCBzZWxmLiQgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGVuZ2luZSBpcyBkZXBlbmRlbnQgb24gVEhSRUUuanMgYW5kIGpRdWVyeSwgd2hpY2ggb25lIG9mIHdhcyBub3QgZm91bmQsIG9yIG5vdCBpbiB0aGUgZ2xvYmFsIHNjb3BlLlwiKTtcbiAgICB9XG4gICAgVEhSRUUgPSBzZWxmLlRIUkVFO1xuICAgIGNvbmZpZ0xvYWRlZCA9IGZhbHNlO1xuICAgIHNjZW5lID0gZmFsc2U7XG4gICAgdGhhdCA9IHRoaXM7XG4gICAgdGhpcy5kZWJ1ZyA9IHRydWU7XG4gICAgdGhpcy5sb2dzID0gW107XG4gICAgbG9nID0gKGZ1bmN0aW9uKG1zZykge1xuICAgICAgcmV0dXJuIHV0aWxzLmxvZy5jYWxsKHRoaXMsIG1zZywgdGhpcy5sb2dzKTtcbiAgICB9KS5iaW5kKHRoaXMpO1xuICAgIHRoaXMubG9nID0gbG9nO1xuICAgIC8qXG4gICAgICBAUFVCTElDU1xuICAgICovXG5cbiAgICB0aGlzLmxvYWQgPSBmdW5jdGlvbigpIHt9O1xuICAgIHRoaXMucmVuZGVyUXVldWUgPSBbXTtcbiAgICB0aGlzLnN0YWdlID0gbmV3IFN0YWdlKHRoaXMpO1xuICAgIHRoaXMuY2xvY2sgPSBuZXcgQ2xvY2soKTtcbiAgICAvKiBcbiAgICAgIER5bmFtaWNhbGx5IGFkZCBldmVudCBtZXRob2RzIGZyb20gdGhlIGNsb2NrIG9iamVjdCAod2hpY2ggaGFzIGFuIGV2ZW50IGVtaXR0ZXIgYnVpbHQgaW50byBpdC4pXG4gICAgICB0aGlzIGFycmF5IGlzIHRoZSBuYW1lcyBvZiB0aGUgbWV0aG9kcyB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIGV2ZW50cyBvYmplY3RcbiAgICAqL1xuXG4gICAgZXZlbnRNZXRob2RzID0gW1wib25cIiwgXCJvZmZcIiwgXCJkZWZlclwiLCBcImdldEV2ZW50c1wiLCBcInRyaWdnZXJcIiwgXCJyZW1vdmVcIl07XG4gICAgdGhpcy5ldmVudHMgPSB7fTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IGV2ZW50TWV0aG9kcy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgbmFtZSA9IGV2ZW50TWV0aG9kc1tfaV07XG4gICAgICB0aGlzLmV2ZW50c1tuYW1lXSA9IHRoaXMuY2xvY2tbbmFtZV07XG4gICAgfVxuICAgIHRoaXMuaW5pdCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBjb25maWc7XG4gICAgICBjb25maWcgPSAkLmdldEpTT04oKG9wdGlvbnMgfHwge30pLmNvbmZpZyk7XG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoYXQgPSB0aGlzO1xuICAgICAgcmV0dXJuIGNvbmZpZy5jb21wbGV0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVyO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoYXQuY29uZmlnID0gJC5wYXJzZUpTT04oY29uZmlnLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBsb2coZSk7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSlNPTiB3YXMgbm90IHBhcnNlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uZmlnTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgbG9nKFwiQ29uZmlndXJhdGlvbiBMb2FkZWQuXCIpO1xuICAgICAgICByZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKCk7XG4gICAgICAgIHJlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocmVuZGVyZXIuZG9tRWxlbWVudCk7XG4gICAgICAgIHRoYXQucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgbG9nKFwiSW5pdGlhbGl6ZWQuXCIpO1xuICAgICAgICBpZiAoKG9wdGlvbnMgfHwge30pLmF1dG9zdGFydCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHJldHVybiB0aGF0LnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHN0YWdlO1xuICAgICAgaWYgKCFjb25maWdMb2FkZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3RhZ2UgPSB0aGlzLnN0YWdlLmNyZWF0ZShcInRlc3RcIiwge1xuICAgICAgICBcInVybFwiOiBcImpzb24vdGVzdC5qc29uXCJcbiAgICAgIH0pO1xuICAgICAgc3RhZ2UuY2FtZXJhID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKDMwLCB3aW5kb3cuaW5uZXJXaWR0aCAvIHdpbmRvdy5pbm5lckhlaWdodCwgMC4xLCAxMDAwMCk7XG4gICAgICByZXR1cm4gc3RhZ2Uuc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcbiAgICB9O1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHNlbGYuRW5naW5lID0gbmV3IFRocmVlVGFjdGljc0VuZ2luZSgpO1xuXG4gIEVuZ2luZS5pbml0KHtcbiAgICBcImNvbmZpZ1wiOiBcImpzb24vY29uZmlnLmpzb25cIixcbiAgICBcImF1dG9zdGFydFwiOiB0cnVlXG4gIH0pO1xuXG4gIGNvbnNvbGUubG9nKEVuZ2luZSk7XG5cbn0pLmNhbGwodGhpcyk7XG5cbi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS41LjAtcHJlXG4iLCJcbiAgLypcbiAgICBNb2RpZmllZCB2ZXJzaW9uIGZyb21cblxuICAgICstKy0gR0lUSFVCIC0rLStcbiAgdW5tb2RpZmllZCB2ZXJzaW9uIGxvY2F0ZWQgYXQ6XG4gICAgaHR0cHM6Ly9naXRodWIuY29tL1JvcnlEdW5jYW4vQ2xvY2tFdmVudEFnZ3JlZ2dhdG9yXG4gICAgXG4gICAgKy0rLSBET0NVTUVOVEFUSU9OIC0rLStcbiAgICBodHRwOi8vcm9yeWR1bmNhbi5naXRodWIuaW8vQ2xvY2tFdmVudEFnZ3JlZ2dhdG9yL1xuXG4gICovXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuL191dGlsc1wiKTtcblxudmFyIENsb2NrID0gZnVuY3Rpb24oYXJncykge1xuXG4gIC8qIEhlbHBlcnMgKi9cblxuICAvLyBIZWxwZXIgZm9yIG1lcmdpbmcgb2JqZWN0c1xuICBleHRlbmQgPSB1dGlscy5leHRlbmQ7XG5cbiAgdmFyIGlzQXJyYXkgPSBmdW5jdGlvbih0aGluZyl7XG4gICAgLy8gYXNzdW1lICd0aGluZycgaXMgbm90IHVuZGVmaW5lZCBvciBudWxsIGFzIGl0IHdpbGwgdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKHR5cGVvZiB0aGluZyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGZhbHNlO1xuICAgIGlmICggKHRoaW5nKS5sZW5ndGggPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZhbHNlO1xuICAgIGVsc2UgcmV0dXJuIHRydWU7IFxuICB9XG5cblxuICAvKiAgVGltZWxpbmUgcmVsYXRlZCB2YXJpYWJsZXMgICovXG5cbiAgdmFyIGRlZmF1bHRzID0ge3VzZVJBRjogdHJ1ZSwgdGlja0ludGVydmFsOiAxNiwgYXV0b3N0YXJ0OiBmYWxzZX0sXG4gICAgICBvcHRpb25zID0gZXh0ZW5kKGRlZmF1bHRzLCBhcmdzKSxcbiAgICAgIHRpY2tzID0gMCxcbiAgICAgIGxhc3RUaWNrID0gMCxcbiAgICAgIHN0YXJ0VGltZSA9IDAsXG5cbiAgICAgIC8vIHRoZSAnY2xvY2snIHRpbWUsIGNhbGN1bGF0ZWQgd2l0aCBkZWx0YSBhbmQgY2xvY2tTcGVlZCB2YXJpYWJsZXMuXG4gICAgICBlbGFwc2VkVGltZSA9IDAsXG5cbiAgICAgIC8vIGlkIGZvciByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgIHJBRklEID0gbnVsbCxcblxuICAgICAgLy8gd2hldGhlciB0aGlzIGlzIGV2ZXJ5IG90aGVyIHRpY2tcbiAgICAgIHRpY2tfbiA9IGZhbHNlLFxuXG4gICAgICAvLyB0aGUgYW1vdW50IG9mIHJlYWwtdGltZSB0aGF0IGhhcyBwYXNzZWQgYmV0d2VlbiB0aWNrc1xuICAgICAgZGVsdGEgPSAwLFxuICAgICAgYWN0dWFsRWxhcHNlZFRpbWUgPSAwO1xuXG4gICAgICAvLyBmYWxsYmFjayB0aW1lIGZvciBzZXRUaW1lb3V0XG4gICAgICB0aGlzLnRpY2tJbnRlcnZhbCA9IG9wdGlvbnMudGlja0ludGVydmFsLFxuXG4gICAgICBydW5uaW5nID0gZmFsc2UsXG5cbiAgICAgIC8vIHNwZWVkIGF0IHdoaWNoIHRoZSBjbG9jayBydW5zXG4gICAgICBjbG9ja3NwZWVkID0gMSxcblxuICAgICAgLy8gcmVmZXJlbmNlXG4gICAgICBzZWxmID0gdGhpcyxcblxuICAgICAgLy8gd2V0aGVyIG9yIG5vdCB0byB1c2UgcmVxdWVzdCBBbmltYXRpb24gRnJhbWVcbiAgICAgIHVzZVJBRiA9IG9wdGlvbnMudXNlUkFGLFxuXG4gICAgICAvLyBkeW5hbWljIGZ1bmN0aW9uIGZvciByQUYgb3Igc2V0VGltZW91dCBmdW5jdGlvbmFsaXR5LFxuICAgICAgdGlja0NhbGxlZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBzZXQgdG8gc3RhcnQoKSBpbml0aWFsbHkgaW4gY2FzZSBjYWxsZWQgYmVmb3JlIHN0YXJ0IHNvbWVob3cuXG4gICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgIH07XG5cbiAgICAgIFxuICAgICAgXG5cblxuICAvKiAgRXZlbnQgQWdncmVnYXRvciByZWxhdGVkIHZhcmlhYmxlcyAgKi9cblxuICB2YXIgZXZlbnRzID0ge307XG4gICAgICBldmVudHMubm9taW5hbCA9IHt9O1xuICAgICAgZXZlbnRzLm9yZGluYWwgPSB7fTtcbiAgICAgIGV2ZW50cy5sb29wcyA9IHt9O1xuXG4gIFxuICAvKiAgSW50ZXJuYWwgRnVuY3Rpb25zICovXG5cbiAgLy8gIGNsb2NrJ3MgdGljayBtZWNoYW5pc21cbiAgdmFyIHRpY2sgPSBmdW5jdGlvbigpIHtcbiAgICBcbiAgICB2YXIgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7IC8vY2FjaGVcbiAgICBpZiAoIXJ1bm5pbmcpIHJldHVybjtcbiAgICBcbiAgICB0aWNrcyArPSAxICogY2xvY2tzcGVlZDtcbiAgICB0aWNrX24gPSAhdGlja19uO1xuICAgIGlmICh0aGlzLmRlYnVnICYmIHRpY2tfbikgdGhpcy5sb2coKTtcblxuICAgIFxuICAgIHRoaXMuZGVsdGEgPSBkZWx0YSA9IChub3cgLSBsYXN0VGljaykgKiBjbG9ja3NwZWVkO1xuXG4gICAgbGFzdFRpY2sgPSBub3c7XG5cbiAgICBlbGFwc2VkVGltZSArPSBkZWx0YTtcblxuICAgIGFjdHVhbEVsYXBzZWRUaW1lID0gKCBub3cgLSBzdGFydFRpbWUgKTtcblxuICAgIHRoaXMuZXJyb3JNYXJnaW4gPSBhY3R1YWxFbGFwc2VkVGltZSAtIGVsYXBzZWRUaW1lOyBcblxuXG4gICAgLy8gc2luZ3VsYXIgZXZlbnRzIHRha2UgcHJlY2VkZW5jZSBvdmVyIGxvb3AgZXZlbnRzLlxuICAgIHRyaWdnZXJDdXJyZW50RXZlbnRzKCk7XG4gICAgdHJpZ2dlckxvb3BFdmVudHMoKTtcblxuICAgIHRoaXMudHJpZ2dlcihcInRpY2tcIik7XG5cbiAgICBcbiAgICByQUZJRCA9IHRpY2tDYWxsZWUoKTtcblxuICAgIHJldHVybiB0aWNrcztcbiAgfTtcbiAgXG4gIHZhciBidWlsZERlZmF1bHRFdmVudHMgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBkZWZhdWx0RXZlbnRzID0gW1widGlja1wiLCBcInN0YXJ0XCIsIFwiYWZ0ZXI6c3RhcnRcIiwgXCJwYXVzZVwiLCBcInJlc3VtZVwiXSxcbiAgICAgICAgYWRkRXZlbnQgPSBmdW5jdGlvbihuYW1lKXtcblxuICAgICAgICAgIGV2ZW50cy5vcmRpbmFsW25hbWVdID0gW107XG4gICAgICAgIH07XG5cbiAgICBkZWZhdWx0RXZlbnRzLmZvckVhY2goYWRkRXZlbnQpO1xuXG4gIH07XG4gIGJ1aWxkRGVmYXVsdEV2ZW50cygpO1xuXG4gIHZhciB0cmlnZ2VyT3JkaW5hbEV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIG5vdyA9IH5+KGVsYXBzZWRUaW1lIC8gMTAwKSAqIDEwMDtcblxuICAgIGlmICggZXZlbnRzLm9yZGluYWxbIG5vdyBdID09PSB1bmRlZmluZWQgKSB7cmV0dXJuIGZhbHNlO30gIC8vIHJldHVybiBmYWxzZSBpbiBjYXNlIG9mIGNoZWNrc1xuXG4gICAgXG4gICAgdmFyIGVvdCA9IGV2ZW50cy5vcmRpbmFsWyBub3cgXTtcblxuICAgIC8vIGV2ZW50cy5vcmRpbmFsIHdpbGwgYmUgYW4gYXJyYXksIHNvIGxvb3Agb3ZlciBlYWNoIGZ1bmN0aW9uIGluIGl0LlxuICAgIGZvciAodmFyIF94ID0gMCwgX3h4ID0gZW90Lmxlbmd0aDsgX3ggPCBfeHg7IF94KyspIHtcblxuICAgICAgdmFyIGZuID0gZW90W194XS5mbixcbiAgICAgICAgICBjdHggPSBlb3RbX3hdLmNvbnRleHQsXG4gICAgICAgICAgYXJncyA9IGVvdFtfeF0uYXJncztcblxuICAgICAgZm4uYXBwbHkoY3R4LCBhcmdzKTtcbiAgICB9XG5cbiAgICAvLyBkZWxldGUgaXQsIHNvIHRoYXQgaXQgd29uJ3QgdHJpZ2dlciB0aGUgbmV4dCB0aWNrcyB0aGF0IHJvdW5kIGRvd24gdG8gdGhpcyB0aW1lLlxuICAgIGRlbGV0ZSBldmVudHMub3JkaW5hbFsgbm93IF07XG5cbiAgICByZXR1cm4gdHJ1ZTsgLy8gcmV0dXJuIHRydWUgaW4gY2FzZSBvZiBjaGVja3NcbiAgfTtcblxuICB2YXIgdHJpZ2dlckxvb3BFdmVudHMgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBub3cgPSB+fmVsYXBzZWRUaW1lO1xuXG4gICAgdmFyIGV4cGlyZWQgPSBbXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBldmVudHMubG9vcHMpIHtcblxuICAgICAgdmFyIGxvb3AgPSBldmVudHMubG9vcHNbIGtleSBdXG5cbiAgICAgIGlmIChsb29wLnN0YXJ0IDw9IG5vdyAmJiAgICAgICAgICAvLyBDaGVjayBpZiBpdCBpcyAnYWxsb3dlZCcgdG8gc3RhcnQuXG4gICAgICAgICAgbG9vcC5jaGVja0ludGVydmFsKCBub3cgKSAmJiAgLy8gQ2hlY2sgd2hldGhlciB0aGUgbG9vcCBzaG91bGQgZmlyZSBhdCB0aGUgY3VycmVudCB0aW1lXG4gICAgICAgICAgbG9vcC5kZWxldGUgPT09IGZhbHNlICkgeyAgICAgIC8vIENoZWNrIGlmIGl0IGlzIHRvIGJlIGRlbGV0ZWRcbiAgICAgICAgICBcbiAgICAgICAgICAvLyB0aGVyZSBpcyBhIHJlZmVyZW5jZSB0byBfdGhpc18gaW5zaWRlIG9mIGxvb3AsXG4gICAgICAgICAgLy8gc28gc2VuZGluZyB0aGUgbG9vcCBpdHNlbGYgYXMgY29udGV4dCBpcyBlbm91Z2guXG4gICAgICAgICAgbG9vcC5jYWxsZWRBdC5wdXNoKCBub3cgKTtcbiAgICAgICAgICBsb29wLm5vdyA9IG5vdztcbiAgICAgICAgICBcbiAgICAgICAgICBsb29wLmZuLmFwcGx5KCBsb29wLnNjb3BlLCBsb29wLmFyZ3MgKTtcbiAgICAgICAgICBcbiAgICAgICAgICBsb29wLmxhc3RDYWxsID0gbm93O1xuICAgICAgICAgIGxvb3AuY2FsbHMrKztcbiAgICAgIH1cbiAgICAgIC8vIGNoZWNrIHdoZXRoZXIgaXQgaGFzIGV4cGlyZWRcbiAgICAgIGlmIChsb29wLnN0b3AgPT09IG5vdyB8fCBsb29wLmNhbGxzID09PSBsb29wLm1heEludGVydmFscyB8fCBsb29wLmRlbGV0ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyBwdXQgaXQgaW4gdGhlIGJveCB3aGVyZSBiYWQgbG9vcHMgZ28uXG4gICAgICAgIGV4cGlyZWQucHVzaCgga2V5ICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGVsZXRlIGFueSBsb29wcyBtYXJrZWRcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBleHBpcmVkLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIHZhciBuYW1lID0gZXhwaXJlZFtpXTtcbiAgICAgIGRlbGV0ZSBldmVudHMubG9vcHNbbmFtZV07XG4gICAgfVxuICB9O1xuXG5cbiAgLyogIEJpbmRpbmdzICAqL1xuXG4gIHRoaXMudGljayA9IHRpY2suYmluZCh0aGlzKTtcbiAgdmFyIHRyaWdnZXJMb29wRXZlbnRzID0gdHJpZ2dlckxvb3BFdmVudHMuYmluZCh0aGlzKTtcbiAgdmFyICB0cmlnZ2VyQ3VycmVudEV2ZW50cyA9IHRyaWdnZXJPcmRpbmFsRXZlbnRzLmJpbmQodGhpcyk7XG4gIFxuXG5cbiAgLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqL1xuICAvKiAqICogKiAqICogKiAqICogKiAqICogKiAgIEFQSSAgICogKiAqICogKiAqICogKiAqICogKiAqICovXG4gIC8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKi9cblxuXG4gIC8qICBDbG9jay1yZWxhdGVkIG1ldGhvZHMgICovXG5cbiAgdGhpcy5zdGFydCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgaWYgKHJ1bm5pbmcgPT09IHRydWUpIHsgcmV0dXJuIHRoaXM7IH0gLy8gc2ltcGxlIHRlc3RzIHRvIHByZXZlbnQgbXVsdGlwbGUgc3RhcnRzXG5cbiAgICAvLyB0aWNrTG9vcCBpcyBhIGR5bmFtaWNhbGx5IGNvbnN0cnVjdGVkIGZ1bmN0aW9uIHRvIHJlbW92ZSBhbiAnaWYnIHN0YXRlbWVudCBpbnNpZGUgb2YgdGljaygpIC5cbiAgICB2YXIgdGlja0xvb3A7ICBcblxuICAgIGlmICh1c2VSQUYgPT09IHRydWUpIHtcbiAgICAgIHRpY2tMb29wID0gbmV3IEZ1bmN0aW9uKFwiIHZhciBpZCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHRoaXMudGljayApOyByZXR1cm4gaWQ7XCIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRpY2tMb29wID0gbmV3IEZ1bmN0aW9uKFwiIHZhciBpZCA9IHdpbmRvdy5zZXRUaW1lb3V0KHRoaXMudGljaywgdGhpcy50aWNrSW50ZXJ2YWwpO3JldHVybiBpZDtcIiApO1xuICAgIH1cbiAgICAvLyBiaW5kIGludG8gdGhpcyBjb250ZXh0XG4gICAgdGlja0NhbGxlZSA9IHRpY2tMb29wLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLnRyaWdnZXIoXCJiZWZvcmU6c3RhcnRcIik7XG5cbiAgICB2YXIgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgdGhpcy5zdGFydFRpbWUgPSBzdGFydFRpbWUgPSBub3c7XG4gICAgcnVubmluZyA9IHRydWU7XG4gICAgbGFzdFRpY2sgPSBub3c7XG4gICAgdGhpcy50aWNrKCk7XG5cbiAgICB0aGlzLmVuYWJsZVBhdXNlT25CbHVyKCk7XG4gICAgdGhpcy50cmlnZ2VyKFwic3RhcnRcIik7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfS5iaW5kKHRoaXMpO1xuXG4gIHRoaXMuc3RvcCA9IGZ1bmN0aW9uKCl7XG5cbiAgICBydW5uaW5nID0gZmFsc2U7XG4gICAgLy9yZXNldCBldmVudCBsaXN0c1xuICAgIGV2ZW50cy5ub21pbmFsID0ge307XG4gICAgZXZlbnRzLm9yZGluYWwgPSBbXTtcbiAgICBldmVudHMubG9vcHMgPSB7fTtcblxuICAgIGJ1aWxkRGVmYXVsdEV2ZW50cygpO1xuXG4gICAgLy9yZXNldCBjb3VudGVyc1xuICAgIHRpY2tzID0gMDtcbiAgICBlbGFwc2VkVGltZSA9IDA7XG4gICAgdGhpcy5zdGFydFRpbWUgPSBzdGFydFRpbWUgPSAwO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0uYmluZCh0aGlzKTtcblxuICB0aGlzLnJlc2V0ID0gZnVuY3Rpb24oKXtcblxuICAgIHRoaXMucmVzZXQoKTtcbiAgICB0aGlzLnN0YXJ0KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0uYmluZCh0aGlzKTtcblxuICB0aGlzLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gICAgcnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMudHJpZ2dlcihcInBhdXNlXCIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LmJpbmQodGhpcyk7XG5cbiAgdGhpcy5yZXN1bWUgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAocnVubmluZyA9PT0gdHJ1ZSkgcmV0dXJuIHRoaXM7XG4gICAgcnVubmluZyA9IHRydWU7XG4gICAgbGFzdFRpY2sgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB0aGlzLnRpY2soKTtcbiAgICB0aGlzLnRyaWdnZXIoXCJyZXN1bWVcIik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0uYmluZCh0aGlzKTtcblxuICB0aGlzLmNsb2NrU2NhbGFyID0gZnVuY3Rpb24obXVsdGlwbGllcikge1xuICAgIC8vIGEgcmVsYXRpdmUgd2F5IHRvIGFmZmVjdCB0aGUgY2xvY2tcbiAgICBjbG9ja3NwZWVkICo9IG11bHRpcGxpZXIgfHwgMTtcbiAgfTtcblxuICB0aGlzLnNldENsb2NrU3BlZWQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIC8vIGZvciBtYW51YWxseSBlbnRlcmluZyBhIHNwZWVkIHZhbHVlXG4gICAgY2xvY2tzcGVlZCA9IHZhbHVlIHx8IGNsb2Nrc3BlZWQ7XG4gIH07XG5cbiAgdGhpcy5lbmFibGVQYXVzZU9uQmx1ciA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIGNhbGxlZCBvbiBzdGFydFxuICAgIC8vIHJlcXVlc3RBbmltYXRpb25GcmFtZSBuYXRpdmVseSBwYXVzZXMgb25ibHVyLCBidXQsIHRoaXMgY2xvY2sgZG9lc24ndFxuICAgIC8vIHNvIEkndmUgcHJvZ3JhbW1lZCB0aGUgZnVuY3Rpb25hbGl0eSBpbnRvIGl0LiBcblxuICAgIHdpbmRvdy5vbmJsdXIgPSBmdW5jdGlvbigpe3NlbGYucGF1c2UoKTt9XG4gICAgd2luZG93Lm9uZm9jdXMgPSBmdW5jdGlvbigpe3NlbGYucmVzdW1lKCk7fTtcbiAgfTtcblxuICB0aGlzLmRpc2FibGVQYXVzZU9uQmx1ciA9IGZ1bmN0aW9uKCl7XG4gICAgd2luZG93Lm9uYmx1ciA9IGZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9O1xuICAgIHdpbmRvdy5vbmZvY3VzID0gZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH07XG4gIH07XG4gIFxuICB0aGlzLnRpY2tzID0gZnVuY3Rpb24oKXsgcmV0dXJuIHRpY2tzOyB9O1xuXG4gIHRoaXMubWlsbGlzZWNvbmRzID0gZnVuY3Rpb24oKXsgcmV0dXJuIGVsYXBzZWRUaW1lO307XG5cbiAgdGhpcy5zZWNvbmRzID0gZnVuY3Rpb24oKXsgcmV0dXJuIGVsYXBzZWRUaW1lIC8gMTAwMCA7IH07XG5cbiAgdGhpcy5taW51dGVzID0gZnVuY3Rpb24oKXsgcmV0dXJuICh0aGlzLnNlY29uZHMoKSAvIDYwKTsgfTtcblxuICB0aGlzLmRlYnVnID0gb3B0aW9ucy5kZWJ1ZyB8fCBmYWxzZTtcblxuICAvLyBpZiBkZWJ1ZyBpcyB0cnVlLCBsb2cgaXMgYXV0b21hdGljYWxseSBjYWxsZWQgZWFjaCB0aWNrXG4gIHRoaXMubG9nID0gZnVuY3Rpb24oKSB7XG5cbiAgICBjb25zb2xlLmNsZWFyKCk7XG4gICAgaWYgKHVzZVJBRikgY29uc29sZS5sb2coXCI8VXNpbmcgcmVxdWVzdEFuaW1hdGlvbkZyYW1lPlwiKTtcbiAgICBlbHNlIGNvbnNvbGUubG9nKFwiPFVzaW5nIHNldFRpbWVvdXQ+XCIpO1xuICAgIGNvbnNvbGUubG9nKFwidGlja3M6XCIsIHRpY2tzKTtcbiAgICBjb25zb2xlLmxvZyhcImRlbHRhOlwiLCBkZWx0YSk7XG4gICAgY29uc29sZS5sb2coXCJsYXN0VGljayhzaG91bGQgY2hhbmdlKVwiLCB+fmxhc3RUaWNrKVxuICAgIGNvbnNvbGUubG9nKFwiZWxhcHNlZCB0aW1lOlwiLCBlbGFwc2VkVGltZSAvIDEwMDApO1xuICAgIGNvbnNvbGUubG9nKFwiZWxhcHNlZCBzZWNvbmRzOlwiLCB+fihlbGFwc2VkVGltZSAvIDEwMDApKTtcbiAgICBjb25zb2xlLmxvZyhcImFjdHVhbCBlbGFwc2VkIHRpbWU6XCIsIGFjdHVhbEVsYXBzZWRUaW1lIC8gMTAwMCk7XG4gICAgY29uc29sZS53YXJuKFwiJWNkaWZmZXJlbmNlIChpbiBzZWNvbmRzKTogXCIgKyAodGhpcy5lcnJvck1hcmdpbiAvIDEwMDApLCBcImNvbG9yOiAjYTAwXCIgKTtcbiAgICBjb25zb2xlLmxvZyhcIklnbm9yZSBkaWZmZXJlbmNlcyBpZiB5b3UgaGF2ZSBjYWxsZWQgcGF1c2UgYXQgYW55IHRpbWUuXCIpO1xuICAgIGNvbnNvbGUubG9nKFwiRXN0aW1hdGVkIEZQUzpcIiwgfn4odGlja3MgLyAoIGVsYXBzZWRUaW1lIC8gMTAwMCApKSk7XG4gIH07XG5cbiAgdGhpcy50aW1lID0gdGhpcy5ub3cgPSBmdW5jdGlvbigpeyByZXR1cm4gZWxhcHNlZFRpbWU7IH07XG5cblxuXG4gIC8qICBFdmVudC1yZWxhdGVkIG1ldGhvZHMgICovXG4gIFxuICB0aGlzLnRyaWdnZXIgPSBmdW5jdGlvbihldmVudE5hbWUpIHtcblxuICAgIGlmIChldmVudHMubm9taW5hbFtldmVudE5hbWVdID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzO1xuXG4gICAgdmFyIGwgPSBldmVudHMubm9taW5hbFtldmVudE5hbWVdLmxlbmd0aFxuXG4gICAgZm9yICh2YXIgX3ggPSAwLCBfeHggPSBsOyBfeCA8IF94eDsgX3grKykge1xuXG4gICAgICAvLyB3b3csIG11Y2ggbGVuZ3RoLCBtYW55IGNoYXJzLCBzdWNoIHNjYXJ5LlxuICAgICAgdmFyIGZuID0gZXZlbnRzLm5vbWluYWxbZXZlbnROYW1lXVtfeF0uZm4sXG4gICAgICAgICAgY3R4ID0gZXZlbnRzLm5vbWluYWxbZXZlbnROYW1lXVtfeF0uY29udGV4dCxcbiAgICAgICAgICBhcmdzID0gZXZlbnRzLm5vbWluYWxbZXZlbnROYW1lXVtfeF0uYXJncztcblxuICAgICAgZm4uYXBwbHkoY3R4LCBhcmdzKTtcblxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB0aGlzLm9uID0gZnVuY3Rpb24oIGV2ZW50TmFtZSwgZm4gLyogWywgYXJncywgY29udGV4dCBdICovICkge1xuXG4gICAgdmFyIGNvbnRleHQgPSBhcmd1bWVudHNbM10gfHwgdGhpcywgYXJncyA9IGFyZ3VtZW50c1syXSB8fCBbXTtcblxuICAgIC8vIGNyZWF0ZSBhbiBhcnJheSBmb3IgdGhlIGV2ZW50XG4gICAgZXZlbnRzLm5vbWluYWxbZXZlbnROYW1lXSA9IGV2ZW50cy5ub21pbmFsW2V2ZW50TmFtZV0gfHwgW11cblxuICAgIHZhciBzY29wZSA9IHRoaXM7IC8vIGFsbCBldmVudHMgZGVmYXVsdCB0byB0aGUgc2NvcGUgb2YgdGhlIFRpbWVsaW5lIG9iamVjdC5cblxuICAgIGV2ZW50cy5ub21pbmFsW2V2ZW50TmFtZV0ucHVzaCh7XG4gICAgICAnZm4nOiBmbixcbiAgICAgICdhcmdzJzogYXJncyxcbiAgICAgICdjb250ZXh0JzogY29udGV4dFxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHRoaXMuYXQgPSBmdW5jdGlvbiggZWxhcHNlZE1TLCBmbiAvKiBbLCBhcmdzLCBjb250ZXh0IF0gKi8gKSB7XG4gICAgaWYgKGVsYXBzZWRNUyA9PT0gdW5kZWZpbmVkKSB7dGhyb3cgbmV3IEVycm9yKFwiYXQoKSBtZXRob2QgcmVxdWlyZXMgYSBjbG9jay10aW1lIHBhc3NlZCBpbiBhcyBmaXJzdCBwYXJhbWV0ZXIuXCIpOyByZXR1cm47fVxuICAgIGlmIChmbiA9PT0gdW5kZWZpbmVkKSB7dGhyb3cgbmV3IEVycm9yKFwiYXQoKSBtZXRob2QgcmVxdWlyZXMgYSBmdW5jdGlvbiBwYXNzZWQgaW4gYXMgc2Vjb25kIHBhcmFtZXRlci5cIik7IHJldHVybjt9XG5cbiAgICB2YXIgY29udGV4dCA9IGFyZ3VtZW50c1szXSB8fCBudWxsLCBhcmdzID0gYXJndW1lbnRzWzJdIHx8IHRoaXM7XG5cbiAgICB2YXIgYWRkVGltZSA9IGZ1bmN0aW9uKCB0aW1lICkge1xuXG4gICAgICB2YXIgdCA9IHRpbWUudG9TdHJpbmcoKTtcbiAgICAgIGV2ZW50cy5vcmRpbmFsWyB0aW1lIF0gPSBldmVudHMub3JkaW5hbFsgdGltZSBdIHx8IFtdO1xuICAgICAgZXZlbnRzLm9yZGluYWxbIHRpbWUgXS5wdXNoKHtcbiAgICAgICAgXCJmblwiOiBmbixcbiAgICAgICAgXCJjb250ZXh0XCI6IGNvbnRleHQsXG4gICAgICAgIFwiYXJnc1wiOiBhcmdzXG4gICAgICB9KTtcblxuICAgIH07XG5cbiAgICBpZiAoICFpc0FycmF5KGVsYXBzZWRNUykgKSB7XG4gICAgICBhZGRUaW1lKCBlbGFwc2VkTVMgKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9XG5cbiAgICAgIGVsYXBzZWRNUy5mb3JFYWNoKCBhZGRUaW1lICk7XG5cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdGhpcy5hZnRlciA9IGZ1bmN0aW9uKCBtaWxsaXNlY29uZHMsIGZuIC8qIFssIGFyZ3MsIGNvbnRleHQgXSAqLyApIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50c1syXSwgY29udGV4dCA9IGFyZ3VtZW50c1szXTtcbiAgICB0aGlzLmF0KCBlbGFwc2VkVGltZSArIG1pbGxpc2Vjb25kcywgZm4sIGFyZ3MsIGNvbnRleHQgKTtcbiAgfTtcblxuICB0aGlzLmxvb3AgPSBmdW5jdGlvbiggdW5pcXVlTmFtZSwgZm4sIGFyZ3MsIHNjb3BlICkge1xuXG4gICAgLypcbiAgICAgICAgdGhpcy5sb29wKCkgcmV0dXJucyBhIG5ldyBsb29wIG9iamVjdCwgd2hpY2ggdG8gYWx0ZXIgdGltaW5nLXJlbGF0ZWQgb3B0aW9uc1xuICAgICAgICB5b3UgY2FsbCBpdCdzIC5mb3IoKSBtZXRob2QuIFxuICAgICAgICBcbiAgICAgICAgRVg6XG4gICAgICAgIHZhciB4ID0gdGhpcy5sb29wKCphcmdzKS5mb3IoKmFyZ3MpO1xuICAgICovXG5cbiAgICBpZiAoIXVuaXF1ZU5hbWUpIHJldHVybiB0aGlzO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBkZWZhdWx0cyA9IHtcbiAgICAgICAgICBcImF1dG9zdGFydFwiOiB0cnVlLFxuICAgICAgICAgIFwic3RhcnRcIjogfn5lbGFwc2VkVGltZSxcbiAgICAgICAgICBcInN0b3BcIjogSW5maW5pdHksIFxuICAgICAgICAgIFwiaW50ZXJ2YWxcIjogSW5maW5pdHksIFxuICAgICAgICAgIFwibWF4SW50ZXJ2YWxzXCI6IEluZmluaXR5LCBcbiAgICAgICAgICBcImR1cmF0aW9uXCI6IDAsIFxuICAgICAgICAgIFwiY2FsbGVkQXRcIjogW10sXG4gICAgICAgICAgXCJzdGFydERlbGF5XCI6IDBcbiAgICAgICAgfSxcbiAgICAgICAgcmVxdWlyZWQgPSB7XG4gICAgICAgICAgXCJuYW1lXCI6dW5pcXVlTmFtZSxcbiAgICAgICAgICBcImZuXCI6IGZuLFxuICAgICAgICAgIFwic2NvcGVcIjogc2NvcGUgfHwgc2VsZixcbiAgICAgICAgICBcImNhbGxzXCI6IDAsXG4gICAgICAgICAgXCJwYXJlbnRcIjogc2VsZixcbiAgICAgICAgICBcImFyZ3NcIjogYXJncyB8fCBbXVxuICAgICAgICB9O1xuXG4gICAgLy8gdGhlIGxvb3Agb2JqZWN0IHRoYXQgd2lsbCBiZSByZXR1cm5lZFxuICAgIHZhciBMb29wID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXG5cbiAgICAgIGV4dGVuZCh0aGlzLCBkZWZhdWx0cywgcmVxdWlyZWQpO1xuXG4gICAgICAvLyB0aGUgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRoZSBsb29wIGlzIGNhbGxlZFxuICAgICAgdGhpcy5jaGVja0ludGVydmFsID0gZnVuY3Rpb24obm93KSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuc3RhcnQsXG4gICAgICAgICAgICBpbnRlcnZhbCA9IHRoaXMuaW50ZXJ2YWwsXG4gICAgICAgICAgICBkdXJhdGlvbiA9IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICBkb2VzSW50ZXJ2YWxNYXRjaE5vdyA9IChub3cgLSAoc3RhcnQgKyB0aGlzLnN0YXJ0RGVsYXkpKSAgJSAoaW50ZXJ2YWwgKyBkdXJhdGlvbiksXG4gICAgICAgICAgICBpbnRlcnZhbEhhc1Bhc3NlZCA9IG5vdyAtICh0aGlzLmxhc3RDYWxsID09PSB1bmRlZmluZWQgPyBzdGFydCA6IHRoaXMubGFzdENhbGwpO1xuICBcbiAgICAgICAgLypcbiAgICAgICAgY29uc29sZS5jbGVhcigpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIm5hbWU6XCIsIHRoaXMubmFtZSk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiRGVsdGE6XCIsIHNlbGYuZGVsdGEgKTtcbiAgICAgICAgY29uc29sZS5sb2coXCItLS0tLVwiKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJzdGFydDpcIiwgc3RhcnQpO1xuICAgICAgICBjb25zb2xlLmxvZyhcImRvZXNJbnRlcnZhbE1hdGNoTm93XCIsIGRvZXNJbnRlcnZhbE1hdGNoTm93KTtcbiAgICAgICAgY29uc29sZS5sb2coXCJpbnRlcnZhbDpcIiwgaW50ZXJ2YWwpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIm5vdzpcIiwgbm93KTtcbiAgICAgICAgY29uc29sZS5sb2coXCJsYXN0Q2FsbCdlZDpcIiwgdGhpcy5sYXN0Q2FsbCk7XG4gICAgICAgICovXG4gICAgICAgIFxuICAgICAgICBpZiAoIGRvZXNJbnRlcnZhbE1hdGNoTm93ID49IDAgJiYgZG9lc0ludGVydmFsTWF0Y2hOb3cgPD0gZGVsdGEgJiYgKG5vdyAtIHRoaXMubGFzdENhbGwpID4gKGludGVydmFsKjAuOTkpICkgcmV0dXJuIHRydWU7XG4gICAgICAgIGVsc2UgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5mb3IgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIGV4dGVuZCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5sYXN0Q2FsbCA9IHRoaXMuc3RhcnQgLSB0aGlzLmludGVydmFsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuZGVsZXRlID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHZhciBsID0gbmV3IExvb3AoKTtcblxuICAgIGV2ZW50cy5sb29wc1sgbC5uYW1lIF0gPSBsO1xuXG4gICAgcmV0dXJuIGw7XG4gIH07XG5cbiAgdGhpcy5yZW1vdmUgPSAgdGhpcy5vZmYgPSBmdW5jdGlvbihldmVudCkge1xuXG4gICAgaWYgKHR5cGVvZiBldmVudCA9PT0gXCJudW1iZXJcIikge1xuXG4gICAgICBpZiAoZXZlbnRzLm9yZGluYWxbZXZlbnRdID09PSB1bmRlZmluZWQpIHJldHVybiB7XCJyZW1vdmVkXCI6ZmFsc2UsIFwiY3R4XCI6IHRoaXN9O1xuXG4gICAgICBkZWxldGUgZXZlbnRzLm9yZGluYWxbZXZlbnRdO1xuICAgICAgcmV0dXJuIHtcInJlbW92ZWRcIjp0cnVlLCBcImN0eFwiOiB0aGlzfTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGV2ZW50ID09PSBcInN0cmluZ1wiKSB7XG5cbiAgICAgIC8vIGlmIGl0IGlzIGEgZXZlbnQgc2V0IHdpdGggb24oKTpcbiAgICAgIGlmIChldmVudHMubm9taW5hbFtldmVudE5hbWVdID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAvL2lmIGl0IGlzIGEgbG9vcCBldmVudCBcbiAgICAgICAgaWYgKGV2ZW50cy5sb29wc1tldmVudE5hbWVdID09PSB1bmRlZmluZWQpIHJldHVybiB7XCJyZW1vdmVkXCI6ZmFsc2UsIFwiY3R4XCI6IHRoaXN9O1xuXG4gICAgICAgIC8vIGxvb3BzIHRlcm1pbmF0ZSB0aGVtc2VsdmVzIGF1dG9tYXRpY2FsbHkgd2hlbiBzZXQgdG8gZGVsZXRlXG4gICAgICAgIGV2ZW50cy5sb29wc1tldmVudE5hbWVdLmRlbGV0ZSA9IHRydWU7XG4gICAgICAgIHJldHVybiB7XCJyZW1vdmVkXCI6dHJ1ZSwgXCJjdHhcIjogdGhpc307XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSBldmVudHMubm9taW5hbFtldmVudE5hbWVdO1xuICAgICAgcmV0dXJuIHtcInJlbW92ZWRcIjp0cnVlLCBcImN0eFwiOiB0aGlzfTtcbiAgICB9IFxuICB9O1xuXG4gIHRoaXMuZGVmZXIgPSBmdW5jdGlvbihmbil7XG4gICAgLy8gd2FpdHMgZm9yIHRoZSBjdXJyZW50IHN0YWNrIHRvIGNsZWFyXG4gICAgd2luZG93LnNldFRpbWVvdXQoMCwgZm4pXG4gIH07XG5cbiAgdGhpcy5nZXRFdmVudHMgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBpbiBjYXNlIHNvbWVvbmUgd2FudHMgdG8gdmlldyB0aGUgaW50ZXJuYWxseSBzZXQgZXZlbnRzXG4gICAgcmV0dXJuIGV2ZW50cztcbiAgfTtcblxuICAvKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG5cbiAgICBiaW5kVG9GdW5jdGlvbjpcblxuICAgIEF0dGFjaCAnd2FpdCcgbWV0aG9kIHRvIHRoZSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgZGVsZWdhdGluZyB0byB0aGUgdGltZWxpbmUncyA8dGhpcz4uYWZ0ZXIoKSBtZXRob2QuXG4gICAgVXNlZnVsPyBDb3VsZCBiZS4gSW52YXNpdmUgb2YgZ2xvYmFsIHByb3RvdHlwZXM/IERlZi5cblxuICAqICogKiAqICogKiAqICogKiAqICogKiAqICovXG4gIFxuICBpZiAob3B0aW9ucy5iaW5kVG9GdW5jdGlvbiA9PT0gdHJ1ZSkge1xuXG4gICAgICB2YXIgX3QgPSB0aGlzOyAvLyByZWZlcmVuY2UsIHNpbmNlIHdhaXQgaXMgaW4gdGhlIGNvbnRleHQgb2YgdGhlIGNhbGxlZVxuXG4gICAgICB2YXIgd2FpdCA9IGZ1bmN0aW9uKHNlY29uZHMsIGFyZ3MsIGNvbnRleHQpIHtcbiAgICAgICAgX3QuYWZ0ZXIoc2Vjb25kcywgdGhpcywgYXJncywgY29udGV4dCk7IFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgRnVuY3Rpb24ucHJvdG90eXBlLndhaXQgPSB3YWl0O1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuYXV0b3N0YXJ0ID09PSB0cnVlKSB0aGlzLnN0YXJ0KCk7XG4gIGVsc2UgcmV0dXJuIHRoaXM7XG59O1xuICAgXG5cbm1vZHVsZS5leHBvcnRzID0gQ2xvY2s7XG4iLCIoZnVuY3Rpb24oKSB7XG4gIHZhciBDdWJlLCBTa3lib3gsIF9jbGFzcztcblxuICBtb2R1bGUuZXhwb3J0cy5DdWJlID0gQ3ViZSA9IChmdW5jdGlvbigpIHtcblxuICAgIGZ1bmN0aW9uIEN1YmUoc2l6ZSwgcG9zaXRpb24sIG1hdGVyaWFsLCBzY2VuZSkge1xuICAgICAgdmFyIG51bWJlcjtcbiAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcbiAgICAgIGlmICh0eXBlb2Ygc2l6ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBudW1iZXIgPSBzaXplO1xuICAgICAgfVxuICAgICAgdGhpcy5wb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHBvc2l0aW9uLnopO1xuICAgICAgdGhpcy5nZW9tZXRyeSA9IG5ldyBUSFJFRS5Cb3hHZW9tZXRyeShudW1iZXIgfHwgc2l6ZS54LCBudW1iZXIgfHwgc2l6ZS55LCBudW1iZXIgfHwgc2l6ZS56KTtcbiAgICAgIGlmICghbWF0ZXJpYWwpIHtcbiAgICAgICAgdGhpcy5tYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7XG4gICAgICAgICAgY29sb3I6IDB4MDA4ODg4LFxuICAgICAgICAgIHdpcmVmcmFtZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAobWF0ZXJpYWwuaWQgPT09IHZvaWQgMCkge1xuICAgICAgICB0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWwgfHwgbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAgICAgICAgICBjb2xvcjogMHgwMDg4ODgsXG4gICAgICAgICAgd2lyZWZyYW1lOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY3ViZSA9IG5ldyBUSFJFRS5NZXNoKHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwpO1xuICAgICAgdGhpcy5jdWJlLnBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgIGlmICh0aGlzLnNjZW5lICE9PSB2b2lkIDApIHtcbiAgICAgICAgdGhpcy5hZGRUb1NjZW5lKHRoaXMuc2NlbmUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIEN1YmUucHJvdG90eXBlLmFkZFRvU2NlbmUgPSBmdW5jdGlvbihzY2VuZSkge1xuICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xuICAgICAgcmV0dXJuIHNjZW5lLmFkZCh0aGlzLmN1YmUpO1xuICAgIH07XG5cbiAgICByZXR1cm4gQ3ViZTtcblxuICB9KSgpO1xuXG4gIG1vZHVsZS5leHBvcnRzLlNreWJveCA9IFNreWJveCA9IChmdW5jdGlvbigpIHtcblxuICAgIGZ1bmN0aW9uIFNreWJveCgpIHtcbiAgICAgIF9jbGFzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIF9jbGFzcyA9IGNvbnNvbGUubG9nKFwid293XCIpO1xuXG4gICAgcmV0dXJuIFNreWJveDtcblxuICB9KSgpO1xuXG59KS5jYWxsKHRoaXMpO1xuXG4vLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNS4wLXByZVxuIiwiXG4vKlxuXG4gIFN0YWdlcyBpcyBhbiBvYmplY3QgdG8gbWFuYWdlLCB3ZWxsLCBzdGFnZXMuXG4gIHdoaWNoIGEgc3RhZ2UgaXMgdGhlIGVxdWl2YWxlbnQgdG8gdGhlIGdhbWUgY29uY2VwdCBvZiBhICdsZXZlbC4nXG4gIGJ1dCBzb21lb25lIGNvdWxkIHVzZSBtdWx0aXBsZSBzdGFnZXMgaW4gb25lIGxldmVsLCBzbyBJIGRvbid0IHdhbnQgdG8gYmUgcHVzaHkgYW5kIGNhbGwgaXQgYSAnbGV2ZWwnIG1hbmFnZXJcbiovXG5cblxuKGZ1bmN0aW9uKCkge1xuICB2YXIgQ3ViZSwgU2VsZWN0aW9uR3JpZCwgU3RhZ2UsIFN0YWdlTWFuYWdlciwgdXRpbHMsXG4gICAgX19oYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXG4gICAgX19leHRlbmRzID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChfX2hhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH07XG5cbiAgdXRpbHMgPSByZXF1aXJlKFwiLi9fdXRpbHNcIik7XG5cbiAgQ3ViZSA9IHJlcXVpcmUoXCIuL19vYmplY3RzXCIpLkN1YmU7XG5cbiAgU2VsZWN0aW9uR3JpZCA9IChmdW5jdGlvbigpIHtcblxuICAgIGZ1bmN0aW9uIFNlbGVjdGlvbkdyaWQoZGF0YSwgZW5naW5lLCBzdGFnZSkge1xuICAgICAgdmFyIGNlbnRlckluZGV4LCBobSwgeCwgeDAsIHksIHkwO1xuICAgICAgdGhpcy5lbmdpbmUgPSBlbmdpbmU7XG4gICAgICB0aGlzLnN0YWdlID0gc3RhZ2U7XG4gICAgICB0aGlzLndpZHRoID0gZGF0YS53aWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gZGF0YS5sZW5ndGg7XG4gICAgICB0aGlzLnggPSBkYXRhLng7XG4gICAgICB0aGlzLnkgPSBkYXRhLnk7XG4gICAgICB4MCA9IE1hdGguZmxvb3IoZGF0YS54IC8gMik7XG4gICAgICB5MCA9IE1hdGguZmxvb3IoZGF0YS55IC8gMik7XG4gICAgICBjZW50ZXJJbmRleCA9IG51bGw7XG4gICAgICB4ID0gLTEgKiB4MDtcbiAgICAgIHkgPSAtMSAqIHkwO1xuICAgICAgaG0gPSBkYXRhLmhlaWdodG1hcC5tYXAoZnVuY3Rpb24oZWwsIGluZGV4LCBhcnIpIHtcbiAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgIG5vZGUgPSB7XG4gICAgICAgICAgXCJ6XCI6IGVsLFxuICAgICAgICAgIFwieFwiOiB4LFxuICAgICAgICAgIFwieVwiOiB5XG4gICAgICAgIH07XG4gICAgICAgIGlmICh4ID09PSAwICYmIHkgPT09IDApIHtcbiAgICAgICAgICBub2RlLmNlbnRlciA9IHRydWU7XG4gICAgICAgICAgY2VudGVySW5kZXggPSBpbmRleDtcbiAgICAgICAgfVxuICAgICAgICB4Kys7XG4gICAgICAgIGlmICh4ID09PSB4MCkge1xuICAgICAgICAgIHggPSAtMSAqIHgwO1xuICAgICAgICAgIHkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jZW50ZXJJbmRleCA9IGNlbnRlckluZGV4O1xuICAgICAgdGhpcy5kYXRhID0gaG07XG4gICAgICBjb25zb2xlLmxvZyh0aGlzKTtcbiAgICAgIHRoaXMuY3JlYXRlR3JpZCgpO1xuICAgIH1cblxuICAgIFNlbGVjdGlvbkdyaWQucHJvdG90eXBlLmNyZWF0ZUdyaWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkYXR1bSwgaCwgbWFyZ2luLCBwYWRkaW5nLCB3LCB4LCB5LCBfaSwgX2xlbiwgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICBpZiAodGhpcy5kYXRhID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbWFyZ2luID0gMjtcbiAgICAgIHRoaXMub2JqZWN0cyA9IFtdO1xuICAgICAgeCA9IDA7XG4gICAgICB5ID0gMDtcbiAgICAgIHcgPSB0aGlzLndpZHRoO1xuICAgICAgaCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgcGFkZGluZyA9IDI7XG4gICAgICBfcmVmID0gdGhpcy5kYXRhO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBkYXR1bSA9IF9yZWZbX2ldO1xuICAgICAgICBfcmVzdWx0cy5wdXNoKHRoaXMub2JqZWN0cy5wdXNoKG5ldyBDdWJlKHtcbiAgICAgICAgICB4OiB3LFxuICAgICAgICAgIHk6IDEgKiB3LFxuICAgICAgICAgIHo6IDFcbiAgICAgICAgfSwge1xuICAgICAgICAgIHg6IGRhdHVtLnggKiAodyArIHBhZGRpbmcpLFxuICAgICAgICAgIHk6IGRhdHVtLnkgKiAodyArIHBhZGRpbmcpLFxuICAgICAgICAgIHo6IGRhdHVtLnogKiAoaCArIHBhZGRpbmcpXG4gICAgICAgIH0sIG51bGwsIHRoaXMuc3RhZ2Uuc2NlbmUpKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcblxuICAgIFNlbGVjdGlvbkdyaWQucHJvdG90eXBlLmZpbHRlckRhdGEgPSBmdW5jdGlvbih2ZWMzKSB7XG4gICAgICAvKlxuICAgICAgICBhcmd1bWVudCAndmVjMycgY2FuIGJlIGFuIG9iamVjdCBvciBhIFRIUkVFLlZlY3RvcjMgaW5zdGFuY2VcbiAgICAgICAgISBWZWN0b3IzIGluc3RhbmNlcyBkb24ndCBhbGxvdyB5b3UgdG8gaGF2ZSAndW5kZWZpbmVkJyBhcyBhIHZhbHVlLCBzbyB1c2luZyAnKicgaXMgdXNlZFxuICAgICAgICBpZTogICBmaWx0ZXJEYXRhKCBuZXcgVEhSRUUuVmVjdG9yMygwLCBcIipcIiwgXCIqXCIpICk7XG4gICAgICBcbiAgICAgICAgUGxhaW4gb2JqZWN0cyBkbyBhbGxvdyB1bmRlZmluZWQgdGhvdWdoLCBzbyB5b3UgY2FuIHBhc3MgaW4gYW4gb2JqZWN0IHdpdGggYWxsIHRoZSB2YWx1ZXMgeW91IHdhbnRcbiAgICAgICAgaWU6ICAgZmlsdGVyRGF0YSh7IHg6IDJ9KTtcbiAgICAgICovXG4gICAgICBjb25zb2xlLmxvZyh2ZWMzKTtcbiAgICAgIGlmICghdmVjMykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5kYXRhLmZpbHRlcihmdW5jdGlvbihlbCwgaSwgYXJyKSB7XG4gICAgICAgIGlmIChlbC54ID09PSB2ZWMzLnggfHwgdmVjMy54ID09PSBcIipcIiB8fCB2ZWMzLnggPT09IHZvaWQgMCkge1xuICAgICAgICAgIGlmIChlbC55ID09PSB2ZWMzLnkgfHwgdmVjMy55ID09PSBcIipcIiB8fCB2ZWMzLnkgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgaWYgKGVsLnogPT09IHZlYzMueiB8fCB2ZWMzLnogPT09IFwiKlwiIHx8IHZlYzMueiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2VsZWN0aW9uR3JpZDtcblxuICB9KSgpO1xuXG4gIFN0YWdlID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuXG4gICAgX19leHRlbmRzKFN0YWdlLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gU3RhZ2UocGFyZW50LCBuYW1lLCBvcHRpb25zKSB7XG4gICAgICB2YXIgY2FsbGJhY2tzLCBjYW1lcmEsIHRoYXQ7XG4gICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgIHRoaXMubmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHRoaXMuc2NlbmUgPSBvcHRpb25zLnNjZW5lO1xuICAgICAgY2FtZXJhID0gb3B0aW9ucy5jYW1lcmE7XG4gICAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcbiAgICAgIHRoYXQgPSB0aGlzO1xuICAgICAgdGhhdC5vbihcImxvYWRcIiwgdGhhdC5vbmxvYWQuYmluZCh0aGF0KSk7XG4gICAgICBjYWxsYmFja3MgPSB7XG4gICAgICAgIHNjb3BlOiB0aGF0LFxuICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihyZXNwb25zZVRleHQpIHtcbiAgICAgICAgICB0aGF0LmRhdGEgPSByZXNwb25zZVRleHQ7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJFbmdpbmUgOjogJ1wiICsgbmFtZSArIFwiJyBhamF4J2QuIFwiKTtcbiAgICAgICAgICB0aGF0LmRhdGEuZ3JpZCA9IHRoYXQuZ3JpZCA9IG5ldyBTZWxlY3Rpb25HcmlkKHRoYXQuZGF0YS5ncmlkLCB0aGF0LnBhcmVudCwgdGhhdCk7XG4gICAgICAgICAgcmV0dXJuIHRoYXQudHJpZ2dlcihcImxvYWRcIik7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciByZXRyaWV2aW5nIGRhdGEgZm9yIFN0YWdlXCIpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKG9wdGlvbnMudXJsICE9PSB2b2lkIDApIHtcbiAgICAgICAgdXRpbHMuZ2V0SlNPTihvcHRpb25zLnVybCwgY2FsbGJhY2tzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBTdGFnZS5wcm90b3R5cGUub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnJlbmRlcigpO1xuICAgIH07XG5cbiAgICBTdGFnZS5wcm90b3R5cGUubG9va0F0ID0gZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbWVyYS5sb29rQXQocG9pbnQgfHwgdGhpcy5zY2VuZSk7XG4gICAgfTtcblxuICAgIFN0YWdlLnByb3RvdHlwZS5zZXRDYW1lcmFUb0lzb21ldHJpYyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFtdCwgaCwgdywgeCwgeTtcbiAgICAgIGlmICghdGhpcy5ncmlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHcgPSB0aGlzLmdyaWQud2lkdGg7XG4gICAgICBoID0gdGhpcy5ncmlkLmhlaWdodDtcbiAgICAgIHggPSB0aGlzLmdyaWQueDtcbiAgICAgIHkgPSB0aGlzLmdyaWQueTtcbiAgICAgIGFtdCA9IE1hdGgucG93KHcgKiB4IC8gMiwgMS4zNSk7XG4gICAgICB0aGlzLmNhbWVyYS5wb3NpdGlvbi56ID0gYW10IC8gMjtcbiAgICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLnkgPSAtMSAqIGFtdCAqIDEuMTtcbiAgICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLnggPSBhbXQ7XG4gICAgICB0aGlzLmNhbWVyYS5yb3RhdGlvbi54ID0gMS4yO1xuICAgICAgdGhpcy5jYW1lcmEucm90YXRpb24ueSA9IDAuNzU7XG4gICAgICByZXR1cm4gdGhpcy5jYW1lcmEucm90YXRpb24ueiA9IDAuMjU7XG4gICAgfTtcblxuICAgIFN0YWdlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBMLCBjdWJlLCBnZW9tZXRyeSwgbWF0ZXJpYWw7XG4gICAgICBnZW9tZXRyeSA9IG5ldyBUSFJFRS5Cb3hHZW9tZXRyeSgyLCAyLCAyMCk7XG4gICAgICBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7XG4gICAgICAgIGNvbG9yOiAweGZmZmZmZlxuICAgICAgfSk7XG4gICAgICBjdWJlID0gbmV3IFRIUkVFLk1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgICAgIHRoaXMuc2NlbmUuYWRkKGN1YmUpO1xuICAgICAgdGhpcy5zZXRDYW1lcmFUb0lzb21ldHJpYygpO1xuICAgICAgdGhpcy5wYXJlbnQucmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKTtcbiAgICAgIEwgPSB0aGlzLnBhcmVudC5jbG9jay5sb29wKFwicmVuZGVyXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQucmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIHRoaXMuY2FtZXJhKTtcbiAgICAgIH0sIG51bGwsIHRoaXMpO1xuICAgICAgTFtcImZvclwiXSh7XG4gICAgICAgIGludGVydmFsOiAxN1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQuY2xvY2suc3RhcnQoKTtcbiAgICB9O1xuXG4gICAgU3RhZ2UucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5kZXN0cm95KHRoaXMubmFtZSk7XG4gICAgfTtcblxuICAgIHJldHVybiBTdGFnZTtcblxuICB9KSh1dGlscy5FdmVudEVtaXR0ZXIpO1xuXG4gIFN0YWdlTWFuYWdlciA9IGZ1bmN0aW9uKGVuZ2luZSkge1xuICAgIC8qIEBQUklWQVRFU1xuICAgICovXG5cbiAgICB2YXIgbGlzdCwgcGFyZW50O1xuICAgIHBhcmVudCA9IGVuZ2luZTtcbiAgICAvKiBAUFVCTElDU1xuICAgICovXG5cbiAgICBsaXN0ID0ge307XG4gICAgdGhpcy5saXN0ID0gW107XG4gICAgdGhpcy5jcmVhdGUgPSBmdW5jdGlvbihuYW1lLCBvcHRpb25zKSB7XG4gICAgICB2YXIgbywgc3RhZ2U7XG4gICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbyA9IG9wdGlvbnMgfHwge307XG4gICAgICBzdGFnZSA9IG5ldyBTdGFnZShwYXJlbnQsIG5hbWUsIG8pO1xuICAgICAgdGhpcy5saXN0LnB1c2gobmFtZSk7XG4gICAgICBsaXN0W25hbWUudG9Mb3dlckNhc2UoKV0gPSBzdGFnZTtcbiAgICAgIHJldHVybiBsaXN0W25hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgfTtcbiAgICB0aGlzLmN1cnJlbnQgPSB2b2lkIDA7XG4gICAgdGhpcy5kZXN0cm95ID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgcmV0dXJuIGRlbGV0ZSBsaXN0W25hbWVdO1xuICAgIH07XG4gICAgdGhpcy5sb2FkID0gZnVuY3Rpb24obmFtZSwgdHJhbnNpdGlvbikge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBTdGFnZU1hbmFnZXI7XG5cbn0pLmNhbGwodGhpcyk7XG5cbi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS41LjAtcHJlXG4iLCJcbi8qXG4gICAgICB1dGlsaXRpZXNcbiovXG5cblxuKGZ1bmN0aW9uKCkge1xuICB2YXIgRXZlbnRFbWl0dGVyLFxuICAgIF9fc2xpY2UgPSBbXS5zbGljZTtcblxuICBtb2R1bGUuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbihtc2cpIHtcbiAgICB2YXIgcHJlZml4O1xuICAgIHRoaXMubG9ncy51bnNoaWZ0KG1zZyk7XG4gICAgaWYgKCF0aGlzLmRlYnVnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHByZWZpeCA9IFwiRW5naW5lIDo6IFwiO1xuICAgIGlmICh0eXBlb2YgbXNnID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zb2xlLmxvZyhwcmVmaXggKyBtc2cpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhtc2cpO1xuICAgIH1cbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cy5leHRlbmQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYmFzZSwgZXh0ZW5kZWQsIGtleSwgb2JqLCBvYmpzLCBfaSwgX2xlbjtcbiAgICBvYmpzID0gMSA8PSBhcmd1bWVudHMubGVuZ3RoID8gX19zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkgOiBbXTtcbiAgICBpZiAob2Jqcy5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm4gb2Jqc1swXTtcbiAgICB9XG4gICAgZXh0ZW5kZWQgPSBvYmpzWzBdO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gb2Jqcy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgb2JqID0gb2Jqc1tfaV07XG4gICAgICBiYXNlID0gb2JqO1xuICAgICAgZm9yIChrZXkgaW4gYmFzZSkge1xuICAgICAgICBleHRlbmRlZFtrZXldID0gYmFzZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXh0ZW5kZWQ7XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMuaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24odGhpbmcpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRoaW5nID09PSBcIltvYmplY3QgQXJyYXldXCIpO1xuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzLmdldEpTT04gPSBmdW5jdGlvbih1cmwsIGNhbGxiYWNrcykge1xuICAgIHZhciBhamF4LCBkYXRhLCBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSBjYWxsYmFja3MgfHwge307XG4gICAgZGF0YSA9IHZvaWQgMDtcbiAgICBhamF4ID0gJC5nZXRKU09OKHVybCk7XG4gICAgcmV0dXJuIGFqYXguY29tcGxldGUoZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkYXRhID0gJC5wYXJzZUpTT04oYWpheC5yZXNwb25zZVRleHQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBvcHRpb25zLmVycm9yLmNhbGwob3B0aW9ucy5zY29wZSB8fCBudWxsLCBlLCBhamF4KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgb3B0aW9ucy5zdWNjZXNzLmNhbGwob3B0aW9ucy5zY29wZSB8fCBudWxsLCBkYXRhLCBhamF4KTtcbiAgICB9KTtcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXIgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICBmdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7fVxuXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudHMgPSB7fTtcblxuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbihuYW1lLCBmbikge1xuICAgICAgdGhpcy5ldmVudHNbbmFtZV0gPSBmbjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmV2ZW50c1tuYW1lXTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmV2ZW50c1tuYW1lXTtcbiAgICB9O1xuXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGZuO1xuICAgICAgZm4gPSB0aGlzLmdldChuYW1lKTtcbiAgICAgIGlmIChmbiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZuLmNhbGwoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyO1xuXG4gIH0pKCk7XG5cbn0pLmNhbGwodGhpcyk7XG5cbi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS41LjAtcHJlXG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgcmVxdWlyZShcIi4vX2Jhc2VcIik7XG5cbiAgcmVxdWlyZShcIi4vbWFpblwiKTtcblxufSkuY2FsbCh0aGlzKTtcblxuLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjUuMC1wcmVcbiIsIihmdW5jdGlvbigpIHtcblxuXG5cbn0pLmNhbGwodGhpcyk7XG5cbi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS41LjAtcHJlXG4iXX0=
