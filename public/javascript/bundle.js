(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

/*
    three-js Tactics Engine
*/


(function() {
  var Clock, Stage, ThreeTacticsEngine, utils;

  console.log("_base");

  utils = require("./_utils");

  Stage = require("./_stage");

  Clock = require("./_clock");

  ThreeTacticsEngine = function() {
    /*
      @PRIVATES
    */

    var THREE, configLoaded, eventMethods, name, _i, _len;
    if (self.THREE === void 0 || self.$ === void 0) {
      throw new Error("The engine is dependent on THREE.js and jQuery, which one of was not found, or not in the global scope.");
    }
    THREE = self.THREE;
    configLoaded = false;
    /*
      @PUBLICS
    */

    this.load = function() {};
    this.stage = new Stage();
    this.clock = new Clock();
    /* 
      Dynamically add event methods from the clock object (which has an event emitter built into it.)
      this array is the names of the methods that will be added to the events object
    */

    eventMethods = ["on", "off", "defer", "getEvents", "trigger", "remove"];
    this.events = {};
    for (_i = 0, _len = eventMethods.length; _i < _len; _i++) {
      name = eventMethods[_i];
      this.events[name] = this.clock[name];
    }
    this.displayLoading = function() {};
    this.init = function(options) {
      var config, that;
      config = $.getJSON((options || {}).config || "json/config.json");
      that = this;
      this.displayLoading(config);
      return config.complete(function() {
        try {
          this.config = $.parseJSON(config.responseText);
        } catch (e) {
          console.log(e);
          throw new Error("JSON was not parsed.");
        }
        configLoaded = true;
        console.log("Configuration Loaded.");
        that.displayLoading();
        if ((options || {}).autostart === true) {
          return that.start();
        }
      });
    };
    this.start = function() {
      var camera, renderer, scene;
      if (!configLoaded) {
        return;
      }
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      return this.renderer = renderer;
    };
    return this;
  };

  self.Engine = new ThreeTacticsEngine();

  Engine.init({
    "autostart": true
  });

  console.log(Engine);

}).call(this);

// Generated by CoffeeScript 1.5.0-pre

},{"./_clock":2,"./_stage":3,"./_utils":4}],2:[function(require,module,exports){

  /*
    Modified version from

    +-+- GITHUB -+-+
    https://github.com/RoryDuncan/ClockEventAggreggator
    
    +-+- DOCS -+-+
    http://roryduncan.github.io/ClockEventAggreggator/

  */

var utils = require("./_utils");

var Clock = function(args) {

  /* Helpers */

  // Helper for merging objects
  extend = utils.extend;

  var isArray = function(thing){
    // assume 'thing' is not undefined or null as it will throw a TypeError.
    if (typeof thing === "string") return false;
    if ( (thing).length === undefined) return false;
    else return true; 
  }


  /*  Timeline related variables  */

  var defaults = {useRAF: true, tickInterval: 16, autostart: false},
      options = extend(defaults, args),
      ticks = 0,
      lastTick = 0,
      startTime = 0,

      // the 'clock' time, calculated with delta and clockSpeed variables.
      elapsedTime = 0,

      // id for requestAnimationFrame
      rAFID = null,

      // whether this is every other tick
      tick_n = false,

      // the amount of real-time that has passed between ticks
      delta = 0,
      actualElapsedTime = 0;

      // fallback time for setTimeout
      this.tickInterval = options.tickInterval,

      running = false,

      // speed at which the clock runs
      clockspeed = 1,

      // reference
      self = this,

      // wether or not to use request Animation Frame
      useRAF = options.useRAF,

      // dynamic function for rAF or setTimeout functionality,
      tickCallee = function() {
        // set to start() initially in case called before start somehow.
        this.start();
      };

      
      


  /*  Event Aggregator related variables  */

  var events = {};
      events.nominal = {};
      events.ordinal = {};
      events.loops = {};

  
  /*  Internal Functions */

  //  clock's tick mechanism
  var tick = function() {
    
    var now = new Date().getTime(); //cache
    if (!running) return;
    
    ticks += 1 * clockspeed;
    tick_n = !tick_n;
    if (this.debug && tick_n) this.log();

    
    this.delta = delta = (now - lastTick) * clockspeed;

    lastTick = now;

    elapsedTime += delta;

    actualElapsedTime = ( now - startTime );

    this.errorMargin = actualElapsedTime - elapsedTime; 


    // singular events take precedence over loop events.
    triggerCurrentEvents();
    triggerLoopEvents();

    this.trigger("tick");

    
    rAFID = tickCallee();

    return ticks;
  };
  
  var buildDefaultEvents = function() {

    var defaultEvents = ["tick", "start", "after:start", "pause", "resume"],
        addEvent = function(name){

          events.ordinal[name] = [];
        };

    defaultEvents.forEach(addEvent);

  };
  buildDefaultEvents();

  var triggerOrdinalEvents = function() {

    var now = ~~(elapsedTime / 100) * 100;

    if ( events.ordinal[ now ] === undefined ) {return false;}  // return false in case of checks

    
    var eot = events.ordinal[ now ];

    // events.ordinal will be an array, so loop over each function in it.
    for (var _x = 0, _xx = eot.length; _x < _xx; _x++) {

      var fn = eot[_x].fn,
          ctx = eot[_x].context,
          args = eot[_x].args;

      fn.apply(ctx, args);
    }

    // delete it, so that it won't trigger the next ticks that round down to this time.
    delete events.ordinal[ now ];

    return true; // return true in case of checks
  };

  var triggerLoopEvents = function() {

    var now = ~~elapsedTime;

    var expired = [];

    for (var key in events.loops) {

      var loop = events.loops[ key ]

      if (loop.start <= now &&          // Check if it is 'allowed' to start.
          loop.checkInterval( now ) &&  // Check whether the loop should fire at the current time
          loop.delete === false ) {      // Check if it is to be deleted
          
          // there is a reference to _this_ inside of loop,
          // so sending the loop itself as context is enough.
          loop.calledAt.push( now );
          loop.now = now;
          
          loop.fn.apply( loop, loop.args );
          
          loop.lastCall = now;
          loop.calls++;
      }
      // check whether it has expired
      if (loop.stop === now || loop.calls === loop.maxIntervals || loop.delete === true) {
        // put it in the box where bad loops go.
        expired.push( key );
      }
    }

    // Delete any loops marked
    for (var i = 0, ii = expired.length; i < ii; i++) {
      var name = expired[i];
      delete events.loops[name];
    }
  };


  /*  Bindings  */

  this.tick = tick.bind(this);
  var triggerLoopEvents = triggerLoopEvents.bind(this);
  var  triggerCurrentEvents = triggerOrdinalEvents.bind(this);
  


  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
  /* * * * * * * * * * * * *   API   * * * * * * * * * * * * */
  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


  /*  Clock-related methods  */

  this.start = function() {

    if (running === true) { return this; } // simple tests to prevent multiple starts

    // tickLoop is a dynamically constructed function to remove an 'if' statement inside of tick() .
    var tickLoop;  

    if (useRAF === true) {
      tickLoop = new Function(" var id = window.requestAnimationFrame( this.tick ); return id;");
    }
    else {
      tickLoop = new Function(" var id = window.setTimeout(this.tick, this.tickInterval);return id;" );
    }
    // bind into this context
    tickCallee = tickLoop.bind(this);

    this.trigger("before:start");

    var now = new Date().getTime();
    this.startTime = startTime = now;
    running = true;
    lastTick = now;
    this.tick();

    this.enablePauseOnBlur();
    this.trigger("start");

    return this;
  }.bind(this);

  this.stop = function(){

    running = false;
    //reset event lists
    events.nominal = {};
    events.ordinal = [];
    events.loops = {};

    buildDefaultEvents();

    //reset counters
    ticks = 0;
    elapsedTime = 0;
    this.startTime = startTime = 0;

    return this;
  }.bind(this);

  this.reset = function(){

    this.reset();
    this.start();
    return this;
  }.bind(this);

  this.pause = function() {
    running = false;
    this.trigger("pause");
    return this;
  }.bind(this);

  this.resume = function() {
    if (running === true) return this;
    running = true;
    lastTick = new Date().getTime();
    this.tick();
    this.trigger("resume");
    return this;
  }.bind(this);

  this.clockScalar = function(multiplier) {
    // a relative way to affect the clock
    clockspeed *= multiplier || 1;
  };

  this.setClockSpeed = function(value) {
    // for manually entering a speed value
    clockspeed = value || clockspeed;
  };

  this.enablePauseOnBlur = function() {
    // called on start
    // requestAnimationFrame natively pauses onblur, but, this clock doesn't
    // so I've programmed the functionality into it. 

    window.onblur = function(){self.pause();}
    window.onfocus = function(){self.resume();};
  };

  this.disablePauseOnBlur = function(){
    window.onblur = function(){return null};
    window.onfocus = function(){return null};
  };
  
  this.ticks = function(){ return ticks; };

  this.milliseconds = function(){ return elapsedTime;};

  this.seconds = function(){ return elapsedTime / 1000 ; };

  this.minutes = function(){ return (this.seconds() / 60); };

  this.debug = options.debug || false;

  // if debug is true, log is automatically called each tick
  this.log = function() {

    console.clear();
    if (useRAF) console.log("<Using requestAnimationFrame>");
    else console.log("<Using setTimeout>");
    console.log("ticks:", ticks);
    console.log("delta:", delta);
    console.log("lastTick(should change)", ~~lastTick)
    console.log("elapsed time:", elapsedTime / 1000);
    console.log("elapsed seconds:", ~~(elapsedTime / 1000));
    console.log("actual elapsed time:", actualElapsedTime / 1000);
    console.warn("%cdifference (in seconds): " + (this.errorMargin / 1000), "color: #a00" );
    console.log("Ignore differences if you have called pause at any time.");
    console.log("Estimated FPS:", ~~(ticks / ( elapsedTime / 1000 )));
  };

  this.time = this.now = function(){ return elapsedTime; };



  /*  Event-related methods  */
  
  this.trigger = function(eventName) {

    if (events.nominal[eventName] === undefined) return this;

    var l = events.nominal[eventName].length

    for (var _x = 0, _xx = l; _x < _xx; _x++) {

      // wow, much length, many chars, such scary.
      var fn = events.nominal[eventName][_x].fn,
          ctx = events.nominal[eventName][_x].context,
          args = events.nominal[eventName][_x].args;

      fn.apply(ctx, args);

    }
    return this;
  };

  this.on = function( eventName, fn /* [, args, context ] */ ) {

    var context = arguments[3] || this, args = arguments[2] || [];

    // create an array for the event
    events.nominal[eventName] = events.nominal[eventName] || []

    var scope = this; // all events default to the scope of the Timeline object.

    events.nominal[eventName].push({
      'fn': fn,
      'args': args,
      'context': context
    });
    return this;
  };

  this.at = function( elapsedMS, fn /* [, args, context ] */ ) {
    if (elapsedMS === undefined) {throw new Error("at() method requires a clock-time passed in as first parameter."); return;}
    if (fn === undefined) {throw new Error("at() method requires a function passed in as second parameter."); return;}

    var context = arguments[3] || null, args = arguments[2] || this;

    var addTime = function( time ) {

      var t = time.toString();
      events.ordinal[ time ] = events.ordinal[ time ] || [];
      events.ordinal[ time ].push({
        "fn": fn,
        "context": context,
        "args": args
      });

    };

    if ( !isArray(elapsedMS) ) {
      addTime( elapsedMS );
      
      return this;

    }

      elapsedMS.forEach( addTime );


      return this;
  };

  this.after = function( milliseconds, fn /* [, args, context ] */ ) {
    var args = arguments[2], context = arguments[3];
    this.at( elapsedTime + milliseconds, fn, args, context );
  };

  this.loop = function( uniqueName, fn, args, scope ) {

    /*
        this.loop() returns a new loop object, which to alter timing-related options
        you call it's .for() method. 
        
        EX:
        var x = this.loop(*args).for(*args);
    */

    if (!uniqueName) return this;

    var self = this,
        defaults = {
          "autostart": true,
          "start": ~~elapsedTime,
          "stop": Infinity, 
          "interval": Infinity, 
          "maxIntervals": Infinity, 
          "duration": 0, 
          "calledAt": [],
          "startDelay": 0
        },
        required = {
          "name":uniqueName,
          "fn": fn,
          "calls": 0,
          "parent":self,
          "args": args || []
        };

    // the loop object that will be returned
    var Loop = function(options) {


      extend(this, defaults, required);

      // the check to determine if the loop is called
      this.checkInterval = function(now) {
        var start = this.start,
            interval = this.interval,
            duration = this.duration,
            doesIntervalMatchNow = (now - (start + this.startDelay))  % (interval + duration),
            intervalHasPassed = now - (this.lastCall === undefined ? start : this.lastCall);
  

        console.clear();
        console.log("name:", this.name);
        console.log("Delta:", self.delta );
        console.log("-----");
        console.log("start:", start);
        console.log("doesIntervalMatchNow", doesIntervalMatchNow);
        console.log("interval:", interval);
        console.log("now:", now);
        console.log("lastCall'ed:", this.lastCall);
        
        if ( doesIntervalMatchNow >= 0 && doesIntervalMatchNow <= delta && (now - this.lastCall) > (interval*0.99) ) return true;
        else return false;
      };

      this.for = function(options) {
        extend(this, options);
        this.lastCall = this.start - this.interval;
        return this;
      };

      this.delete = false;
      return this;
    };
    var l = new Loop();

    events.loops[ l.name ] = l;

    return l;
  };

  this.remove =  this.off = function(event) {

    if (typeof event === "number") {

      if (events.ordinal[event] === undefined) return {"removed":false, "ctx": this};

      delete events.ordinal[event];
      return {"removed":true, "ctx": this};
    }

    if (typeof event === "string") {

      // if it is a event set with on():
      if (events.nominal[eventName] === undefined) {

        //if it is a loop event 
        if (events.loops[eventName] === undefined) return {"removed":false, "ctx": this};

        // loops terminate themselves automatically when set to delete
        events.loops[eventName].delete = true;
        return {"removed":true, "ctx": this};
      }

      delete events.nominal[eventName];
      return {"removed":true, "ctx": this};
    } 
  };

  this.defer = function(fn){
    // waits for the current stack to clear
    window.setTimeout(0, fn)
  };

  this.getEvents = function() {
    // in case someone wants to view the internally set events
    return events;
  };

  /* * * * * * * * * * * * * *

    bindToFunction:

    Attach 'wait' method to the Function.prototype,
    delegating to the timeline's <this>.after() method.
    Useful? Could be. Invasive of global prototypes? Def.

  * * * * * * * * * * * * * */
  
  if (options.bindToFunction === true) {

      var _t = this; // reference, since wait is in the context of the callee

      var wait = function(seconds, args, context) {
        _t.after(seconds, this, args, context); 
      };
      
      Function.prototype.wait = wait;
  }

  if (options.autostart === true) this.start();
  else return this;
};
   

module.exports = Clock;

},{"./_utils":4}],3:[function(require,module,exports){
(function() {
  var Stages;

  Stages = function() {
    console.log("_stageloader");
    this.create = function() {};
    return this;
  };

  module.exports = Stages;

}).call(this);

// Generated by CoffeeScript 1.5.0-pre

},{}],4:[function(require,module,exports){

/*
      utilities
*/


(function() {
  var __slice = [].slice;

  module.exports.extend = function() {
    var base, extended, key, obj, objs, _i, _len;
    objs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (objs.length < 2) {
      return objs[0];
    }
    extended = objs[0];
    for (_i = 0, _len = objs.length; _i < _len; _i++) {
      obj = objs[_i];
      base = obj;
      for (key in base) {
        extended[key] = base[key];
      }
    }
    return extended;
  };

}).call(this);

// Generated by CoffeeScript 1.5.0-pre

},{}],5:[function(require,module,exports){
(function() {

  require("./_base");

  require("./main");

}).call(this);

// Generated by CoffeeScript 1.5.0-pre

},{"./_base":1,"./main":6}],6:[function(require,module,exports){
(function() {



}).call(this);

// Generated by CoffeeScript 1.5.0-pre

},{}]},{},[5])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyJjOlxcVXNlcnNcXFJvYXItWWF3blxcc2FuZGJveFxcdGhyZWVqcy10YWN0aWNzLWVuZ2luZVxcbm9kZV9tb2R1bGVzXFxicm93c2VyaWZ5XFxub2RlX21vZHVsZXNcXGJyb3dzZXItcGFja1xcX3ByZWx1ZGUuanMiLCJjOi9Vc2Vycy9Sb2FyLVlhd24vc2FuZGJveC90aHJlZWpzLXRhY3RpY3MtZW5naW5lL3B1YmxpYy9qYXZhc2NyaXB0L3NyYy9fYmFzZS5qcyIsImM6L1VzZXJzL1JvYXItWWF3bi9zYW5kYm94L3RocmVlanMtdGFjdGljcy1lbmdpbmUvcHVibGljL2phdmFzY3JpcHQvc3JjL19jbG9jay5qcyIsImM6L1VzZXJzL1JvYXItWWF3bi9zYW5kYm94L3RocmVlanMtdGFjdGljcy1lbmdpbmUvcHVibGljL2phdmFzY3JpcHQvc3JjL19zdGFnZS5qcyIsImM6L1VzZXJzL1JvYXItWWF3bi9zYW5kYm94L3RocmVlanMtdGFjdGljcy1lbmdpbmUvcHVibGljL2phdmFzY3JpcHQvc3JjL191dGlscy5qcyIsImM6L1VzZXJzL1JvYXItWWF3bi9zYW5kYm94L3RocmVlanMtdGFjdGljcy1lbmdpbmUvcHVibGljL2phdmFzY3JpcHQvc3JjL2Jyb3dzZXIuanMiLCJjOi9Vc2Vycy9Sb2FyLVlhd24vc2FuZGJveC90aHJlZWpzLXRhY3RpY3MtZW5naW5lL3B1YmxpYy9qYXZhc2NyaXB0L3NyYy9tYWluLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdGlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpfXZhciBmPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChmLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGYsZi5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJcbi8qXG4gICAgdGhyZWUtanMgVGFjdGljcyBFbmdpbmVcbiovXG5cblxuKGZ1bmN0aW9uKCkge1xuICB2YXIgQ2xvY2ssIFN0YWdlLCBUaHJlZVRhY3RpY3NFbmdpbmUsIHV0aWxzO1xuXG4gIGNvbnNvbGUubG9nKFwiX2Jhc2VcIik7XG5cbiAgdXRpbHMgPSByZXF1aXJlKFwiLi9fdXRpbHNcIik7XG5cbiAgU3RhZ2UgPSByZXF1aXJlKFwiLi9fc3RhZ2VcIik7XG5cbiAgQ2xvY2sgPSByZXF1aXJlKFwiLi9fY2xvY2tcIik7XG5cbiAgVGhyZWVUYWN0aWNzRW5naW5lID0gZnVuY3Rpb24oKSB7XG4gICAgLypcbiAgICAgIEBQUklWQVRFU1xuICAgICovXG5cbiAgICB2YXIgVEhSRUUsIGNvbmZpZ0xvYWRlZCwgZXZlbnRNZXRob2RzLCBuYW1lLCBfaSwgX2xlbjtcbiAgICBpZiAoc2VsZi5USFJFRSA9PT0gdm9pZCAwIHx8IHNlbGYuJCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZW5naW5lIGlzIGRlcGVuZGVudCBvbiBUSFJFRS5qcyBhbmQgalF1ZXJ5LCB3aGljaCBvbmUgb2Ygd2FzIG5vdCBmb3VuZCwgb3Igbm90IGluIHRoZSBnbG9iYWwgc2NvcGUuXCIpO1xuICAgIH1cbiAgICBUSFJFRSA9IHNlbGYuVEhSRUU7XG4gICAgY29uZmlnTG9hZGVkID0gZmFsc2U7XG4gICAgLypcbiAgICAgIEBQVUJMSUNTXG4gICAgKi9cblxuICAgIHRoaXMubG9hZCA9IGZ1bmN0aW9uKCkge307XG4gICAgdGhpcy5zdGFnZSA9IG5ldyBTdGFnZSgpO1xuICAgIHRoaXMuY2xvY2sgPSBuZXcgQ2xvY2soKTtcbiAgICAvKiBcbiAgICAgIER5bmFtaWNhbGx5IGFkZCBldmVudCBtZXRob2RzIGZyb20gdGhlIGNsb2NrIG9iamVjdCAod2hpY2ggaGFzIGFuIGV2ZW50IGVtaXR0ZXIgYnVpbHQgaW50byBpdC4pXG4gICAgICB0aGlzIGFycmF5IGlzIHRoZSBuYW1lcyBvZiB0aGUgbWV0aG9kcyB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIGV2ZW50cyBvYmplY3RcbiAgICAqL1xuXG4gICAgZXZlbnRNZXRob2RzID0gW1wib25cIiwgXCJvZmZcIiwgXCJkZWZlclwiLCBcImdldEV2ZW50c1wiLCBcInRyaWdnZXJcIiwgXCJyZW1vdmVcIl07XG4gICAgdGhpcy5ldmVudHMgPSB7fTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IGV2ZW50TWV0aG9kcy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgbmFtZSA9IGV2ZW50TWV0aG9kc1tfaV07XG4gICAgICB0aGlzLmV2ZW50c1tuYW1lXSA9IHRoaXMuY2xvY2tbbmFtZV07XG4gICAgfVxuICAgIHRoaXMuZGlzcGxheUxvYWRpbmcgPSBmdW5jdGlvbigpIHt9O1xuICAgIHRoaXMuaW5pdCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBjb25maWcsIHRoYXQ7XG4gICAgICBjb25maWcgPSAkLmdldEpTT04oKG9wdGlvbnMgfHwge30pLmNvbmZpZyB8fCBcImpzb24vY29uZmlnLmpzb25cIik7XG4gICAgICB0aGF0ID0gdGhpcztcbiAgICAgIHRoaXMuZGlzcGxheUxvYWRpbmcoY29uZmlnKTtcbiAgICAgIHJldHVybiBjb25maWcuY29tcGxldGUoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5jb25maWcgPSAkLnBhcnNlSlNPTihjb25maWcucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkpTT04gd2FzIG5vdCBwYXJzZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbmZpZ0xvYWRlZCA9IHRydWU7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiQ29uZmlndXJhdGlvbiBMb2FkZWQuXCIpO1xuICAgICAgICB0aGF0LmRpc3BsYXlMb2FkaW5nKCk7XG4gICAgICAgIGlmICgob3B0aW9ucyB8fCB7fSkuYXV0b3N0YXJ0ID09PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoYXQuc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY2FtZXJhLCByZW5kZXJlciwgc2NlbmU7XG4gICAgICBpZiAoIWNvbmZpZ0xvYWRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpO1xuICAgICAgY2FtZXJhID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKDc1LCB3aW5kb3cuaW5uZXJXaWR0aCAvIHdpbmRvdy5pbm5lckhlaWdodCwgMC4xLCAxMDAwKTtcbiAgICAgIHJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoKTtcbiAgICAgIHJlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHJlbmRlcmVyLmRvbUVsZW1lbnQpO1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB9O1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHNlbGYuRW5naW5lID0gbmV3IFRocmVlVGFjdGljc0VuZ2luZSgpO1xuXG4gIEVuZ2luZS5pbml0KHtcbiAgICBcImF1dG9zdGFydFwiOiB0cnVlXG4gIH0pO1xuXG4gIGNvbnNvbGUubG9nKEVuZ2luZSk7XG5cbn0pLmNhbGwodGhpcyk7XG5cbi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS41LjAtcHJlXG4iLCJcbiAgLypcbiAgICBNb2RpZmllZCB2ZXJzaW9uIGZyb21cblxuICAgICstKy0gR0lUSFVCIC0rLStcbiAgICBodHRwczovL2dpdGh1Yi5jb20vUm9yeUR1bmNhbi9DbG9ja0V2ZW50QWdncmVnZ2F0b3JcbiAgICBcbiAgICArLSstIERPQ1MgLSstK1xuICAgIGh0dHA6Ly9yb3J5ZHVuY2FuLmdpdGh1Yi5pby9DbG9ja0V2ZW50QWdncmVnZ2F0b3IvXG5cbiAgKi9cblxudmFyIHV0aWxzID0gcmVxdWlyZShcIi4vX3V0aWxzXCIpO1xuXG52YXIgQ2xvY2sgPSBmdW5jdGlvbihhcmdzKSB7XG5cbiAgLyogSGVscGVycyAqL1xuXG4gIC8vIEhlbHBlciBmb3IgbWVyZ2luZyBvYmplY3RzXG4gIGV4dGVuZCA9IHV0aWxzLmV4dGVuZDtcblxuICB2YXIgaXNBcnJheSA9IGZ1bmN0aW9uKHRoaW5nKXtcbiAgICAvLyBhc3N1bWUgJ3RoaW5nJyBpcyBub3QgdW5kZWZpbmVkIG9yIG51bGwgYXMgaXQgd2lsbCB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAodHlwZW9mIHRoaW5nID09PSBcInN0cmluZ1wiKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCAodGhpbmcpLmxlbmd0aCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZmFsc2U7XG4gICAgZWxzZSByZXR1cm4gdHJ1ZTsgXG4gIH1cblxuXG4gIC8qICBUaW1lbGluZSByZWxhdGVkIHZhcmlhYmxlcyAgKi9cblxuICB2YXIgZGVmYXVsdHMgPSB7dXNlUkFGOiB0cnVlLCB0aWNrSW50ZXJ2YWw6IDE2LCBhdXRvc3RhcnQ6IGZhbHNlfSxcbiAgICAgIG9wdGlvbnMgPSBleHRlbmQoZGVmYXVsdHMsIGFyZ3MpLFxuICAgICAgdGlja3MgPSAwLFxuICAgICAgbGFzdFRpY2sgPSAwLFxuICAgICAgc3RhcnRUaW1lID0gMCxcblxuICAgICAgLy8gdGhlICdjbG9jaycgdGltZSwgY2FsY3VsYXRlZCB3aXRoIGRlbHRhIGFuZCBjbG9ja1NwZWVkIHZhcmlhYmxlcy5cbiAgICAgIGVsYXBzZWRUaW1lID0gMCxcblxuICAgICAgLy8gaWQgZm9yIHJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgckFGSUQgPSBudWxsLFxuXG4gICAgICAvLyB3aGV0aGVyIHRoaXMgaXMgZXZlcnkgb3RoZXIgdGlja1xuICAgICAgdGlja19uID0gZmFsc2UsXG5cbiAgICAgIC8vIHRoZSBhbW91bnQgb2YgcmVhbC10aW1lIHRoYXQgaGFzIHBhc3NlZCBiZXR3ZWVuIHRpY2tzXG4gICAgICBkZWx0YSA9IDAsXG4gICAgICBhY3R1YWxFbGFwc2VkVGltZSA9IDA7XG5cbiAgICAgIC8vIGZhbGxiYWNrIHRpbWUgZm9yIHNldFRpbWVvdXRcbiAgICAgIHRoaXMudGlja0ludGVydmFsID0gb3B0aW9ucy50aWNrSW50ZXJ2YWwsXG5cbiAgICAgIHJ1bm5pbmcgPSBmYWxzZSxcblxuICAgICAgLy8gc3BlZWQgYXQgd2hpY2ggdGhlIGNsb2NrIHJ1bnNcbiAgICAgIGNsb2Nrc3BlZWQgPSAxLFxuXG4gICAgICAvLyByZWZlcmVuY2VcbiAgICAgIHNlbGYgPSB0aGlzLFxuXG4gICAgICAvLyB3ZXRoZXIgb3Igbm90IHRvIHVzZSByZXF1ZXN0IEFuaW1hdGlvbiBGcmFtZVxuICAgICAgdXNlUkFGID0gb3B0aW9ucy51c2VSQUYsXG5cbiAgICAgIC8vIGR5bmFtaWMgZnVuY3Rpb24gZm9yIHJBRiBvciBzZXRUaW1lb3V0IGZ1bmN0aW9uYWxpdHksXG4gICAgICB0aWNrQ2FsbGVlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIHNldCB0byBzdGFydCgpIGluaXRpYWxseSBpbiBjYXNlIGNhbGxlZCBiZWZvcmUgc3RhcnQgc29tZWhvdy5cbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgfTtcblxuICAgICAgXG4gICAgICBcblxuXG4gIC8qICBFdmVudCBBZ2dyZWdhdG9yIHJlbGF0ZWQgdmFyaWFibGVzICAqL1xuXG4gIHZhciBldmVudHMgPSB7fTtcbiAgICAgIGV2ZW50cy5ub21pbmFsID0ge307XG4gICAgICBldmVudHMub3JkaW5hbCA9IHt9O1xuICAgICAgZXZlbnRzLmxvb3BzID0ge307XG5cbiAgXG4gIC8qICBJbnRlcm5hbCBGdW5jdGlvbnMgKi9cblxuICAvLyAgY2xvY2sncyB0aWNrIG1lY2hhbmlzbVxuICB2YXIgdGljayA9IGZ1bmN0aW9uKCkge1xuICAgIFxuICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTsgLy9jYWNoZVxuICAgIGlmICghcnVubmluZykgcmV0dXJuO1xuICAgIFxuICAgIHRpY2tzICs9IDEgKiBjbG9ja3NwZWVkO1xuICAgIHRpY2tfbiA9ICF0aWNrX247XG4gICAgaWYgKHRoaXMuZGVidWcgJiYgdGlja19uKSB0aGlzLmxvZygpO1xuXG4gICAgXG4gICAgdGhpcy5kZWx0YSA9IGRlbHRhID0gKG5vdyAtIGxhc3RUaWNrKSAqIGNsb2Nrc3BlZWQ7XG5cbiAgICBsYXN0VGljayA9IG5vdztcblxuICAgIGVsYXBzZWRUaW1lICs9IGRlbHRhO1xuXG4gICAgYWN0dWFsRWxhcHNlZFRpbWUgPSAoIG5vdyAtIHN0YXJ0VGltZSApO1xuXG4gICAgdGhpcy5lcnJvck1hcmdpbiA9IGFjdHVhbEVsYXBzZWRUaW1lIC0gZWxhcHNlZFRpbWU7IFxuXG5cbiAgICAvLyBzaW5ndWxhciBldmVudHMgdGFrZSBwcmVjZWRlbmNlIG92ZXIgbG9vcCBldmVudHMuXG4gICAgdHJpZ2dlckN1cnJlbnRFdmVudHMoKTtcbiAgICB0cmlnZ2VyTG9vcEV2ZW50cygpO1xuXG4gICAgdGhpcy50cmlnZ2VyKFwidGlja1wiKTtcblxuICAgIFxuICAgIHJBRklEID0gdGlja0NhbGxlZSgpO1xuXG4gICAgcmV0dXJuIHRpY2tzO1xuICB9O1xuICBcbiAgdmFyIGJ1aWxkRGVmYXVsdEV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGRlZmF1bHRFdmVudHMgPSBbXCJ0aWNrXCIsIFwic3RhcnRcIiwgXCJhZnRlcjpzdGFydFwiLCBcInBhdXNlXCIsIFwicmVzdW1lXCJdLFxuICAgICAgICBhZGRFdmVudCA9IGZ1bmN0aW9uKG5hbWUpe1xuXG4gICAgICAgICAgZXZlbnRzLm9yZGluYWxbbmFtZV0gPSBbXTtcbiAgICAgICAgfTtcblxuICAgIGRlZmF1bHRFdmVudHMuZm9yRWFjaChhZGRFdmVudCk7XG5cbiAgfTtcbiAgYnVpbGREZWZhdWx0RXZlbnRzKCk7XG5cbiAgdmFyIHRyaWdnZXJPcmRpbmFsRXZlbnRzID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgbm93ID0gfn4oZWxhcHNlZFRpbWUgLyAxMDApICogMTAwO1xuXG4gICAgaWYgKCBldmVudHMub3JkaW5hbFsgbm93IF0gPT09IHVuZGVmaW5lZCApIHtyZXR1cm4gZmFsc2U7fSAgLy8gcmV0dXJuIGZhbHNlIGluIGNhc2Ugb2YgY2hlY2tzXG5cbiAgICBcbiAgICB2YXIgZW90ID0gZXZlbnRzLm9yZGluYWxbIG5vdyBdO1xuXG4gICAgLy8gZXZlbnRzLm9yZGluYWwgd2lsbCBiZSBhbiBhcnJheSwgc28gbG9vcCBvdmVyIGVhY2ggZnVuY3Rpb24gaW4gaXQuXG4gICAgZm9yICh2YXIgX3ggPSAwLCBfeHggPSBlb3QubGVuZ3RoOyBfeCA8IF94eDsgX3grKykge1xuXG4gICAgICB2YXIgZm4gPSBlb3RbX3hdLmZuLFxuICAgICAgICAgIGN0eCA9IGVvdFtfeF0uY29udGV4dCxcbiAgICAgICAgICBhcmdzID0gZW90W194XS5hcmdzO1xuXG4gICAgICBmbi5hcHBseShjdHgsIGFyZ3MpO1xuICAgIH1cblxuICAgIC8vIGRlbGV0ZSBpdCwgc28gdGhhdCBpdCB3b24ndCB0cmlnZ2VyIHRoZSBuZXh0IHRpY2tzIHRoYXQgcm91bmQgZG93biB0byB0aGlzIHRpbWUuXG4gICAgZGVsZXRlIGV2ZW50cy5vcmRpbmFsWyBub3cgXTtcblxuICAgIHJldHVybiB0cnVlOyAvLyByZXR1cm4gdHJ1ZSBpbiBjYXNlIG9mIGNoZWNrc1xuICB9O1xuXG4gIHZhciB0cmlnZ2VyTG9vcEV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIG5vdyA9IH5+ZWxhcHNlZFRpbWU7XG5cbiAgICB2YXIgZXhwaXJlZCA9IFtdO1xuXG4gICAgZm9yICh2YXIga2V5IGluIGV2ZW50cy5sb29wcykge1xuXG4gICAgICB2YXIgbG9vcCA9IGV2ZW50cy5sb29wc1sga2V5IF1cblxuICAgICAgaWYgKGxvb3Auc3RhcnQgPD0gbm93ICYmICAgICAgICAgIC8vIENoZWNrIGlmIGl0IGlzICdhbGxvd2VkJyB0byBzdGFydC5cbiAgICAgICAgICBsb29wLmNoZWNrSW50ZXJ2YWwoIG5vdyApICYmICAvLyBDaGVjayB3aGV0aGVyIHRoZSBsb29wIHNob3VsZCBmaXJlIGF0IHRoZSBjdXJyZW50IHRpbWVcbiAgICAgICAgICBsb29wLmRlbGV0ZSA9PT0gZmFsc2UgKSB7ICAgICAgLy8gQ2hlY2sgaWYgaXQgaXMgdG8gYmUgZGVsZXRlZFxuICAgICAgICAgIFxuICAgICAgICAgIC8vIHRoZXJlIGlzIGEgcmVmZXJlbmNlIHRvIF90aGlzXyBpbnNpZGUgb2YgbG9vcCxcbiAgICAgICAgICAvLyBzbyBzZW5kaW5nIHRoZSBsb29wIGl0c2VsZiBhcyBjb250ZXh0IGlzIGVub3VnaC5cbiAgICAgICAgICBsb29wLmNhbGxlZEF0LnB1c2goIG5vdyApO1xuICAgICAgICAgIGxvb3Aubm93ID0gbm93O1xuICAgICAgICAgIFxuICAgICAgICAgIGxvb3AuZm4uYXBwbHkoIGxvb3AsIGxvb3AuYXJncyApO1xuICAgICAgICAgIFxuICAgICAgICAgIGxvb3AubGFzdENhbGwgPSBub3c7XG4gICAgICAgICAgbG9vcC5jYWxscysrO1xuICAgICAgfVxuICAgICAgLy8gY2hlY2sgd2hldGhlciBpdCBoYXMgZXhwaXJlZFxuICAgICAgaWYgKGxvb3Auc3RvcCA9PT0gbm93IHx8IGxvb3AuY2FsbHMgPT09IGxvb3AubWF4SW50ZXJ2YWxzIHx8IGxvb3AuZGVsZXRlID09PSB0cnVlKSB7XG4gICAgICAgIC8vIHB1dCBpdCBpbiB0aGUgYm94IHdoZXJlIGJhZCBsb29wcyBnby5cbiAgICAgICAgZXhwaXJlZC5wdXNoKCBrZXkgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZWxldGUgYW55IGxvb3BzIG1hcmtlZFxuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGV4cGlyZWQubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgdmFyIG5hbWUgPSBleHBpcmVkW2ldO1xuICAgICAgZGVsZXRlIGV2ZW50cy5sb29wc1tuYW1lXTtcbiAgICB9XG4gIH07XG5cblxuICAvKiAgQmluZGluZ3MgICovXG5cbiAgdGhpcy50aWNrID0gdGljay5iaW5kKHRoaXMpO1xuICB2YXIgdHJpZ2dlckxvb3BFdmVudHMgPSB0cmlnZ2VyTG9vcEV2ZW50cy5iaW5kKHRoaXMpO1xuICB2YXIgIHRyaWdnZXJDdXJyZW50RXZlbnRzID0gdHJpZ2dlck9yZGluYWxFdmVudHMuYmluZCh0aGlzKTtcbiAgXG5cblxuICAvKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICovXG4gIC8qICogKiAqICogKiAqICogKiAqICogKiAqICAgQVBJICAgKiAqICogKiAqICogKiAqICogKiAqICogKi9cbiAgLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqL1xuXG5cbiAgLyogIENsb2NrLXJlbGF0ZWQgbWV0aG9kcyAgKi9cblxuICB0aGlzLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG5cbiAgICBpZiAocnVubmluZyA9PT0gdHJ1ZSkgeyByZXR1cm4gdGhpczsgfSAvLyBzaW1wbGUgdGVzdHMgdG8gcHJldmVudCBtdWx0aXBsZSBzdGFydHNcblxuICAgIC8vIHRpY2tMb29wIGlzIGEgZHluYW1pY2FsbHkgY29uc3RydWN0ZWQgZnVuY3Rpb24gdG8gcmVtb3ZlIGFuICdpZicgc3RhdGVtZW50IGluc2lkZSBvZiB0aWNrKCkgLlxuICAgIHZhciB0aWNrTG9vcDsgIFxuXG4gICAgaWYgKHVzZVJBRiA9PT0gdHJ1ZSkge1xuICAgICAgdGlja0xvb3AgPSBuZXcgRnVuY3Rpb24oXCIgdmFyIGlkID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSggdGhpcy50aWNrICk7IHJldHVybiBpZDtcIik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGlja0xvb3AgPSBuZXcgRnVuY3Rpb24oXCIgdmFyIGlkID0gd2luZG93LnNldFRpbWVvdXQodGhpcy50aWNrLCB0aGlzLnRpY2tJbnRlcnZhbCk7cmV0dXJuIGlkO1wiICk7XG4gICAgfVxuICAgIC8vIGJpbmQgaW50byB0aGlzIGNvbnRleHRcbiAgICB0aWNrQ2FsbGVlID0gdGlja0xvb3AuYmluZCh0aGlzKTtcblxuICAgIHRoaXMudHJpZ2dlcihcImJlZm9yZTpzdGFydFwiKTtcblxuICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB0aGlzLnN0YXJ0VGltZSA9IHN0YXJ0VGltZSA9IG5vdztcbiAgICBydW5uaW5nID0gdHJ1ZTtcbiAgICBsYXN0VGljayA9IG5vdztcbiAgICB0aGlzLnRpY2soKTtcblxuICAgIHRoaXMuZW5hYmxlUGF1c2VPbkJsdXIoKTtcbiAgICB0aGlzLnRyaWdnZXIoXCJzdGFydFwiKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LmJpbmQodGhpcyk7XG5cbiAgdGhpcy5zdG9wID0gZnVuY3Rpb24oKXtcblxuICAgIHJ1bm5pbmcgPSBmYWxzZTtcbiAgICAvL3Jlc2V0IGV2ZW50IGxpc3RzXG4gICAgZXZlbnRzLm5vbWluYWwgPSB7fTtcbiAgICBldmVudHMub3JkaW5hbCA9IFtdO1xuICAgIGV2ZW50cy5sb29wcyA9IHt9O1xuXG4gICAgYnVpbGREZWZhdWx0RXZlbnRzKCk7XG5cbiAgICAvL3Jlc2V0IGNvdW50ZXJzXG4gICAgdGlja3MgPSAwO1xuICAgIGVsYXBzZWRUaW1lID0gMDtcbiAgICB0aGlzLnN0YXJ0VGltZSA9IHN0YXJ0VGltZSA9IDA7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfS5iaW5kKHRoaXMpO1xuXG4gIHRoaXMucmVzZXQgPSBmdW5jdGlvbigpe1xuXG4gICAgdGhpcy5yZXNldCgpO1xuICAgIHRoaXMuc3RhcnQoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfS5iaW5kKHRoaXMpO1xuXG4gIHRoaXMucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgICBydW5uaW5nID0gZmFsc2U7XG4gICAgdGhpcy50cmlnZ2VyKFwicGF1c2VcIik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0uYmluZCh0aGlzKTtcblxuICB0aGlzLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChydW5uaW5nID09PSB0cnVlKSByZXR1cm4gdGhpcztcbiAgICBydW5uaW5nID0gdHJ1ZTtcbiAgICBsYXN0VGljayA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIHRoaXMudGljaygpO1xuICAgIHRoaXMudHJpZ2dlcihcInJlc3VtZVwiKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfS5iaW5kKHRoaXMpO1xuXG4gIHRoaXMuY2xvY2tTY2FsYXIgPSBmdW5jdGlvbihtdWx0aXBsaWVyKSB7XG4gICAgLy8gYSByZWxhdGl2ZSB3YXkgdG8gYWZmZWN0IHRoZSBjbG9ja1xuICAgIGNsb2Nrc3BlZWQgKj0gbXVsdGlwbGllciB8fCAxO1xuICB9O1xuXG4gIHRoaXMuc2V0Q2xvY2tTcGVlZCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgLy8gZm9yIG1hbnVhbGx5IGVudGVyaW5nIGEgc3BlZWQgdmFsdWVcbiAgICBjbG9ja3NwZWVkID0gdmFsdWUgfHwgY2xvY2tzcGVlZDtcbiAgfTtcblxuICB0aGlzLmVuYWJsZVBhdXNlT25CbHVyID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gY2FsbGVkIG9uIHN0YXJ0XG4gICAgLy8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIG5hdGl2ZWx5IHBhdXNlcyBvbmJsdXIsIGJ1dCwgdGhpcyBjbG9jayBkb2Vzbid0XG4gICAgLy8gc28gSSd2ZSBwcm9ncmFtbWVkIHRoZSBmdW5jdGlvbmFsaXR5IGludG8gaXQuIFxuXG4gICAgd2luZG93Lm9uYmx1ciA9IGZ1bmN0aW9uKCl7c2VsZi5wYXVzZSgpO31cbiAgICB3aW5kb3cub25mb2N1cyA9IGZ1bmN0aW9uKCl7c2VsZi5yZXN1bWUoKTt9O1xuICB9O1xuXG4gIHRoaXMuZGlzYWJsZVBhdXNlT25CbHVyID0gZnVuY3Rpb24oKXtcbiAgICB3aW5kb3cub25ibHVyID0gZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH07XG4gICAgd2luZG93Lm9uZm9jdXMgPSBmdW5jdGlvbigpe3JldHVybiBudWxsfTtcbiAgfTtcbiAgXG4gIHRoaXMudGlja3MgPSBmdW5jdGlvbigpeyByZXR1cm4gdGlja3M7IH07XG5cbiAgdGhpcy5taWxsaXNlY29uZHMgPSBmdW5jdGlvbigpeyByZXR1cm4gZWxhcHNlZFRpbWU7fTtcblxuICB0aGlzLnNlY29uZHMgPSBmdW5jdGlvbigpeyByZXR1cm4gZWxhcHNlZFRpbWUgLyAxMDAwIDsgfTtcblxuICB0aGlzLm1pbnV0ZXMgPSBmdW5jdGlvbigpeyByZXR1cm4gKHRoaXMuc2Vjb25kcygpIC8gNjApOyB9O1xuXG4gIHRoaXMuZGVidWcgPSBvcHRpb25zLmRlYnVnIHx8IGZhbHNlO1xuXG4gIC8vIGlmIGRlYnVnIGlzIHRydWUsIGxvZyBpcyBhdXRvbWF0aWNhbGx5IGNhbGxlZCBlYWNoIHRpY2tcbiAgdGhpcy5sb2cgPSBmdW5jdGlvbigpIHtcblxuICAgIGNvbnNvbGUuY2xlYXIoKTtcbiAgICBpZiAodXNlUkFGKSBjb25zb2xlLmxvZyhcIjxVc2luZyByZXF1ZXN0QW5pbWF0aW9uRnJhbWU+XCIpO1xuICAgIGVsc2UgY29uc29sZS5sb2coXCI8VXNpbmcgc2V0VGltZW91dD5cIik7XG4gICAgY29uc29sZS5sb2coXCJ0aWNrczpcIiwgdGlja3MpO1xuICAgIGNvbnNvbGUubG9nKFwiZGVsdGE6XCIsIGRlbHRhKTtcbiAgICBjb25zb2xlLmxvZyhcImxhc3RUaWNrKHNob3VsZCBjaGFuZ2UpXCIsIH5+bGFzdFRpY2spXG4gICAgY29uc29sZS5sb2coXCJlbGFwc2VkIHRpbWU6XCIsIGVsYXBzZWRUaW1lIC8gMTAwMCk7XG4gICAgY29uc29sZS5sb2coXCJlbGFwc2VkIHNlY29uZHM6XCIsIH5+KGVsYXBzZWRUaW1lIC8gMTAwMCkpO1xuICAgIGNvbnNvbGUubG9nKFwiYWN0dWFsIGVsYXBzZWQgdGltZTpcIiwgYWN0dWFsRWxhcHNlZFRpbWUgLyAxMDAwKTtcbiAgICBjb25zb2xlLndhcm4oXCIlY2RpZmZlcmVuY2UgKGluIHNlY29uZHMpOiBcIiArICh0aGlzLmVycm9yTWFyZ2luIC8gMTAwMCksIFwiY29sb3I6ICNhMDBcIiApO1xuICAgIGNvbnNvbGUubG9nKFwiSWdub3JlIGRpZmZlcmVuY2VzIGlmIHlvdSBoYXZlIGNhbGxlZCBwYXVzZSBhdCBhbnkgdGltZS5cIik7XG4gICAgY29uc29sZS5sb2coXCJFc3RpbWF0ZWQgRlBTOlwiLCB+fih0aWNrcyAvICggZWxhcHNlZFRpbWUgLyAxMDAwICkpKTtcbiAgfTtcblxuICB0aGlzLnRpbWUgPSB0aGlzLm5vdyA9IGZ1bmN0aW9uKCl7IHJldHVybiBlbGFwc2VkVGltZTsgfTtcblxuXG5cbiAgLyogIEV2ZW50LXJlbGF0ZWQgbWV0aG9kcyAgKi9cbiAgXG4gIHRoaXMudHJpZ2dlciA9IGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xuXG4gICAgaWYgKGV2ZW50cy5ub21pbmFsW2V2ZW50TmFtZV0gPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXM7XG5cbiAgICB2YXIgbCA9IGV2ZW50cy5ub21pbmFsW2V2ZW50TmFtZV0ubGVuZ3RoXG5cbiAgICBmb3IgKHZhciBfeCA9IDAsIF94eCA9IGw7IF94IDwgX3h4OyBfeCsrKSB7XG5cbiAgICAgIC8vIHdvdywgbXVjaCBsZW5ndGgsIG1hbnkgY2hhcnMsIHN1Y2ggc2NhcnkuXG4gICAgICB2YXIgZm4gPSBldmVudHMubm9taW5hbFtldmVudE5hbWVdW194XS5mbixcbiAgICAgICAgICBjdHggPSBldmVudHMubm9taW5hbFtldmVudE5hbWVdW194XS5jb250ZXh0LFxuICAgICAgICAgIGFyZ3MgPSBldmVudHMubm9taW5hbFtldmVudE5hbWVdW194XS5hcmdzO1xuXG4gICAgICBmbi5hcHBseShjdHgsIGFyZ3MpO1xuXG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHRoaXMub24gPSBmdW5jdGlvbiggZXZlbnROYW1lLCBmbiAvKiBbLCBhcmdzLCBjb250ZXh0IF0gKi8gKSB7XG5cbiAgICB2YXIgY29udGV4dCA9IGFyZ3VtZW50c1szXSB8fCB0aGlzLCBhcmdzID0gYXJndW1lbnRzWzJdIHx8IFtdO1xuXG4gICAgLy8gY3JlYXRlIGFuIGFycmF5IGZvciB0aGUgZXZlbnRcbiAgICBldmVudHMubm9taW5hbFtldmVudE5hbWVdID0gZXZlbnRzLm5vbWluYWxbZXZlbnROYW1lXSB8fCBbXVxuXG4gICAgdmFyIHNjb3BlID0gdGhpczsgLy8gYWxsIGV2ZW50cyBkZWZhdWx0IHRvIHRoZSBzY29wZSBvZiB0aGUgVGltZWxpbmUgb2JqZWN0LlxuXG4gICAgZXZlbnRzLm5vbWluYWxbZXZlbnROYW1lXS5wdXNoKHtcbiAgICAgICdmbic6IGZuLFxuICAgICAgJ2FyZ3MnOiBhcmdzLFxuICAgICAgJ2NvbnRleHQnOiBjb250ZXh0XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdGhpcy5hdCA9IGZ1bmN0aW9uKCBlbGFwc2VkTVMsIGZuIC8qIFssIGFyZ3MsIGNvbnRleHQgXSAqLyApIHtcbiAgICBpZiAoZWxhcHNlZE1TID09PSB1bmRlZmluZWQpIHt0aHJvdyBuZXcgRXJyb3IoXCJhdCgpIG1ldGhvZCByZXF1aXJlcyBhIGNsb2NrLXRpbWUgcGFzc2VkIGluIGFzIGZpcnN0IHBhcmFtZXRlci5cIik7IHJldHVybjt9XG4gICAgaWYgKGZuID09PSB1bmRlZmluZWQpIHt0aHJvdyBuZXcgRXJyb3IoXCJhdCgpIG1ldGhvZCByZXF1aXJlcyBhIGZ1bmN0aW9uIHBhc3NlZCBpbiBhcyBzZWNvbmQgcGFyYW1ldGVyLlwiKTsgcmV0dXJuO31cblxuICAgIHZhciBjb250ZXh0ID0gYXJndW1lbnRzWzNdIHx8IG51bGwsIGFyZ3MgPSBhcmd1bWVudHNbMl0gfHwgdGhpcztcblxuICAgIHZhciBhZGRUaW1lID0gZnVuY3Rpb24oIHRpbWUgKSB7XG5cbiAgICAgIHZhciB0ID0gdGltZS50b1N0cmluZygpO1xuICAgICAgZXZlbnRzLm9yZGluYWxbIHRpbWUgXSA9IGV2ZW50cy5vcmRpbmFsWyB0aW1lIF0gfHwgW107XG4gICAgICBldmVudHMub3JkaW5hbFsgdGltZSBdLnB1c2goe1xuICAgICAgICBcImZuXCI6IGZuLFxuICAgICAgICBcImNvbnRleHRcIjogY29udGV4dCxcbiAgICAgICAgXCJhcmdzXCI6IGFyZ3NcbiAgICAgIH0pO1xuXG4gICAgfTtcblxuICAgIGlmICggIWlzQXJyYXkoZWxhcHNlZE1TKSApIHtcbiAgICAgIGFkZFRpbWUoIGVsYXBzZWRNUyApO1xuICAgICAgXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH1cblxuICAgICAgZWxhcHNlZE1TLmZvckVhY2goIGFkZFRpbWUgKTtcblxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB0aGlzLmFmdGVyID0gZnVuY3Rpb24oIG1pbGxpc2Vjb25kcywgZm4gLyogWywgYXJncywgY29udGV4dCBdICovICkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzWzJdLCBjb250ZXh0ID0gYXJndW1lbnRzWzNdO1xuICAgIHRoaXMuYXQoIGVsYXBzZWRUaW1lICsgbWlsbGlzZWNvbmRzLCBmbiwgYXJncywgY29udGV4dCApO1xuICB9O1xuXG4gIHRoaXMubG9vcCA9IGZ1bmN0aW9uKCB1bmlxdWVOYW1lLCBmbiwgYXJncywgc2NvcGUgKSB7XG5cbiAgICAvKlxuICAgICAgICB0aGlzLmxvb3AoKSByZXR1cm5zIGEgbmV3IGxvb3Agb2JqZWN0LCB3aGljaCB0byBhbHRlciB0aW1pbmctcmVsYXRlZCBvcHRpb25zXG4gICAgICAgIHlvdSBjYWxsIGl0J3MgLmZvcigpIG1ldGhvZC4gXG4gICAgICAgIFxuICAgICAgICBFWDpcbiAgICAgICAgdmFyIHggPSB0aGlzLmxvb3AoKmFyZ3MpLmZvcigqYXJncyk7XG4gICAgKi9cblxuICAgIGlmICghdW5pcXVlTmFtZSkgcmV0dXJuIHRoaXM7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGRlZmF1bHRzID0ge1xuICAgICAgICAgIFwiYXV0b3N0YXJ0XCI6IHRydWUsXG4gICAgICAgICAgXCJzdGFydFwiOiB+fmVsYXBzZWRUaW1lLFxuICAgICAgICAgIFwic3RvcFwiOiBJbmZpbml0eSwgXG4gICAgICAgICAgXCJpbnRlcnZhbFwiOiBJbmZpbml0eSwgXG4gICAgICAgICAgXCJtYXhJbnRlcnZhbHNcIjogSW5maW5pdHksIFxuICAgICAgICAgIFwiZHVyYXRpb25cIjogMCwgXG4gICAgICAgICAgXCJjYWxsZWRBdFwiOiBbXSxcbiAgICAgICAgICBcInN0YXJ0RGVsYXlcIjogMFxuICAgICAgICB9LFxuICAgICAgICByZXF1aXJlZCA9IHtcbiAgICAgICAgICBcIm5hbWVcIjp1bmlxdWVOYW1lLFxuICAgICAgICAgIFwiZm5cIjogZm4sXG4gICAgICAgICAgXCJjYWxsc1wiOiAwLFxuICAgICAgICAgIFwicGFyZW50XCI6c2VsZixcbiAgICAgICAgICBcImFyZ3NcIjogYXJncyB8fCBbXVxuICAgICAgICB9O1xuXG4gICAgLy8gdGhlIGxvb3Agb2JqZWN0IHRoYXQgd2lsbCBiZSByZXR1cm5lZFxuICAgIHZhciBMb29wID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXG5cbiAgICAgIGV4dGVuZCh0aGlzLCBkZWZhdWx0cywgcmVxdWlyZWQpO1xuXG4gICAgICAvLyB0aGUgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRoZSBsb29wIGlzIGNhbGxlZFxuICAgICAgdGhpcy5jaGVja0ludGVydmFsID0gZnVuY3Rpb24obm93KSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuc3RhcnQsXG4gICAgICAgICAgICBpbnRlcnZhbCA9IHRoaXMuaW50ZXJ2YWwsXG4gICAgICAgICAgICBkdXJhdGlvbiA9IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICBkb2VzSW50ZXJ2YWxNYXRjaE5vdyA9IChub3cgLSAoc3RhcnQgKyB0aGlzLnN0YXJ0RGVsYXkpKSAgJSAoaW50ZXJ2YWwgKyBkdXJhdGlvbiksXG4gICAgICAgICAgICBpbnRlcnZhbEhhc1Bhc3NlZCA9IG5vdyAtICh0aGlzLmxhc3RDYWxsID09PSB1bmRlZmluZWQgPyBzdGFydCA6IHRoaXMubGFzdENhbGwpO1xuICBcblxuICAgICAgICBjb25zb2xlLmNsZWFyKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwibmFtZTpcIiwgdGhpcy5uYW1lKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJEZWx0YTpcIiwgc2VsZi5kZWx0YSApO1xuICAgICAgICBjb25zb2xlLmxvZyhcIi0tLS0tXCIpO1xuICAgICAgICBjb25zb2xlLmxvZyhcInN0YXJ0OlwiLCBzdGFydCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiZG9lc0ludGVydmFsTWF0Y2hOb3dcIiwgZG9lc0ludGVydmFsTWF0Y2hOb3cpO1xuICAgICAgICBjb25zb2xlLmxvZyhcImludGVydmFsOlwiLCBpbnRlcnZhbCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwibm93OlwiLCBub3cpO1xuICAgICAgICBjb25zb2xlLmxvZyhcImxhc3RDYWxsJ2VkOlwiLCB0aGlzLmxhc3RDYWxsKTtcbiAgICAgICAgXG4gICAgICAgIGlmICggZG9lc0ludGVydmFsTWF0Y2hOb3cgPj0gMCAmJiBkb2VzSW50ZXJ2YWxNYXRjaE5vdyA8PSBkZWx0YSAmJiAobm93IC0gdGhpcy5sYXN0Q2FsbCkgPiAoaW50ZXJ2YWwqMC45OSkgKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZWxzZSByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmZvciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgZXh0ZW5kKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmxhc3RDYWxsID0gdGhpcy5zdGFydCAtIHRoaXMuaW50ZXJ2YWw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5kZWxldGUgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgdmFyIGwgPSBuZXcgTG9vcCgpO1xuXG4gICAgZXZlbnRzLmxvb3BzWyBsLm5hbWUgXSA9IGw7XG5cbiAgICByZXR1cm4gbDtcbiAgfTtcblxuICB0aGlzLnJlbW92ZSA9ICB0aGlzLm9mZiA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICBpZiAodHlwZW9mIGV2ZW50ID09PSBcIm51bWJlclwiKSB7XG5cbiAgICAgIGlmIChldmVudHMub3JkaW5hbFtldmVudF0gPT09IHVuZGVmaW5lZCkgcmV0dXJuIHtcInJlbW92ZWRcIjpmYWxzZSwgXCJjdHhcIjogdGhpc307XG5cbiAgICAgIGRlbGV0ZSBldmVudHMub3JkaW5hbFtldmVudF07XG4gICAgICByZXR1cm4ge1wicmVtb3ZlZFwiOnRydWUsIFwiY3R4XCI6IHRoaXN9O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZXZlbnQgPT09IFwic3RyaW5nXCIpIHtcblxuICAgICAgLy8gaWYgaXQgaXMgYSBldmVudCBzZXQgd2l0aCBvbigpOlxuICAgICAgaWYgKGV2ZW50cy5ub21pbmFsW2V2ZW50TmFtZV0gPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgIC8vaWYgaXQgaXMgYSBsb29wIGV2ZW50IFxuICAgICAgICBpZiAoZXZlbnRzLmxvb3BzW2V2ZW50TmFtZV0gPT09IHVuZGVmaW5lZCkgcmV0dXJuIHtcInJlbW92ZWRcIjpmYWxzZSwgXCJjdHhcIjogdGhpc307XG5cbiAgICAgICAgLy8gbG9vcHMgdGVybWluYXRlIHRoZW1zZWx2ZXMgYXV0b21hdGljYWxseSB3aGVuIHNldCB0byBkZWxldGVcbiAgICAgICAgZXZlbnRzLmxvb3BzW2V2ZW50TmFtZV0uZGVsZXRlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHtcInJlbW92ZWRcIjp0cnVlLCBcImN0eFwiOiB0aGlzfTtcbiAgICAgIH1cblxuICAgICAgZGVsZXRlIGV2ZW50cy5ub21pbmFsW2V2ZW50TmFtZV07XG4gICAgICByZXR1cm4ge1wicmVtb3ZlZFwiOnRydWUsIFwiY3R4XCI6IHRoaXN9O1xuICAgIH0gXG4gIH07XG5cbiAgdGhpcy5kZWZlciA9IGZ1bmN0aW9uKGZuKXtcbiAgICAvLyB3YWl0cyBmb3IgdGhlIGN1cnJlbnQgc3RhY2sgdG8gY2xlYXJcbiAgICB3aW5kb3cuc2V0VGltZW91dCgwLCBmbilcbiAgfTtcblxuICB0aGlzLmdldEV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIGluIGNhc2Ugc29tZW9uZSB3YW50cyB0byB2aWV3IHRoZSBpbnRlcm5hbGx5IHNldCBldmVudHNcbiAgICByZXR1cm4gZXZlbnRzO1xuICB9O1xuXG4gIC8qICogKiAqICogKiAqICogKiAqICogKiAqICpcblxuICAgIGJpbmRUb0Z1bmN0aW9uOlxuXG4gICAgQXR0YWNoICd3YWl0JyBtZXRob2QgdG8gdGhlIEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBkZWxlZ2F0aW5nIHRvIHRoZSB0aW1lbGluZSdzIDx0aGlzPi5hZnRlcigpIG1ldGhvZC5cbiAgICBVc2VmdWw/IENvdWxkIGJlLiBJbnZhc2l2ZSBvZiBnbG9iYWwgcHJvdG90eXBlcz8gRGVmLlxuXG4gICogKiAqICogKiAqICogKiAqICogKiAqICogKi9cbiAgXG4gIGlmIChvcHRpb25zLmJpbmRUb0Z1bmN0aW9uID09PSB0cnVlKSB7XG5cbiAgICAgIHZhciBfdCA9IHRoaXM7IC8vIHJlZmVyZW5jZSwgc2luY2Ugd2FpdCBpcyBpbiB0aGUgY29udGV4dCBvZiB0aGUgY2FsbGVlXG5cbiAgICAgIHZhciB3YWl0ID0gZnVuY3Rpb24oc2Vjb25kcywgYXJncywgY29udGV4dCkge1xuICAgICAgICBfdC5hZnRlcihzZWNvbmRzLCB0aGlzLCBhcmdzLCBjb250ZXh0KTsgXG4gICAgICB9O1xuICAgICAgXG4gICAgICBGdW5jdGlvbi5wcm90b3R5cGUud2FpdCA9IHdhaXQ7XG4gIH1cblxuICBpZiAob3B0aW9ucy5hdXRvc3RhcnQgPT09IHRydWUpIHRoaXMuc3RhcnQoKTtcbiAgZWxzZSByZXR1cm4gdGhpcztcbn07XG4gICBcblxubW9kdWxlLmV4cG9ydHMgPSBDbG9jaztcbiIsIihmdW5jdGlvbigpIHtcbiAgdmFyIFN0YWdlcztcblxuICBTdGFnZXMgPSBmdW5jdGlvbigpIHtcbiAgICBjb25zb2xlLmxvZyhcIl9zdGFnZWxvYWRlclwiKTtcbiAgICB0aGlzLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBTdGFnZXM7XG5cbn0pLmNhbGwodGhpcyk7XG5cbi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS41LjAtcHJlXG4iLCJcbi8qXG4gICAgICB1dGlsaXRpZXNcbiovXG5cblxuKGZ1bmN0aW9uKCkge1xuICB2YXIgX19zbGljZSA9IFtdLnNsaWNlO1xuXG4gIG1vZHVsZS5leHBvcnRzLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBiYXNlLCBleHRlbmRlZCwga2V5LCBvYmosIG9ianMsIF9pLCBfbGVuO1xuICAgIG9ianMgPSAxIDw9IGFyZ3VtZW50cy5sZW5ndGggPyBfX3NsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSA6IFtdO1xuICAgIGlmIChvYmpzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybiBvYmpzWzBdO1xuICAgIH1cbiAgICBleHRlbmRlZCA9IG9ianNbMF07XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBvYmpzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICBvYmogPSBvYmpzW19pXTtcbiAgICAgIGJhc2UgPSBvYmo7XG4gICAgICBmb3IgKGtleSBpbiBiYXNlKSB7XG4gICAgICAgIGV4dGVuZGVkW2tleV0gPSBiYXNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBleHRlbmRlZDtcbiAgfTtcblxufSkuY2FsbCh0aGlzKTtcblxuLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjUuMC1wcmVcbiIsIihmdW5jdGlvbigpIHtcblxuICByZXF1aXJlKFwiLi9fYmFzZVwiKTtcblxuICByZXF1aXJlKFwiLi9tYWluXCIpO1xuXG59KS5jYWxsKHRoaXMpO1xuXG4vLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNS4wLXByZVxuIiwiKGZ1bmN0aW9uKCkge1xuXG5cblxufSkuY2FsbCh0aGlzKTtcblxuLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjUuMC1wcmVcbiJdfQ==
