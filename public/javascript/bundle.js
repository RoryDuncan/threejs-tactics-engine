(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

/*
    three-js Tactics Engine
*/


(function() {
  var Clock, Stage, ThreeTacticsEngine, utils;

  console.log("_base");

  utils = require("./_utils");

  Stage = require("./_stage");

  Clock = require("./_clock");

  ThreeTacticsEngine = function() {
    /*
      @PRIVATES
    */

    var THREE, configLoaded, eventMethods, log, name, scene, that, _i, _len;
    if (self.THREE === void 0 || self.$ === void 0) {
      throw new Error("The engine is dependent on THREE.js and jQuery, which one of was not found, or not in the global scope.");
    }
    THREE = self.THREE;
    configLoaded = false;
    scene = false;
    that = this;
    this.debug = true;
    this.logs = [];
    log = (function(msg) {
      return utils.log.call(this, msg, this.logs);
    }).bind(this);
    this.log = log;
    /*
      @PUBLICS
    */

    this.load = function() {};
    this.renderQueue = [];
    this.stage = new Stage(this);
    this.clock = new Clock();
    /* 
      Dynamically add event methods from the clock object (which has an event emitter built into it.)
      this array is the names of the methods that will be added to the events object
    */

    eventMethods = ["on", "off", "defer", "getEvents", "trigger", "remove"];
    this.events = {};
    for (_i = 0, _len = eventMethods.length; _i < _len; _i++) {
      name = eventMethods[_i];
      this.events[name] = this.clock[name];
    }
    this.init = function(options) {
      var config;
      config = $.getJSON((options || {}).config);
      if (typeof config === void 0) {
        return;
      }
      that = this;
      return config.complete(function() {
        var renderer;
        try {
          that.config = $.parseJSON(config.responseText);
        } catch (e) {
          log(e);
          throw new Error("JSON was not parsed.");
        }
        configLoaded = true;
        log("Configuration Loaded.");
        renderer = new THREE.WebGLRenderer({
          antialias: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        that.renderer = renderer;
        log("Initialized.");
        if ((options || {}).autostart === true) {
          return that.start();
        }
      });
    };
    this.start = function() {
      var stage;
      if (!configLoaded) {
        return;
      }
      return stage = this.stage.create("test", {
        "url": "json/test.json",
        "camera": new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100000),
        "scene": new THREE.Scene()
      });
    };
    return this;
  };

  self.Engine = new ThreeTacticsEngine();

  Engine.init({
    "config": "json/config.json",
    "autostart": true
  });

  console.log(Engine);

}).call(this);

// Generated by CoffeeScript 1.5.0-pre

},{"./_clock":2,"./_stage":5,"./_utils":6}],2:[function(require,module,exports){

  /*
    Modified version from

    +-+- GITHUB -+-+
  unmodified version located at:
    https://github.com/RoryDuncan/ClockEventAggreggator
    
    +-+- DOCUMENTATION -+-+
    http://roryduncan.github.io/ClockEventAggreggator/

  */

var utils = require("./_utils");

var Clock = function(args) {

  /* Helpers */

  // Helper for merging objects
  extend = utils.extend;

  var isArray = function(thing){
    // assume 'thing' is not undefined or null as it will throw a TypeError.
    if (typeof thing === "string") return false;
    if ( (thing).length === undefined) return false;
    else return true; 
  }


  /*  Timeline related variables  */

  var defaults = {useRAF: true, tickInterval: 16, autostart: false},
      options = extend(defaults, args),
      ticks = 0,
      lastTick = 0,
      startTime = 0,

      // the 'clock' time, calculated with delta and clockSpeed variables.
      elapsedTime = 0,

      // id for requestAnimationFrame
      rAFID = null,

      // whether this is every other tick
      tick_n = false,

      // the amount of real-time that has passed between ticks
      delta = 0,
      actualElapsedTime = 0;

      // fallback time for setTimeout
      this.tickInterval = options.tickInterval,

      running = false,

      // speed at which the clock runs
      clockspeed = 1,

      // reference
      self = this,

      // wether or not to use request Animation Frame
      useRAF = options.useRAF,

      // dynamic function for rAF or setTimeout functionality,
      tickCallee = function() {
        // set to start() initially in case called before start somehow.
        this.start();
      };

      
      


  /*  Event Aggregator related variables  */

  var events = {};
      events.nominal = {};
      events.ordinal = {};
      events.loops = {};

  
  /*  Internal Functions */

  //  clock's tick mechanism
  var tick = function() {
    
    var now = new Date().getTime(); //cache
    if (!running) return;
    
    ticks += 1 * clockspeed;
    tick_n = !tick_n;
    if (this.debug && tick_n) this.log();

    
    this.delta = delta = (now - lastTick) * clockspeed;

    lastTick = now;

    elapsedTime += delta;

    actualElapsedTime = ( now - startTime );

    this.errorMargin = actualElapsedTime - elapsedTime; 


    // singular events take precedence over loop events.
    triggerCurrentEvents();
    triggerLoopEvents();

    this.trigger("tick");

    
    rAFID = tickCallee();

    return ticks;
  };
  
  var buildDefaultEvents = function() {

    var defaultEvents = ["tick", "start", "after:start", "pause", "resume"],
        addEvent = function(name){

          events.ordinal[name] = [];
        };

    defaultEvents.forEach(addEvent);

  };
  buildDefaultEvents();

  var triggerOrdinalEvents = function() {

    var now = ~~(elapsedTime / 100) * 100;

    if ( events.ordinal[ now ] === undefined ) {return false;}  // return false in case of checks

    
    var eot = events.ordinal[ now ];

    // events.ordinal will be an array, so loop over each function in it.
    for (var _x = 0, _xx = eot.length; _x < _xx; _x++) {

      var fn = eot[_x].fn,
          ctx = eot[_x].context,
          args = eot[_x].args;

      fn.apply(ctx, args);
    }

    // delete it, so that it won't trigger the next ticks that round down to this time.
    delete events.ordinal[ now ];

    return true; // return true in case of checks
  };

  var triggerLoopEvents = function() {

    var now = ~~elapsedTime;

    var expired = [];

    for (var key in events.loops) {

      var loop = events.loops[ key ]

      if (loop.start <= now &&          // Check if it is 'allowed' to start.
          loop.checkInterval( now ) &&  // Check whether the loop should fire at the current time
          loop.delete === false ) {      // Check if it is to be deleted
          
          // there is a reference to _this_ inside of loop,
          // so sending the loop itself as context is enough.
          loop.calledAt.push( now );
          loop.now = now;
          
          loop.fn.apply( loop.scope, loop.args );
          
          loop.lastCall = now;
          loop.calls++;
      }
      // check whether it has expired
      if (loop.stop === now || loop.calls === loop.maxIntervals || loop.delete === true) {
        // put it in the box where bad loops go.
        expired.push( key );
      }
    }

    // Delete any loops marked
    for (var i = 0, ii = expired.length; i < ii; i++) {
      var name = expired[i];
      delete events.loops[name];
    }
  };


  /*  Bindings  */

  this.tick = tick.bind(this);
  var triggerLoopEvents = triggerLoopEvents.bind(this);
  var  triggerCurrentEvents = triggerOrdinalEvents.bind(this);
  


  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
  /* * * * * * * * * * * * *   API   * * * * * * * * * * * * */
  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


  /*  Clock-related methods  */

  this.start = function() {

    if (running === true) { return this; } // simple tests to prevent multiple starts

    // tickLoop is a dynamically constructed function to remove an 'if' statement inside of tick() .
    var tickLoop;  

    if (useRAF === true) {
      tickLoop = new Function(" var id = window.requestAnimationFrame( this.tick ); return id;");
    }
    else {
      tickLoop = new Function(" var id = window.setTimeout(this.tick, this.tickInterval);return id;" );
    }
    // bind into this context
    tickCallee = tickLoop.bind(this);

    this.trigger("before:start");

    var now = new Date().getTime();
    this.startTime = startTime = now;
    running = true;
    lastTick = now;
    this.tick();

    this.enablePauseOnBlur();
    this.trigger("start");

    return this;
  }.bind(this);

  this.stop = function(){

    running = false;
    //reset event lists
    events.nominal = {};
    events.ordinal = [];
    events.loops = {};

    buildDefaultEvents();

    //reset counters
    ticks = 0;
    elapsedTime = 0;
    this.startTime = startTime = 0;

    return this;
  }.bind(this);

  this.reset = function(){

    this.reset();
    this.start();
    return this;
  }.bind(this);

  this.pause = function() {
    running = false;
    this.trigger("pause");
    return this;
  }.bind(this);

  this.resume = function() {
    if (running === true) return this;
    running = true;
    lastTick = new Date().getTime();
    this.tick();
    this.trigger("resume");
    return this;
  }.bind(this);

  this.clockScalar = function(multiplier) {
    // a relative way to affect the clock
    clockspeed *= multiplier || 1;
  };

  this.setClockSpeed = function(value) {
    // for manually entering a speed value
    clockspeed = value || clockspeed;
  };

  this.enablePauseOnBlur = function() {
    // called on start
    // requestAnimationFrame natively pauses onblur, but, this clock doesn't
    // so I've programmed the functionality into it. 

    window.onblur = function(){self.pause();}
    window.onfocus = function(){self.resume();};
  };

  this.disablePauseOnBlur = function(){
    window.onblur = function(){return null};
    window.onfocus = function(){return null};
  };
  
  this.ticks = function(){ return ticks; };

  this.milliseconds = function(){ return elapsedTime;};

  this.seconds = function(){ return elapsedTime / 1000 ; };

  this.minutes = function(){ return (this.seconds() / 60); };

  this.debug = options.debug || false;

  // if debug is true, log is automatically called each tick
  this.log = function() {

    console.clear();
    if (useRAF) console.log("<Using requestAnimationFrame>");
    else console.log("<Using setTimeout>");
    console.log("ticks:", ticks);
    console.log("delta:", delta);
    console.log("lastTick(should change)", ~~lastTick)
    console.log("elapsed time:", elapsedTime / 1000);
    console.log("elapsed seconds:", ~~(elapsedTime / 1000));
    console.log("actual elapsed time:", actualElapsedTime / 1000);
    console.warn("%cdifference (in seconds): " + (this.errorMargin / 1000), "color: #a00" );
    console.log("Ignore differences if you have called pause at any time.");
    console.log("Estimated FPS:", ~~(ticks / ( elapsedTime / 1000 )));
  };

  this.time = this.now = function(){ return elapsedTime; };



  /*  Event-related methods  */
  
  this.trigger = function(eventName) {

    if (events.nominal[eventName] === undefined) return this;

    var l = events.nominal[eventName].length

    for (var _x = 0, _xx = l; _x < _xx; _x++) {

      // wow, much length, many chars, such scary.
      var fn = events.nominal[eventName][_x].fn,
          ctx = events.nominal[eventName][_x].context,
          args = events.nominal[eventName][_x].args;

      fn.apply(ctx, args);

    }
    return this;
  };

  this.on = function( eventName, fn /* [, args, context ] */ ) {

    var context = arguments[3] || this, args = arguments[2] || [];

    // create an array for the event
    events.nominal[eventName] = events.nominal[eventName] || []

    var scope = this; // all events default to the scope of the Timeline object.

    events.nominal[eventName].push({
      'fn': fn,
      'args': args,
      'context': context
    });
    return this;
  };

  this.at = function( elapsedMS, fn /* [, args, context ] */ ) {
    if (elapsedMS === undefined) {throw new Error("at() method requires a clock-time passed in as first parameter."); return;}
    if (fn === undefined) {throw new Error("at() method requires a function passed in as second parameter."); return;}

    var context = arguments[3] || null, args = arguments[2] || this;

    var addTime = function( time ) {

      var t = time.toString();
      events.ordinal[ time ] = events.ordinal[ time ] || [];
      events.ordinal[ time ].push({
        "fn": fn,
        "context": context,
        "args": args
      });

    };

    if ( !isArray(elapsedMS) ) {
      addTime( elapsedMS );
      
      return this;

    }

      elapsedMS.forEach( addTime );


      return this;
  };

  this.after = function( milliseconds, fn /* [, args, context ] */ ) {
    var args = arguments[2], context = arguments[3];
    this.at( elapsedTime + milliseconds, fn, args, context );
  };

  this.loop = function( uniqueName, fn, args, scope ) {

    /*
        this.loop() returns a new loop object, which to alter timing-related options
        you call it's .for() method. 
        
        EX:
        var x = this.loop(*args).for(*args);
    */

    if (!uniqueName) return this;

    var self = this,
        defaults = {
          "autostart": true,
          "start": ~~elapsedTime,
          "stop": Infinity, 
          "interval": Infinity, 
          "maxIntervals": Infinity, 
          "duration": 0, 
          "calledAt": [],
          "startDelay": 0
        },
        required = {
          "name":uniqueName,
          "fn": fn,
          "scope": scope || self,
          "calls": 0,
          "parent": self,
          "args": args || []
        };

    // the loop object that will be returned
    var Loop = function(options) {


      extend(this, defaults, required);

      // the check to determine if the loop is called
      this.checkInterval = function(now) {
        var start = this.start,
            interval = this.interval,
            duration = this.duration,
            doesIntervalMatchNow = (now - (start + this.startDelay))  % (interval + duration),
            intervalHasPassed = now - (this.lastCall === undefined ? start : this.lastCall);
  
        /*
        console.clear();
        console.log("name:", this.name);
        console.log("Delta:", self.delta );
        console.log("-----");
        console.log("start:", start);
        console.log("doesIntervalMatchNow", doesIntervalMatchNow);
        console.log("interval:", interval);
        console.log("now:", now);
        console.log("lastCall'ed:", this.lastCall);
        */
        
        if ( doesIntervalMatchNow >= 0 && doesIntervalMatchNow <= delta && (now - this.lastCall) > (interval*0.99) ) return true;
        else return false;
      };

      this.for = function(options) {
        extend(this, options);
        this.lastCall = this.start - this.interval;
        return this;
      };

      this.delete = false;
      return this;
    };
    var l = new Loop();

    events.loops[ l.name ] = l;

    return l;
  };

  this.remove =  this.off = function(event) {

    if (typeof event === "number") {

      if (events.ordinal[event] === undefined) return {"removed":false, "ctx": this};

      delete events.ordinal[event];
      return {"removed":true, "ctx": this};
    }

    if (typeof event === "string") {

      // if it is a event set with on():
      if (events.nominal[eventName] === undefined) {

        //if it is a loop event 
        if (events.loops[eventName] === undefined) return {"removed":false, "ctx": this};

        // loops terminate themselves automatically when set to delete
        events.loops[eventName].delete = true;
        return {"removed":true, "ctx": this};
      }

      delete events.nominal[eventName];
      return {"removed":true, "ctx": this};
    } 
  };

  this.defer = function(fn){
    // waits for the current stack to clear
    window.setTimeout(0, fn)
  };

  this.getEvents = function() {
    // in case someone wants to view the internally set events
    return events;
  };

  /* * * * * * * * * * * * * *

    bindToFunction:

    Attach 'wait' method to the Function.prototype,
    delegating to the timeline's <this>.after() method.
    Useful? Could be. Invasive of global prototypes? Def.

  * * * * * * * * * * * * * */
  
  if (options.bindToFunction === true) {

      var _t = this; // reference, since wait is in the context of the callee

      var wait = function(seconds, args, context) {
        _t.after(seconds, this, args, context); 
      };
      
      Function.prototype.wait = wait;
  }

  if (options.autostart === true) this.start();
  else return this;
};
   

module.exports = Clock;

},{"./_utils":6}],3:[function(require,module,exports){

/*
# @InputInterface
#
*/


(function() {
  var utils;

  utils = require("./_utils");

  module.exports.Interface = function(canvas, parent, engine) {
    var $el, bound, handler, key, mousemoveHandler, scope;
    if (!$) {
      return;
    }
    if (arguments.length === 3) {
      $el = $(canvas);
      this.parent = parent;
      this.engine = engine;
      scope = engine;
    } else {
      $el = $(parent.renderer.domElement);
      this.parent = canvas;
      this.engine = parent;
      scope = parent;
    }
    key = {
      "leftClick": 1,
      "scrollwheel": 2,
      "rightClick": 3,
      'backspace': 8,
      'tab': 9,
      'enter': 13,
      'shift': 16,
      'ctrl': 17,
      'alt': 18,
      'pause': 19,
      'capslock': 20,
      'esc': 27,
      'pageup': 33,
      'pagedown': 34,
      'end': 35,
      'home': 36,
      'left': 37,
      'up': 38,
      'right': 39,
      'down': 40,
      'insert': 45,
      'delete': 46,
      '0': 48,
      '1': 49,
      '2': 50,
      '3': 51,
      '4': 52,
      '5': 53,
      '6': 54,
      '7': 55,
      '8': 56,
      '9': 57,
      'a': 65,
      'b': 66,
      'c': 67,
      'd': 68,
      'e': 69,
      'f': 70,
      'g': 71,
      'h': 72,
      'i': 73,
      'j': 74,
      'k': 75,
      'l': 76,
      'm': 77,
      'n': 78,
      'o': 79,
      'p': 80,
      'q': 81,
      'r': 82,
      's': 83,
      't': 84,
      'u': 85,
      'v': 86,
      'w': 87,
      'x': 88,
      'y': 89,
      'z': 90,
      'numpad0': 96,
      'numpad1': 97,
      'numpad2': 98,
      'numpad3': 99,
      'numpad4': 100,
      'numpad5': 101,
      'numpad6': 102,
      'numpad7': 103,
      'numpad8': 104,
      'numpad9': 105,
      'multiply': 106,
      'plus': 107,
      'minut': 109,
      'dot': 110,
      'slash1': 111,
      'F1': 112,
      'F2': 113,
      'F3': 114,
      'F4': 115,
      'F5': 116,
      'F6': 117,
      'F7': 118,
      'F8': 119,
      'F9': 120,
      'F10': 121,
      'F11': 122,
      'F12': 123,
      'equal': 187,
      'coma': 188,
      'slash': 191,
      'backslash': 220
    };
    bound = {};
    handler = function(e) {
      var b, keyname;
      e.preventDefault();
      b = bound[e.type];
      if (!b) {
        return;
      }
      for (keyname in b) {
        if (key[keyname] === e.which) {
          b[keyname].callback.call(b[keyname], b[keyname].data);
          return;
        }
      }
    };
    mousemoveHandler = function(e) {
      var b, data, mouse, normalized, x, y;
      e.preventDefault();
      x = e.clientX;
      y = e.clientY;
      normalized = {
        "x": (x / window.innerWidth) * 2 - 1,
        "y": -(y / window.innerHeight) * 2 + 1
      };
      b = bound["mousemove"];
      data = b.data || {};
      mouse = {
        x: x,
        y: y,
        normalized: normalized
      };
      b.callback.call(parent, mouse, data, e);
    };
    this.bind = this.on = function(events, keyname, callback, data) {
      var b, eventType, _events, _i, _len;
      if (!(arguments.length >= 2)) {
        return;
      }
      _events = events.split(" ");
      if (_events[0] === "mousemove") {
        bound["mousemove"] = {
          "callback": keyname,
          "data": callback
        };
        $el.on("mousemove", mousemoveHandler);
      }
      for (_i = 0, _len = _events.length; _i < _len; _i++) {
        eventType = _events[_i];
        b = bound[eventType] = bound[eventType] || {};
        b[keyname] = {
          callback: callback,
          data: data
        };
        $el.on(eventType, handler);
      }
      return this;
    };
    this.unbind = this.off = function(events, keyname) {
      var eventType, _events, _i, _len;
      _events = events.split(" ");
      for (_i = 0, _len = _events.length; _i < _len; _i++) {
        eventType = _events[_i];
        $el.off(eventType, handler);
        delete bound[eventType][keyname];
      }
      return this;
    };
    this.trigger = function(event) {
      $el.trigger(event);
      return bound[event];
    };
    return this;
  };

  module.exports.MouseDetection = function(parent, engine) {
    var camera, enabled, handler, input, lastIntersection, projector, stage, that;
    enabled = false;
    stage = parent;
    input = parent.Input;
    camera = parent.camera;
    projector = new THREE.Projector();
    this.intersections = null;
    lastIntersection = null;
    that = this;
    handler = function(mouse, camera) {
      var direction, intersect, raycaster, vector;
      vector = new THREE.Vector3(mouse.normalized.x, mouse.normalized.y, 1);
      projector.unprojectVector(vector, camera);
      direction = vector.sub(camera.position).normalize();
      raycaster = new THREE.Raycaster(camera.position, direction);
      that.intersections = raycaster.intersectObjects(stage.meshes);
      if (!that.intersections.length) {
        return;
      }
      intersect = that.intersections[0].object;
      intersect.dispatchEvent({
        type: "hover"
      });
      if (lastIntersection === null) {
        return lastIntersection = intersect;
      } else if (lastIntersection !== intersect) {
        lastIntersection.dispatchEvent({
          type: "leave"
        });
        return lastIntersection = intersect;
      }
    };
    this.detect = function(eventType) {};
    this.toggle = function() {
      if (enabled) {
        return this.disable();
      } else {
        return this.enable();
      }
    };
    this.disable = function() {
      if (enabled) {
        enabled = false;
        input.off("mousemove", handler, camera);
      }
    };
    this.enable = function() {
      if (!enabled) {
        enabled = true;
        return input.on("mousemove", handler, camera);
      }
    };
    this.enable();
    return this;
  };

}).call(this);

// Generated by CoffeeScript 1.5.0-pre

},{"./_utils":6}],4:[function(require,module,exports){
(function() {
  var Cube, Skybox, _class;

  module.exports.Cube = Cube = (function() {

    function Cube(options, scene) {
      var number, that;
      this.scene = scene;
      if (!(options.size && options.position)) {
        return;
      }
      if (typeof options.size === "number") {
        number = options.size;
      }
      this.position = new THREE.Vector3(options.position.x, options.position.y, options.position.z);
      this.geometry = new THREE.BoxGeometry(options.size.x, options.size.y, options.size.z);
      if (!options.material) {
        this.material = new THREE.MeshBasicMaterial({
          opacity: 0.01,
          transparent: true,
          color: 0xffffff,
          wireframe: true
        });
      } else if (options.material.id === void 0) {
        this.material = material || new THREE.MeshBasicMaterial({
          opacity: 0.0,
          transparent: true,
          color: 0x008888,
          wireframe: false
        });
      }
      this.mesh = new THREE.Mesh(this.geometry, this.material);
      this.mesh.position = this.position;
      this.mesh.wrapper = this;
      that = this;
      this.mesh.addEventListener("hover", that.hover);
      this.mesh.addEventListener("leave", that.leave);
      if (this.scene !== void 0) {
        this.addToScene(this.scene);
      }
    }

    Cube.prototype.addToScene = function(scene) {
      this.scene = scene;
      return scene.add(this.mesh);
    };

    Cube.prototype.hover = function() {
      if (this.oldmaterial === void 0) {
        this.oldmaterial = this.material;
      }
      return this.material = this.hovermaterial || new THREE.MeshBasicMaterial({
        opacity: 0.45,
        transparent: true,
        color: 0xffffff,
        wireframe: true
      });
    };

    Cube.prototype.leave = function() {
      return this.material = this.oldmaterial || new THREE.MeshBasicMaterial({
        color: 0x008888
      });
    };

    return Cube;

  })();

  module.exports.Skybox = Skybox = (function() {

    function Skybox() {
      _class.apply(this, arguments);
    }

    _class = console.log("wow");

    return Skybox;

  })();

}).call(this);

// Generated by CoffeeScript 1.5.0-pre

},{}],5:[function(require,module,exports){

/*

  Stages is an object to manage, well, stages.
  which a stage is the equivalent to the game concept of a 'level.'
  but someone could use multiple stages in one level, so I don't want to be pushy and call it a 'level' manager
*/


(function() {
  var Cube, Input, SelectionGrid, Stage, StageManager, utils,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  utils = require("./_utils");

  Input = require("./_input");

  Cube = require("./_objects").Cube;

  /*
      SelectionGrid Class
      Helper class for selecting objects / entities from a grid
      Should be automatically created when
  */


  SelectionGrid = (function() {

    function SelectionGrid(data, engine, stage) {
      var centerIndex, evenOffset, hm, isInt, o, x, x0, y, y0, _ref;
      this.meshes = [];
      this.engine = engine;
      this.stage = stage;
      this.width = data.width;
      this.height = data.length;
      this.padding = data.padding || 2;
      this.x = data.x;
      this.y = data.y;
      isInt = function(num) {
        if (num / Math.floor(num) === 1 || num / Math.floor(num) === -1) {
          return true;
        }
        return false;
      };
      /* Convert the data into a normalized grid data
      */

      evenOffset = (_ref = isInt(data.x / 2)) != null ? _ref : {
        0: 1
      };
      x0 = ~~(data.x / 2);
      y0 = ~~(data.y / 2);
      centerIndex = null;
      x = -1 * x0;
      y = -1 * y0;
      hm = utils.isArray(data.heightmap) ? data.heightmap : (function() {
        var _i, _ref1, _results;
        _results = [];
        for (o = _i = 0, _ref1 = data.x * data.y; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; o = 0 <= _ref1 ? ++_i : --_i) {
          _results.push(o - o);
        }
        return _results;
      })();
      data = hm.map(function(el, index, arr) {
        var node;
        node = {
          "z": el,
          "x": x,
          "y": y
        };
        if (x === 0 && y === 0) {
          node.center = true;
          centerIndex = index;
        }
        if (x === (x0 - evenOffset)) {
          x = -1 * x0;
          y++;
        } else {
          x++;
        }
        return node;
      });
      this.centerIndex = centerIndex;
      this.data = data;
      this.createGrid();
    }

    SelectionGrid.prototype.createGrid = function() {
      var cube, datum, h, material, padding, position, scene, size, w, x, y, _i, _len, _ref, _results;
      if (this.data === void 0) {
        return;
      }
      this.objects = [];
      x = 0;
      y = 0;
      w = this.width;
      h = this.height;
      padding = this.padding || 2;
      _ref = this.data;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        datum = _ref[_i];
        size = {
          x: w,
          y: w,
          z: 0
        };
        position = {
          x: datum.x * (w + padding),
          y: datum.y * (w + padding),
          z: datum.z * (h + padding)
        };
        material = this.material;
        scene = this.stage.scene;
        cube = new Cube({
          size: size,
          position: position,
          material: material
        }, scene);
        this.objects.push(cube);
        _results.push(this.stage.meshes.push(cube.mesh));
      }
      return _results;
    };

    SelectionGrid.prototype.filterData = function(vec3) {
      /*
        argument 'vec3' can be an object or a THREE.Vector3 instance
        ! Vector3 instances don't allow you to have 'undefined' as a value, so using '*' is used
        ie:   filterData( new THREE.Vector3(0, "*", "*") );
      
        Plain objects do allow undefined though, so you can pass in an object with all the values you want
        ie:   filterData({ x: 2});
      */
      if (!vec3) {
        return;
      }
      return this.data.filter(function(el, i, arr) {
        if (el.x === vec3.x || vec3.x === "*" || vec3.x === void 0) {
          if (el.y === vec3.y || vec3.y === "*" || vec3.y === void 0) {
            if (el.z === vec3.z || vec3.z === "*" || vec3.z === void 0) {
              return el;
            }
          }
        }
      });
    };

    return SelectionGrid;

  })();

  Stage = (function(_super) {

    __extends(Stage, _super);

    function Stage(parent, name, options) {
      var beforeLoaded, callbacks, camera, that;
      this.parent = parent;
      this.renderer = parent.renderer;
      this.name = name.toLowerCase();
      this.scene = options.scene;
      camera = options.camera;
      this.camera = camera;
      this.meshes = [];
      beforeLoaded = function() {
        this.render();
        this.Input = new Input.Interface(this, parent);
        this.MouseDetector = new Input.MouseDetection(this, parent);
        return this.onload.call(this);
      };
      that = this;
      that.on("load", beforeLoaded.bind(that));
      callbacks = {
        scope: that,
        success: function(responseText) {
          that.data = responseText;
          console.log("Engine :: '" + name + "' ajax'd. ");
          that.data.grid = that.grid = new SelectionGrid(that.data.grid, that.parent, that);
          return that.trigger("load");
        },
        error: function() {
          throw new Error("Error retrieving data for Stage");
        }
      };
      if (options.url !== void 0) {
        utils.getJSON(options.url, callbacks);
      }
    }

    Stage.prototype.load = function(urlToJson) {
      /*
        incase wasn't originally passed in
      */

      var callbacks, that;
      that = this;
      callbacks = {
        scope: that,
        success: function(responseText) {
          that.data = responseText;
          console.log("Engine :: '" + name + "' ajax'd. ");
          that.data.grid = that.grid = new SelectionGrid(that.data.grid, that.parent, that);
          return that.trigger("load");
        },
        error: function() {
          throw new Error("Error retrieving data for Stage");
        }
      };
      if (urlToJson !== void 0) {
        return utils.getJSON(urlToJson, callbacks);
      }
    };

    Stage.prototype.onload = function() {
      /*
        meant to be overwritten by the user
        alternative is: 
        | @on "load", fn
        which will be triggered on loading
      */
      return this;
    };

    Stage.prototype.lookAt = function(point) {
      this.camera.up = new THREE.Vector3(0, 0, 1);
      return this.camera.lookAt(point || this.scene);
    };

    Stage.prototype.setCameraToIsometric = function() {
      var distanceFromCenterofGridToEdge, h, w, x, xDistance, y, yDistance, zDistance;
      if (!this.grid) {
        return;
      }
      w = this.grid.width;
      h = this.grid.height;
      x = this.grid.x;
      y = this.grid.y;
      distanceFromCenterofGridToEdge = utils.pythag(w * x, h * y);
      zDistance = distanceFromCenterofGridToEdge / 2;
      yDistance = (w + (this.grid.padding || 2)) * x;
      xDistance = (w + (this.grid.padding || 2)) * x;
      this.camera.position.setZ(zDistance);
      this.camera.position.setY(yDistance);
      this.camera.position.setX(xDistance);
      this.camera.up = new THREE.Vector3(0, 0, 1);
      this.camera.lookAt(new THREE.Vector3(0, 0, 0));
      return this;
      /*
      
      
      @camera.rotation.z = 0.25
      */

    };

    Stage.prototype.render = function() {
      var L, extent, geometry, line, material;
      geometry = new THREE.Geometry();
      extent = 5000;
      geometry.vertices.push(new THREE.Vector3(0, 0, -extent));
      geometry.vertices.push(new THREE.Vector3(0, 0, extent));
      geometry.vertices.push(new THREE.Vector3(-extent, 0, 0));
      geometry.vertices.push(new THREE.Vector3(extent, 0, 0));
      geometry.vertices.push(new THREE.Vector3(0, -extent, 0));
      geometry.vertices.push(new THREE.Vector3(0, extent, 0));
      material = new THREE.LineBasicMaterial({
        color: 0x555555
      });
      line = new THREE.Line(geometry, material);
      this.scene.add(line);
      this.setCameraToIsometric();
      this.parent.renderer.render(this.scene, this.camera);
      L = this.parent.clock.loop("render", function() {
        return this.parent.renderer.render(this.scene, this.camera);
      }, null, this);
      L["for"]({
        interval: 17
      });
      return this.parent.clock.start();
    };

    Stage.prototype.destroy = function() {
      return this.parent.destroy(this.name);
    };

    return Stage;

  })(utils.EventEmitter);

  StageManager = function(engine) {
    /* @PRIVATES
    */

    var list, parent;
    parent = engine;
    /* @PUBLICS
    */

    list = {};
    this.list = [];
    this.create = function(name, options) {
      var o, stage;
      if (!name) {
        return;
      }
      o = options || {};
      stage = new Stage(parent, name, o);
      this.list.push(name);
      list[name.toLowerCase()] = stage;
      return list[name.toLowerCase()];
    };
    this.current = void 0;
    this.destroy = function(name) {
      return delete list[name];
    };
    this.load = function(name, transition) {};
    return this;
  };

  module.exports = StageManager;

}).call(this);

// Generated by CoffeeScript 1.5.0-pre

},{"./_input":3,"./_objects":4,"./_utils":6}],6:[function(require,module,exports){

/*
      utilities
*/


(function() {
  var EventEmitter,
    __slice = [].slice;

  module.exports.log = function(msg) {
    var prefix;
    this.logs.unshift(msg);
    if (!this.debug) {
      return;
    }
    prefix = "Engine :: ";
    if (typeof msg === "string") {
      console.log(prefix + msg);
    } else {
      console.log(msg);
    }
  };

  module.exports.extend = function() {
    var base, extended, key, obj, objs, _i, _len;
    objs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (objs.length < 2) {
      return objs[0];
    }
    extended = objs[0];
    for (_i = 0, _len = objs.length; _i < _len; _i++) {
      obj = objs[_i];
      base = obj;
      for (key in base) {
        extended[key] = base[key];
      }
    }
    return extended;
  };

  module.exports.isArray = Array.isArray || function(thing) {
    return Object.prototype.toString.call(thing === "[object Array]");
  };

  module.exports.pythag = window.Math.pythag = function(A, B, hypotenuse) {
    var a2, b2, result;
    if (!(arguments.length >= 2)) {
      return;
    }
    if (B === null) {
      result = (Math.pow(hypotenuse, 2)) - Math.pow(A, 2);
      result = Math.sqrt(result);
      return result;
    } else {
      a2 = Math.pow(A, 2);
      b2 = Math.pow(B, 2);
      result = Math.sqrt(a2 + b2);
      return result;
    }
  };

  module.exports.getJSON = function(url, callbacks) {
    var ajax, data, options;
    options = callbacks || {};
    data = void 0;
    ajax = $.getJSON(url);
    return ajax.complete(function() {
      try {
        data = $.parseJSON(ajax.responseText);
      } catch (e) {
        options.error.call(options.scope || null, e, ajax);
        return;
      }
      options.success.call(options.scope || null, data, ajax);
    });
  };

  module.exports.EventEmitter = EventEmitter = (function() {

    function EventEmitter() {}

    EventEmitter.prototype.events = {};

    EventEmitter.prototype.on = function(name, fn) {
      this.events[name] = fn;
      return this;
    };

    EventEmitter.prototype.off = function(name) {
      delete this.events[name];
      return this;
    };

    EventEmitter.prototype.get = function(name) {
      return this.events[name];
    };

    EventEmitter.prototype.trigger = function(name) {
      var fn;
      fn = this.get(name);
      if (fn === void 0) {
        return;
      }
      fn.call();
      return this;
    };

    return EventEmitter;

  })();

}).call(this);

// Generated by CoffeeScript 1.5.0-pre

},{}],7:[function(require,module,exports){
(function() {

  require("./_base");

  require("./main");

}).call(this);

// Generated by CoffeeScript 1.5.0-pre

},{"./_base":1,"./main":8}],8:[function(require,module,exports){
(function() {



}).call(this);

// Generated by CoffeeScript 1.5.0-pre

},{}]},{},[7])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyJjOlxcVXNlcnNcXFJvYXItWWF3blxcc2FuZGJveFxcdGhyZWVqcy10YWN0aWNzLWVuZ2luZVxcbm9kZV9tb2R1bGVzXFxicm93c2VyaWZ5XFxub2RlX21vZHVsZXNcXGJyb3dzZXItcGFja1xcX3ByZWx1ZGUuanMiLCJjOi9Vc2Vycy9Sb2FyLVlhd24vc2FuZGJveC90aHJlZWpzLXRhY3RpY3MtZW5naW5lL3B1YmxpYy9qYXZhc2NyaXB0L3NyYy9fYmFzZS5qcyIsImM6L1VzZXJzL1JvYXItWWF3bi9zYW5kYm94L3RocmVlanMtdGFjdGljcy1lbmdpbmUvcHVibGljL2phdmFzY3JpcHQvc3JjL19jbG9jay5qcyIsImM6L1VzZXJzL1JvYXItWWF3bi9zYW5kYm94L3RocmVlanMtdGFjdGljcy1lbmdpbmUvcHVibGljL2phdmFzY3JpcHQvc3JjL19pbnB1dC5qcyIsImM6L1VzZXJzL1JvYXItWWF3bi9zYW5kYm94L3RocmVlanMtdGFjdGljcy1lbmdpbmUvcHVibGljL2phdmFzY3JpcHQvc3JjL19vYmplY3RzLmpzIiwiYzovVXNlcnMvUm9hci1ZYXduL3NhbmRib3gvdGhyZWVqcy10YWN0aWNzLWVuZ2luZS9wdWJsaWMvamF2YXNjcmlwdC9zcmMvX3N0YWdlLmpzIiwiYzovVXNlcnMvUm9hci1ZYXduL3NhbmRib3gvdGhyZWVqcy10YWN0aWNzLWVuZ2luZS9wdWJsaWMvamF2YXNjcmlwdC9zcmMvX3V0aWxzLmpzIiwiYzovVXNlcnMvUm9hci1ZYXduL3NhbmRib3gvdGhyZWVqcy10YWN0aWNzLWVuZ2luZS9wdWJsaWMvamF2YXNjcmlwdC9zcmMvYnJvd3Nlci5qcyIsImM6L1VzZXJzL1JvYXItWWF3bi9zYW5kYm94L3RocmVlanMtdGFjdGljcy1lbmdpbmUvcHVibGljL2phdmFzY3JpcHQvc3JjL21haW4uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDemlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpfXZhciBmPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChmLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGYsZi5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJcbi8qXG4gICAgdGhyZWUtanMgVGFjdGljcyBFbmdpbmVcbiovXG5cblxuKGZ1bmN0aW9uKCkge1xuICB2YXIgQ2xvY2ssIFN0YWdlLCBUaHJlZVRhY3RpY3NFbmdpbmUsIHV0aWxzO1xuXG4gIGNvbnNvbGUubG9nKFwiX2Jhc2VcIik7XG5cbiAgdXRpbHMgPSByZXF1aXJlKFwiLi9fdXRpbHNcIik7XG5cbiAgU3RhZ2UgPSByZXF1aXJlKFwiLi9fc3RhZ2VcIik7XG5cbiAgQ2xvY2sgPSByZXF1aXJlKFwiLi9fY2xvY2tcIik7XG5cbiAgVGhyZWVUYWN0aWNzRW5naW5lID0gZnVuY3Rpb24oKSB7XG4gICAgLypcbiAgICAgIEBQUklWQVRFU1xuICAgICovXG5cbiAgICB2YXIgVEhSRUUsIGNvbmZpZ0xvYWRlZCwgZXZlbnRNZXRob2RzLCBsb2csIG5hbWUsIHNjZW5lLCB0aGF0LCBfaSwgX2xlbjtcbiAgICBpZiAoc2VsZi5USFJFRSA9PT0gdm9pZCAwIHx8IHNlbGYuJCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZW5naW5lIGlzIGRlcGVuZGVudCBvbiBUSFJFRS5qcyBhbmQgalF1ZXJ5LCB3aGljaCBvbmUgb2Ygd2FzIG5vdCBmb3VuZCwgb3Igbm90IGluIHRoZSBnbG9iYWwgc2NvcGUuXCIpO1xuICAgIH1cbiAgICBUSFJFRSA9IHNlbGYuVEhSRUU7XG4gICAgY29uZmlnTG9hZGVkID0gZmFsc2U7XG4gICAgc2NlbmUgPSBmYWxzZTtcbiAgICB0aGF0ID0gdGhpcztcbiAgICB0aGlzLmRlYnVnID0gdHJ1ZTtcbiAgICB0aGlzLmxvZ3MgPSBbXTtcbiAgICBsb2cgPSAoZnVuY3Rpb24obXNnKSB7XG4gICAgICByZXR1cm4gdXRpbHMubG9nLmNhbGwodGhpcywgbXNnLCB0aGlzLmxvZ3MpO1xuICAgIH0pLmJpbmQodGhpcyk7XG4gICAgdGhpcy5sb2cgPSBsb2c7XG4gICAgLypcbiAgICAgIEBQVUJMSUNTXG4gICAgKi9cblxuICAgIHRoaXMubG9hZCA9IGZ1bmN0aW9uKCkge307XG4gICAgdGhpcy5yZW5kZXJRdWV1ZSA9IFtdO1xuICAgIHRoaXMuc3RhZ2UgPSBuZXcgU3RhZ2UodGhpcyk7XG4gICAgdGhpcy5jbG9jayA9IG5ldyBDbG9jaygpO1xuICAgIC8qIFxuICAgICAgRHluYW1pY2FsbHkgYWRkIGV2ZW50IG1ldGhvZHMgZnJvbSB0aGUgY2xvY2sgb2JqZWN0ICh3aGljaCBoYXMgYW4gZXZlbnQgZW1pdHRlciBidWlsdCBpbnRvIGl0LilcbiAgICAgIHRoaXMgYXJyYXkgaXMgdGhlIG5hbWVzIG9mIHRoZSBtZXRob2RzIHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgZXZlbnRzIG9iamVjdFxuICAgICovXG5cbiAgICBldmVudE1ldGhvZHMgPSBbXCJvblwiLCBcIm9mZlwiLCBcImRlZmVyXCIsIFwiZ2V0RXZlbnRzXCIsIFwidHJpZ2dlclwiLCBcInJlbW92ZVwiXTtcbiAgICB0aGlzLmV2ZW50cyA9IHt9O1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gZXZlbnRNZXRob2RzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICBuYW1lID0gZXZlbnRNZXRob2RzW19pXTtcbiAgICAgIHRoaXMuZXZlbnRzW25hbWVdID0gdGhpcy5jbG9ja1tuYW1lXTtcbiAgICB9XG4gICAgdGhpcy5pbml0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGNvbmZpZztcbiAgICAgIGNvbmZpZyA9ICQuZ2V0SlNPTigob3B0aW9ucyB8fCB7fSkuY29uZmlnKTtcbiAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhhdCA9IHRoaXM7XG4gICAgICByZXR1cm4gY29uZmlnLmNvbXBsZXRlKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVuZGVyZXI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhhdC5jb25maWcgPSAkLnBhcnNlSlNPTihjb25maWcucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGxvZyhlKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJKU09OIHdhcyBub3QgcGFyc2VkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25maWdMb2FkZWQgPSB0cnVlO1xuICAgICAgICBsb2coXCJDb25maWd1cmF0aW9uIExvYWRlZC5cIik7XG4gICAgICAgIHJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoe1xuICAgICAgICAgIGFudGlhbGlhczogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmVuZGVyZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChyZW5kZXJlci5kb21FbGVtZW50KTtcbiAgICAgICAgdGhhdC5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICBsb2coXCJJbml0aWFsaXplZC5cIik7XG4gICAgICAgIGlmICgob3B0aW9ucyB8fCB7fSkuYXV0b3N0YXJ0ID09PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoYXQuc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc3RhZ2U7XG4gICAgICBpZiAoIWNvbmZpZ0xvYWRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhZ2UgPSB0aGlzLnN0YWdlLmNyZWF0ZShcInRlc3RcIiwge1xuICAgICAgICBcInVybFwiOiBcImpzb24vdGVzdC5qc29uXCIsXG4gICAgICAgIFwiY2FtZXJhXCI6IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSg0NSwgd2luZG93LmlubmVyV2lkdGggLyB3aW5kb3cuaW5uZXJIZWlnaHQsIDAuMSwgMTAwMDAwKSxcbiAgICAgICAgXCJzY2VuZVwiOiBuZXcgVEhSRUUuU2NlbmUoKVxuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBzZWxmLkVuZ2luZSA9IG5ldyBUaHJlZVRhY3RpY3NFbmdpbmUoKTtcblxuICBFbmdpbmUuaW5pdCh7XG4gICAgXCJjb25maWdcIjogXCJqc29uL2NvbmZpZy5qc29uXCIsXG4gICAgXCJhdXRvc3RhcnRcIjogdHJ1ZVxuICB9KTtcblxuICBjb25zb2xlLmxvZyhFbmdpbmUpO1xuXG59KS5jYWxsKHRoaXMpO1xuXG4vLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNS4wLXByZVxuIiwiXG4gIC8qXG4gICAgTW9kaWZpZWQgdmVyc2lvbiBmcm9tXG5cbiAgICArLSstIEdJVEhVQiAtKy0rXG4gIHVubW9kaWZpZWQgdmVyc2lvbiBsb2NhdGVkIGF0OlxuICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9Sb3J5RHVuY2FuL0Nsb2NrRXZlbnRBZ2dyZWdnYXRvclxuICAgIFxuICAgICstKy0gRE9DVU1FTlRBVElPTiAtKy0rXG4gICAgaHR0cDovL3JvcnlkdW5jYW4uZ2l0aHViLmlvL0Nsb2NrRXZlbnRBZ2dyZWdnYXRvci9cblxuICAqL1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKFwiLi9fdXRpbHNcIik7XG5cbnZhciBDbG9jayA9IGZ1bmN0aW9uKGFyZ3MpIHtcblxuICAvKiBIZWxwZXJzICovXG5cbiAgLy8gSGVscGVyIGZvciBtZXJnaW5nIG9iamVjdHNcbiAgZXh0ZW5kID0gdXRpbHMuZXh0ZW5kO1xuXG4gIHZhciBpc0FycmF5ID0gZnVuY3Rpb24odGhpbmcpe1xuICAgIC8vIGFzc3VtZSAndGhpbmcnIGlzIG5vdCB1bmRlZmluZWQgb3IgbnVsbCBhcyBpdCB3aWxsIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmICh0eXBlb2YgdGhpbmcgPT09IFwic3RyaW5nXCIpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoICh0aGluZykubGVuZ3RoID09PSB1bmRlZmluZWQpIHJldHVybiBmYWxzZTtcbiAgICBlbHNlIHJldHVybiB0cnVlOyBcbiAgfVxuXG5cbiAgLyogIFRpbWVsaW5lIHJlbGF0ZWQgdmFyaWFibGVzICAqL1xuXG4gIHZhciBkZWZhdWx0cyA9IHt1c2VSQUY6IHRydWUsIHRpY2tJbnRlcnZhbDogMTYsIGF1dG9zdGFydDogZmFsc2V9LFxuICAgICAgb3B0aW9ucyA9IGV4dGVuZChkZWZhdWx0cywgYXJncyksXG4gICAgICB0aWNrcyA9IDAsXG4gICAgICBsYXN0VGljayA9IDAsXG4gICAgICBzdGFydFRpbWUgPSAwLFxuXG4gICAgICAvLyB0aGUgJ2Nsb2NrJyB0aW1lLCBjYWxjdWxhdGVkIHdpdGggZGVsdGEgYW5kIGNsb2NrU3BlZWQgdmFyaWFibGVzLlxuICAgICAgZWxhcHNlZFRpbWUgPSAwLFxuXG4gICAgICAvLyBpZCBmb3IgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICByQUZJRCA9IG51bGwsXG5cbiAgICAgIC8vIHdoZXRoZXIgdGhpcyBpcyBldmVyeSBvdGhlciB0aWNrXG4gICAgICB0aWNrX24gPSBmYWxzZSxcblxuICAgICAgLy8gdGhlIGFtb3VudCBvZiByZWFsLXRpbWUgdGhhdCBoYXMgcGFzc2VkIGJldHdlZW4gdGlja3NcbiAgICAgIGRlbHRhID0gMCxcbiAgICAgIGFjdHVhbEVsYXBzZWRUaW1lID0gMDtcblxuICAgICAgLy8gZmFsbGJhY2sgdGltZSBmb3Igc2V0VGltZW91dFxuICAgICAgdGhpcy50aWNrSW50ZXJ2YWwgPSBvcHRpb25zLnRpY2tJbnRlcnZhbCxcblxuICAgICAgcnVubmluZyA9IGZhbHNlLFxuXG4gICAgICAvLyBzcGVlZCBhdCB3aGljaCB0aGUgY2xvY2sgcnVuc1xuICAgICAgY2xvY2tzcGVlZCA9IDEsXG5cbiAgICAgIC8vIHJlZmVyZW5jZVxuICAgICAgc2VsZiA9IHRoaXMsXG5cbiAgICAgIC8vIHdldGhlciBvciBub3QgdG8gdXNlIHJlcXVlc3QgQW5pbWF0aW9uIEZyYW1lXG4gICAgICB1c2VSQUYgPSBvcHRpb25zLnVzZVJBRixcblxuICAgICAgLy8gZHluYW1pYyBmdW5jdGlvbiBmb3IgckFGIG9yIHNldFRpbWVvdXQgZnVuY3Rpb25hbGl0eSxcbiAgICAgIHRpY2tDYWxsZWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gc2V0IHRvIHN0YXJ0KCkgaW5pdGlhbGx5IGluIGNhc2UgY2FsbGVkIGJlZm9yZSBzdGFydCBzb21laG93LlxuICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICB9O1xuXG4gICAgICBcbiAgICAgIFxuXG5cbiAgLyogIEV2ZW50IEFnZ3JlZ2F0b3IgcmVsYXRlZCB2YXJpYWJsZXMgICovXG5cbiAgdmFyIGV2ZW50cyA9IHt9O1xuICAgICAgZXZlbnRzLm5vbWluYWwgPSB7fTtcbiAgICAgIGV2ZW50cy5vcmRpbmFsID0ge307XG4gICAgICBldmVudHMubG9vcHMgPSB7fTtcblxuICBcbiAgLyogIEludGVybmFsIEZ1bmN0aW9ucyAqL1xuXG4gIC8vICBjbG9jaydzIHRpY2sgbWVjaGFuaXNtXG4gIHZhciB0aWNrID0gZnVuY3Rpb24oKSB7XG4gICAgXG4gICAgdmFyIG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpOyAvL2NhY2hlXG4gICAgaWYgKCFydW5uaW5nKSByZXR1cm47XG4gICAgXG4gICAgdGlja3MgKz0gMSAqIGNsb2Nrc3BlZWQ7XG4gICAgdGlja19uID0gIXRpY2tfbjtcbiAgICBpZiAodGhpcy5kZWJ1ZyAmJiB0aWNrX24pIHRoaXMubG9nKCk7XG5cbiAgICBcbiAgICB0aGlzLmRlbHRhID0gZGVsdGEgPSAobm93IC0gbGFzdFRpY2spICogY2xvY2tzcGVlZDtcblxuICAgIGxhc3RUaWNrID0gbm93O1xuXG4gICAgZWxhcHNlZFRpbWUgKz0gZGVsdGE7XG5cbiAgICBhY3R1YWxFbGFwc2VkVGltZSA9ICggbm93IC0gc3RhcnRUaW1lICk7XG5cbiAgICB0aGlzLmVycm9yTWFyZ2luID0gYWN0dWFsRWxhcHNlZFRpbWUgLSBlbGFwc2VkVGltZTsgXG5cblxuICAgIC8vIHNpbmd1bGFyIGV2ZW50cyB0YWtlIHByZWNlZGVuY2Ugb3ZlciBsb29wIGV2ZW50cy5cbiAgICB0cmlnZ2VyQ3VycmVudEV2ZW50cygpO1xuICAgIHRyaWdnZXJMb29wRXZlbnRzKCk7XG5cbiAgICB0aGlzLnRyaWdnZXIoXCJ0aWNrXCIpO1xuXG4gICAgXG4gICAgckFGSUQgPSB0aWNrQ2FsbGVlKCk7XG5cbiAgICByZXR1cm4gdGlja3M7XG4gIH07XG4gIFxuICB2YXIgYnVpbGREZWZhdWx0RXZlbnRzID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgZGVmYXVsdEV2ZW50cyA9IFtcInRpY2tcIiwgXCJzdGFydFwiLCBcImFmdGVyOnN0YXJ0XCIsIFwicGF1c2VcIiwgXCJyZXN1bWVcIl0sXG4gICAgICAgIGFkZEV2ZW50ID0gZnVuY3Rpb24obmFtZSl7XG5cbiAgICAgICAgICBldmVudHMub3JkaW5hbFtuYW1lXSA9IFtdO1xuICAgICAgICB9O1xuXG4gICAgZGVmYXVsdEV2ZW50cy5mb3JFYWNoKGFkZEV2ZW50KTtcblxuICB9O1xuICBidWlsZERlZmF1bHRFdmVudHMoKTtcblxuICB2YXIgdHJpZ2dlck9yZGluYWxFdmVudHMgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBub3cgPSB+fihlbGFwc2VkVGltZSAvIDEwMCkgKiAxMDA7XG5cbiAgICBpZiAoIGV2ZW50cy5vcmRpbmFsWyBub3cgXSA9PT0gdW5kZWZpbmVkICkge3JldHVybiBmYWxzZTt9ICAvLyByZXR1cm4gZmFsc2UgaW4gY2FzZSBvZiBjaGVja3NcblxuICAgIFxuICAgIHZhciBlb3QgPSBldmVudHMub3JkaW5hbFsgbm93IF07XG5cbiAgICAvLyBldmVudHMub3JkaW5hbCB3aWxsIGJlIGFuIGFycmF5LCBzbyBsb29wIG92ZXIgZWFjaCBmdW5jdGlvbiBpbiBpdC5cbiAgICBmb3IgKHZhciBfeCA9IDAsIF94eCA9IGVvdC5sZW5ndGg7IF94IDwgX3h4OyBfeCsrKSB7XG5cbiAgICAgIHZhciBmbiA9IGVvdFtfeF0uZm4sXG4gICAgICAgICAgY3R4ID0gZW90W194XS5jb250ZXh0LFxuICAgICAgICAgIGFyZ3MgPSBlb3RbX3hdLmFyZ3M7XG5cbiAgICAgIGZuLmFwcGx5KGN0eCwgYXJncyk7XG4gICAgfVxuXG4gICAgLy8gZGVsZXRlIGl0LCBzbyB0aGF0IGl0IHdvbid0IHRyaWdnZXIgdGhlIG5leHQgdGlja3MgdGhhdCByb3VuZCBkb3duIHRvIHRoaXMgdGltZS5cbiAgICBkZWxldGUgZXZlbnRzLm9yZGluYWxbIG5vdyBdO1xuXG4gICAgcmV0dXJuIHRydWU7IC8vIHJldHVybiB0cnVlIGluIGNhc2Ugb2YgY2hlY2tzXG4gIH07XG5cbiAgdmFyIHRyaWdnZXJMb29wRXZlbnRzID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgbm93ID0gfn5lbGFwc2VkVGltZTtcblxuICAgIHZhciBleHBpcmVkID0gW107XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gZXZlbnRzLmxvb3BzKSB7XG5cbiAgICAgIHZhciBsb29wID0gZXZlbnRzLmxvb3BzWyBrZXkgXVxuXG4gICAgICBpZiAobG9vcC5zdGFydCA8PSBub3cgJiYgICAgICAgICAgLy8gQ2hlY2sgaWYgaXQgaXMgJ2FsbG93ZWQnIHRvIHN0YXJ0LlxuICAgICAgICAgIGxvb3AuY2hlY2tJbnRlcnZhbCggbm93ICkgJiYgIC8vIENoZWNrIHdoZXRoZXIgdGhlIGxvb3Agc2hvdWxkIGZpcmUgYXQgdGhlIGN1cnJlbnQgdGltZVxuICAgICAgICAgIGxvb3AuZGVsZXRlID09PSBmYWxzZSApIHsgICAgICAvLyBDaGVjayBpZiBpdCBpcyB0byBiZSBkZWxldGVkXG4gICAgICAgICAgXG4gICAgICAgICAgLy8gdGhlcmUgaXMgYSByZWZlcmVuY2UgdG8gX3RoaXNfIGluc2lkZSBvZiBsb29wLFxuICAgICAgICAgIC8vIHNvIHNlbmRpbmcgdGhlIGxvb3AgaXRzZWxmIGFzIGNvbnRleHQgaXMgZW5vdWdoLlxuICAgICAgICAgIGxvb3AuY2FsbGVkQXQucHVzaCggbm93ICk7XG4gICAgICAgICAgbG9vcC5ub3cgPSBub3c7XG4gICAgICAgICAgXG4gICAgICAgICAgbG9vcC5mbi5hcHBseSggbG9vcC5zY29wZSwgbG9vcC5hcmdzICk7XG4gICAgICAgICAgXG4gICAgICAgICAgbG9vcC5sYXN0Q2FsbCA9IG5vdztcbiAgICAgICAgICBsb29wLmNhbGxzKys7XG4gICAgICB9XG4gICAgICAvLyBjaGVjayB3aGV0aGVyIGl0IGhhcyBleHBpcmVkXG4gICAgICBpZiAobG9vcC5zdG9wID09PSBub3cgfHwgbG9vcC5jYWxscyA9PT0gbG9vcC5tYXhJbnRlcnZhbHMgfHwgbG9vcC5kZWxldGUgPT09IHRydWUpIHtcbiAgICAgICAgLy8gcHV0IGl0IGluIHRoZSBib3ggd2hlcmUgYmFkIGxvb3BzIGdvLlxuICAgICAgICBleHBpcmVkLnB1c2goIGtleSApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERlbGV0ZSBhbnkgbG9vcHMgbWFya2VkXG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZXhwaXJlZC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICB2YXIgbmFtZSA9IGV4cGlyZWRbaV07XG4gICAgICBkZWxldGUgZXZlbnRzLmxvb3BzW25hbWVdO1xuICAgIH1cbiAgfTtcblxuXG4gIC8qICBCaW5kaW5ncyAgKi9cblxuICB0aGlzLnRpY2sgPSB0aWNrLmJpbmQodGhpcyk7XG4gIHZhciB0cmlnZ2VyTG9vcEV2ZW50cyA9IHRyaWdnZXJMb29wRXZlbnRzLmJpbmQodGhpcyk7XG4gIHZhciAgdHJpZ2dlckN1cnJlbnRFdmVudHMgPSB0cmlnZ2VyT3JkaW5hbEV2ZW50cy5iaW5kKHRoaXMpO1xuICBcblxuXG4gIC8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKi9cbiAgLyogKiAqICogKiAqICogKiAqICogKiAqICogICBBUEkgICAqICogKiAqICogKiAqICogKiAqICogKiAqL1xuICAvKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICovXG5cblxuICAvKiAgQ2xvY2stcmVsYXRlZCBtZXRob2RzICAqL1xuXG4gIHRoaXMuc3RhcnQgPSBmdW5jdGlvbigpIHtcblxuICAgIGlmIChydW5uaW5nID09PSB0cnVlKSB7IHJldHVybiB0aGlzOyB9IC8vIHNpbXBsZSB0ZXN0cyB0byBwcmV2ZW50IG11bHRpcGxlIHN0YXJ0c1xuXG4gICAgLy8gdGlja0xvb3AgaXMgYSBkeW5hbWljYWxseSBjb25zdHJ1Y3RlZCBmdW5jdGlvbiB0byByZW1vdmUgYW4gJ2lmJyBzdGF0ZW1lbnQgaW5zaWRlIG9mIHRpY2soKSAuXG4gICAgdmFyIHRpY2tMb29wOyAgXG5cbiAgICBpZiAodXNlUkFGID09PSB0cnVlKSB7XG4gICAgICB0aWNrTG9vcCA9IG5ldyBGdW5jdGlvbihcIiB2YXIgaWQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCB0aGlzLnRpY2sgKTsgcmV0dXJuIGlkO1wiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aWNrTG9vcCA9IG5ldyBGdW5jdGlvbihcIiB2YXIgaWQgPSB3aW5kb3cuc2V0VGltZW91dCh0aGlzLnRpY2ssIHRoaXMudGlja0ludGVydmFsKTtyZXR1cm4gaWQ7XCIgKTtcbiAgICB9XG4gICAgLy8gYmluZCBpbnRvIHRoaXMgY29udGV4dFxuICAgIHRpY2tDYWxsZWUgPSB0aWNrTG9vcC5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy50cmlnZ2VyKFwiYmVmb3JlOnN0YXJ0XCIpO1xuXG4gICAgdmFyIG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIHRoaXMuc3RhcnRUaW1lID0gc3RhcnRUaW1lID0gbm93O1xuICAgIHJ1bm5pbmcgPSB0cnVlO1xuICAgIGxhc3RUaWNrID0gbm93O1xuICAgIHRoaXMudGljaygpO1xuXG4gICAgdGhpcy5lbmFibGVQYXVzZU9uQmx1cigpO1xuICAgIHRoaXMudHJpZ2dlcihcInN0YXJ0XCIpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0uYmluZCh0aGlzKTtcblxuICB0aGlzLnN0b3AgPSBmdW5jdGlvbigpe1xuXG4gICAgcnVubmluZyA9IGZhbHNlO1xuICAgIC8vcmVzZXQgZXZlbnQgbGlzdHNcbiAgICBldmVudHMubm9taW5hbCA9IHt9O1xuICAgIGV2ZW50cy5vcmRpbmFsID0gW107XG4gICAgZXZlbnRzLmxvb3BzID0ge307XG5cbiAgICBidWlsZERlZmF1bHRFdmVudHMoKTtcblxuICAgIC8vcmVzZXQgY291bnRlcnNcbiAgICB0aWNrcyA9IDA7XG4gICAgZWxhcHNlZFRpbWUgPSAwO1xuICAgIHRoaXMuc3RhcnRUaW1lID0gc3RhcnRUaW1lID0gMDtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LmJpbmQodGhpcyk7XG5cbiAgdGhpcy5yZXNldCA9IGZ1bmN0aW9uKCl7XG5cbiAgICB0aGlzLnJlc2V0KCk7XG4gICAgdGhpcy5zdGFydCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LmJpbmQodGhpcyk7XG5cbiAgdGhpcy5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJ1bm5pbmcgPSBmYWxzZTtcbiAgICB0aGlzLnRyaWdnZXIoXCJwYXVzZVwiKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfS5iaW5kKHRoaXMpO1xuXG4gIHRoaXMucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHJ1bm5pbmcgPT09IHRydWUpIHJldHVybiB0aGlzO1xuICAgIHJ1bm5pbmcgPSB0cnVlO1xuICAgIGxhc3RUaWNrID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgdGhpcy50aWNrKCk7XG4gICAgdGhpcy50cmlnZ2VyKFwicmVzdW1lXCIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LmJpbmQodGhpcyk7XG5cbiAgdGhpcy5jbG9ja1NjYWxhciA9IGZ1bmN0aW9uKG11bHRpcGxpZXIpIHtcbiAgICAvLyBhIHJlbGF0aXZlIHdheSB0byBhZmZlY3QgdGhlIGNsb2NrXG4gICAgY2xvY2tzcGVlZCAqPSBtdWx0aXBsaWVyIHx8IDE7XG4gIH07XG5cbiAgdGhpcy5zZXRDbG9ja1NwZWVkID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAvLyBmb3IgbWFudWFsbHkgZW50ZXJpbmcgYSBzcGVlZCB2YWx1ZVxuICAgIGNsb2Nrc3BlZWQgPSB2YWx1ZSB8fCBjbG9ja3NwZWVkO1xuICB9O1xuXG4gIHRoaXMuZW5hYmxlUGF1c2VPbkJsdXIgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBjYWxsZWQgb24gc3RhcnRcbiAgICAvLyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgbmF0aXZlbHkgcGF1c2VzIG9uYmx1ciwgYnV0LCB0aGlzIGNsb2NrIGRvZXNuJ3RcbiAgICAvLyBzbyBJJ3ZlIHByb2dyYW1tZWQgdGhlIGZ1bmN0aW9uYWxpdHkgaW50byBpdC4gXG5cbiAgICB3aW5kb3cub25ibHVyID0gZnVuY3Rpb24oKXtzZWxmLnBhdXNlKCk7fVxuICAgIHdpbmRvdy5vbmZvY3VzID0gZnVuY3Rpb24oKXtzZWxmLnJlc3VtZSgpO307XG4gIH07XG5cbiAgdGhpcy5kaXNhYmxlUGF1c2VPbkJsdXIgPSBmdW5jdGlvbigpe1xuICAgIHdpbmRvdy5vbmJsdXIgPSBmdW5jdGlvbigpe3JldHVybiBudWxsfTtcbiAgICB3aW5kb3cub25mb2N1cyA9IGZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9O1xuICB9O1xuICBcbiAgdGhpcy50aWNrcyA9IGZ1bmN0aW9uKCl7IHJldHVybiB0aWNrczsgfTtcblxuICB0aGlzLm1pbGxpc2Vjb25kcyA9IGZ1bmN0aW9uKCl7IHJldHVybiBlbGFwc2VkVGltZTt9O1xuXG4gIHRoaXMuc2Vjb25kcyA9IGZ1bmN0aW9uKCl7IHJldHVybiBlbGFwc2VkVGltZSAvIDEwMDAgOyB9O1xuXG4gIHRoaXMubWludXRlcyA9IGZ1bmN0aW9uKCl7IHJldHVybiAodGhpcy5zZWNvbmRzKCkgLyA2MCk7IH07XG5cbiAgdGhpcy5kZWJ1ZyA9IG9wdGlvbnMuZGVidWcgfHwgZmFsc2U7XG5cbiAgLy8gaWYgZGVidWcgaXMgdHJ1ZSwgbG9nIGlzIGF1dG9tYXRpY2FsbHkgY2FsbGVkIGVhY2ggdGlja1xuICB0aGlzLmxvZyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgY29uc29sZS5jbGVhcigpO1xuICAgIGlmICh1c2VSQUYpIGNvbnNvbGUubG9nKFwiPFVzaW5nIHJlcXVlc3RBbmltYXRpb25GcmFtZT5cIik7XG4gICAgZWxzZSBjb25zb2xlLmxvZyhcIjxVc2luZyBzZXRUaW1lb3V0PlwiKTtcbiAgICBjb25zb2xlLmxvZyhcInRpY2tzOlwiLCB0aWNrcyk7XG4gICAgY29uc29sZS5sb2coXCJkZWx0YTpcIiwgZGVsdGEpO1xuICAgIGNvbnNvbGUubG9nKFwibGFzdFRpY2soc2hvdWxkIGNoYW5nZSlcIiwgfn5sYXN0VGljaylcbiAgICBjb25zb2xlLmxvZyhcImVsYXBzZWQgdGltZTpcIiwgZWxhcHNlZFRpbWUgLyAxMDAwKTtcbiAgICBjb25zb2xlLmxvZyhcImVsYXBzZWQgc2Vjb25kczpcIiwgfn4oZWxhcHNlZFRpbWUgLyAxMDAwKSk7XG4gICAgY29uc29sZS5sb2coXCJhY3R1YWwgZWxhcHNlZCB0aW1lOlwiLCBhY3R1YWxFbGFwc2VkVGltZSAvIDEwMDApO1xuICAgIGNvbnNvbGUud2FybihcIiVjZGlmZmVyZW5jZSAoaW4gc2Vjb25kcyk6IFwiICsgKHRoaXMuZXJyb3JNYXJnaW4gLyAxMDAwKSwgXCJjb2xvcjogI2EwMFwiICk7XG4gICAgY29uc29sZS5sb2coXCJJZ25vcmUgZGlmZmVyZW5jZXMgaWYgeW91IGhhdmUgY2FsbGVkIHBhdXNlIGF0IGFueSB0aW1lLlwiKTtcbiAgICBjb25zb2xlLmxvZyhcIkVzdGltYXRlZCBGUFM6XCIsIH5+KHRpY2tzIC8gKCBlbGFwc2VkVGltZSAvIDEwMDAgKSkpO1xuICB9O1xuXG4gIHRoaXMudGltZSA9IHRoaXMubm93ID0gZnVuY3Rpb24oKXsgcmV0dXJuIGVsYXBzZWRUaW1lOyB9O1xuXG5cblxuICAvKiAgRXZlbnQtcmVsYXRlZCBtZXRob2RzICAqL1xuICBcbiAgdGhpcy50cmlnZ2VyID0gZnVuY3Rpb24oZXZlbnROYW1lKSB7XG5cbiAgICBpZiAoZXZlbnRzLm5vbWluYWxbZXZlbnROYW1lXSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcztcblxuICAgIHZhciBsID0gZXZlbnRzLm5vbWluYWxbZXZlbnROYW1lXS5sZW5ndGhcblxuICAgIGZvciAodmFyIF94ID0gMCwgX3h4ID0gbDsgX3ggPCBfeHg7IF94KyspIHtcblxuICAgICAgLy8gd293LCBtdWNoIGxlbmd0aCwgbWFueSBjaGFycywgc3VjaCBzY2FyeS5cbiAgICAgIHZhciBmbiA9IGV2ZW50cy5ub21pbmFsW2V2ZW50TmFtZV1bX3hdLmZuLFxuICAgICAgICAgIGN0eCA9IGV2ZW50cy5ub21pbmFsW2V2ZW50TmFtZV1bX3hdLmNvbnRleHQsXG4gICAgICAgICAgYXJncyA9IGV2ZW50cy5ub21pbmFsW2V2ZW50TmFtZV1bX3hdLmFyZ3M7XG5cbiAgICAgIGZuLmFwcGx5KGN0eCwgYXJncyk7XG5cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdGhpcy5vbiA9IGZ1bmN0aW9uKCBldmVudE5hbWUsIGZuIC8qIFssIGFyZ3MsIGNvbnRleHQgXSAqLyApIHtcblxuICAgIHZhciBjb250ZXh0ID0gYXJndW1lbnRzWzNdIHx8IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHNbMl0gfHwgW107XG5cbiAgICAvLyBjcmVhdGUgYW4gYXJyYXkgZm9yIHRoZSBldmVudFxuICAgIGV2ZW50cy5ub21pbmFsW2V2ZW50TmFtZV0gPSBldmVudHMubm9taW5hbFtldmVudE5hbWVdIHx8IFtdXG5cbiAgICB2YXIgc2NvcGUgPSB0aGlzOyAvLyBhbGwgZXZlbnRzIGRlZmF1bHQgdG8gdGhlIHNjb3BlIG9mIHRoZSBUaW1lbGluZSBvYmplY3QuXG5cbiAgICBldmVudHMubm9taW5hbFtldmVudE5hbWVdLnB1c2goe1xuICAgICAgJ2ZuJzogZm4sXG4gICAgICAnYXJncyc6IGFyZ3MsXG4gICAgICAnY29udGV4dCc6IGNvbnRleHRcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB0aGlzLmF0ID0gZnVuY3Rpb24oIGVsYXBzZWRNUywgZm4gLyogWywgYXJncywgY29udGV4dCBdICovICkge1xuICAgIGlmIChlbGFwc2VkTVMgPT09IHVuZGVmaW5lZCkge3Rocm93IG5ldyBFcnJvcihcImF0KCkgbWV0aG9kIHJlcXVpcmVzIGEgY2xvY2stdGltZSBwYXNzZWQgaW4gYXMgZmlyc3QgcGFyYW1ldGVyLlwiKTsgcmV0dXJuO31cbiAgICBpZiAoZm4gPT09IHVuZGVmaW5lZCkge3Rocm93IG5ldyBFcnJvcihcImF0KCkgbWV0aG9kIHJlcXVpcmVzIGEgZnVuY3Rpb24gcGFzc2VkIGluIGFzIHNlY29uZCBwYXJhbWV0ZXIuXCIpOyByZXR1cm47fVxuXG4gICAgdmFyIGNvbnRleHQgPSBhcmd1bWVudHNbM10gfHwgbnVsbCwgYXJncyA9IGFyZ3VtZW50c1syXSB8fCB0aGlzO1xuXG4gICAgdmFyIGFkZFRpbWUgPSBmdW5jdGlvbiggdGltZSApIHtcblxuICAgICAgdmFyIHQgPSB0aW1lLnRvU3RyaW5nKCk7XG4gICAgICBldmVudHMub3JkaW5hbFsgdGltZSBdID0gZXZlbnRzLm9yZGluYWxbIHRpbWUgXSB8fCBbXTtcbiAgICAgIGV2ZW50cy5vcmRpbmFsWyB0aW1lIF0ucHVzaCh7XG4gICAgICAgIFwiZm5cIjogZm4sXG4gICAgICAgIFwiY29udGV4dFwiOiBjb250ZXh0LFxuICAgICAgICBcImFyZ3NcIjogYXJnc1xuICAgICAgfSk7XG5cbiAgICB9O1xuXG4gICAgaWYgKCAhaXNBcnJheShlbGFwc2VkTVMpICkge1xuICAgICAgYWRkVGltZSggZWxhcHNlZE1TICk7XG4gICAgICBcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfVxuXG4gICAgICBlbGFwc2VkTVMuZm9yRWFjaCggYWRkVGltZSApO1xuXG5cbiAgICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHRoaXMuYWZ0ZXIgPSBmdW5jdGlvbiggbWlsbGlzZWNvbmRzLCBmbiAvKiBbLCBhcmdzLCBjb250ZXh0IF0gKi8gKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHNbMl0sIGNvbnRleHQgPSBhcmd1bWVudHNbM107XG4gICAgdGhpcy5hdCggZWxhcHNlZFRpbWUgKyBtaWxsaXNlY29uZHMsIGZuLCBhcmdzLCBjb250ZXh0ICk7XG4gIH07XG5cbiAgdGhpcy5sb29wID0gZnVuY3Rpb24oIHVuaXF1ZU5hbWUsIGZuLCBhcmdzLCBzY29wZSApIHtcblxuICAgIC8qXG4gICAgICAgIHRoaXMubG9vcCgpIHJldHVybnMgYSBuZXcgbG9vcCBvYmplY3QsIHdoaWNoIHRvIGFsdGVyIHRpbWluZy1yZWxhdGVkIG9wdGlvbnNcbiAgICAgICAgeW91IGNhbGwgaXQncyAuZm9yKCkgbWV0aG9kLiBcbiAgICAgICAgXG4gICAgICAgIEVYOlxuICAgICAgICB2YXIgeCA9IHRoaXMubG9vcCgqYXJncykuZm9yKCphcmdzKTtcbiAgICAqL1xuXG4gICAgaWYgKCF1bmlxdWVOYW1lKSByZXR1cm4gdGhpcztcblxuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgZGVmYXVsdHMgPSB7XG4gICAgICAgICAgXCJhdXRvc3RhcnRcIjogdHJ1ZSxcbiAgICAgICAgICBcInN0YXJ0XCI6IH5+ZWxhcHNlZFRpbWUsXG4gICAgICAgICAgXCJzdG9wXCI6IEluZmluaXR5LCBcbiAgICAgICAgICBcImludGVydmFsXCI6IEluZmluaXR5LCBcbiAgICAgICAgICBcIm1heEludGVydmFsc1wiOiBJbmZpbml0eSwgXG4gICAgICAgICAgXCJkdXJhdGlvblwiOiAwLCBcbiAgICAgICAgICBcImNhbGxlZEF0XCI6IFtdLFxuICAgICAgICAgIFwic3RhcnREZWxheVwiOiAwXG4gICAgICAgIH0sXG4gICAgICAgIHJlcXVpcmVkID0ge1xuICAgICAgICAgIFwibmFtZVwiOnVuaXF1ZU5hbWUsXG4gICAgICAgICAgXCJmblwiOiBmbixcbiAgICAgICAgICBcInNjb3BlXCI6IHNjb3BlIHx8IHNlbGYsXG4gICAgICAgICAgXCJjYWxsc1wiOiAwLFxuICAgICAgICAgIFwicGFyZW50XCI6IHNlbGYsXG4gICAgICAgICAgXCJhcmdzXCI6IGFyZ3MgfHwgW11cbiAgICAgICAgfTtcblxuICAgIC8vIHRoZSBsb29wIG9iamVjdCB0aGF0IHdpbGwgYmUgcmV0dXJuZWRcbiAgICB2YXIgTG9vcCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblxuXG4gICAgICBleHRlbmQodGhpcywgZGVmYXVsdHMsIHJlcXVpcmVkKTtcblxuICAgICAgLy8gdGhlIGNoZWNrIHRvIGRldGVybWluZSBpZiB0aGUgbG9vcCBpcyBjYWxsZWRcbiAgICAgIHRoaXMuY2hlY2tJbnRlcnZhbCA9IGZ1bmN0aW9uKG5vdykge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnN0YXJ0LFxuICAgICAgICAgICAgaW50ZXJ2YWwgPSB0aGlzLmludGVydmFsLFxuICAgICAgICAgICAgZHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgZG9lc0ludGVydmFsTWF0Y2hOb3cgPSAobm93IC0gKHN0YXJ0ICsgdGhpcy5zdGFydERlbGF5KSkgICUgKGludGVydmFsICsgZHVyYXRpb24pLFxuICAgICAgICAgICAgaW50ZXJ2YWxIYXNQYXNzZWQgPSBub3cgLSAodGhpcy5sYXN0Q2FsbCA9PT0gdW5kZWZpbmVkID8gc3RhcnQgOiB0aGlzLmxhc3RDYWxsKTtcbiAgXG4gICAgICAgIC8qXG4gICAgICAgIGNvbnNvbGUuY2xlYXIoKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJuYW1lOlwiLCB0aGlzLm5hbWUpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIkRlbHRhOlwiLCBzZWxmLmRlbHRhICk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiLS0tLS1cIik7XG4gICAgICAgIGNvbnNvbGUubG9nKFwic3RhcnQ6XCIsIHN0YXJ0KTtcbiAgICAgICAgY29uc29sZS5sb2coXCJkb2VzSW50ZXJ2YWxNYXRjaE5vd1wiLCBkb2VzSW50ZXJ2YWxNYXRjaE5vdyk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiaW50ZXJ2YWw6XCIsIGludGVydmFsKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJub3c6XCIsIG5vdyk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwibGFzdENhbGwnZWQ6XCIsIHRoaXMubGFzdENhbGwpO1xuICAgICAgICAqL1xuICAgICAgICBcbiAgICAgICAgaWYgKCBkb2VzSW50ZXJ2YWxNYXRjaE5vdyA+PSAwICYmIGRvZXNJbnRlcnZhbE1hdGNoTm93IDw9IGRlbHRhICYmIChub3cgLSB0aGlzLmxhc3RDYWxsKSA+IChpbnRlcnZhbCowLjk5KSApIHJldHVybiB0cnVlO1xuICAgICAgICBlbHNlIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuZm9yID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBleHRlbmQodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMubGFzdENhbGwgPSB0aGlzLnN0YXJ0IC0gdGhpcy5pbnRlcnZhbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmRlbGV0ZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICB2YXIgbCA9IG5ldyBMb29wKCk7XG5cbiAgICBldmVudHMubG9vcHNbIGwubmFtZSBdID0gbDtcblxuICAgIHJldHVybiBsO1xuICB9O1xuXG4gIHRoaXMucmVtb3ZlID0gIHRoaXMub2ZmID0gZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgIGlmICh0eXBlb2YgZXZlbnQgPT09IFwibnVtYmVyXCIpIHtcblxuICAgICAgaWYgKGV2ZW50cy5vcmRpbmFsW2V2ZW50XSA9PT0gdW5kZWZpbmVkKSByZXR1cm4ge1wicmVtb3ZlZFwiOmZhbHNlLCBcImN0eFwiOiB0aGlzfTtcblxuICAgICAgZGVsZXRlIGV2ZW50cy5vcmRpbmFsW2V2ZW50XTtcbiAgICAgIHJldHVybiB7XCJyZW1vdmVkXCI6dHJ1ZSwgXCJjdHhcIjogdGhpc307XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBldmVudCA9PT0gXCJzdHJpbmdcIikge1xuXG4gICAgICAvLyBpZiBpdCBpcyBhIGV2ZW50IHNldCB3aXRoIG9uKCk6XG4gICAgICBpZiAoZXZlbnRzLm5vbWluYWxbZXZlbnROYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgLy9pZiBpdCBpcyBhIGxvb3AgZXZlbnQgXG4gICAgICAgIGlmIChldmVudHMubG9vcHNbZXZlbnROYW1lXSA9PT0gdW5kZWZpbmVkKSByZXR1cm4ge1wicmVtb3ZlZFwiOmZhbHNlLCBcImN0eFwiOiB0aGlzfTtcblxuICAgICAgICAvLyBsb29wcyB0ZXJtaW5hdGUgdGhlbXNlbHZlcyBhdXRvbWF0aWNhbGx5IHdoZW4gc2V0IHRvIGRlbGV0ZVxuICAgICAgICBldmVudHMubG9vcHNbZXZlbnROYW1lXS5kZWxldGUgPSB0cnVlO1xuICAgICAgICByZXR1cm4ge1wicmVtb3ZlZFwiOnRydWUsIFwiY3R4XCI6IHRoaXN9O1xuICAgICAgfVxuXG4gICAgICBkZWxldGUgZXZlbnRzLm5vbWluYWxbZXZlbnROYW1lXTtcbiAgICAgIHJldHVybiB7XCJyZW1vdmVkXCI6dHJ1ZSwgXCJjdHhcIjogdGhpc307XG4gICAgfSBcbiAgfTtcblxuICB0aGlzLmRlZmVyID0gZnVuY3Rpb24oZm4pe1xuICAgIC8vIHdhaXRzIGZvciB0aGUgY3VycmVudCBzdGFjayB0byBjbGVhclxuICAgIHdpbmRvdy5zZXRUaW1lb3V0KDAsIGZuKVxuICB9O1xuXG4gIHRoaXMuZ2V0RXZlbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gaW4gY2FzZSBzb21lb25lIHdhbnRzIHRvIHZpZXcgdGhlIGludGVybmFsbHkgc2V0IGV2ZW50c1xuICAgIHJldHVybiBldmVudHM7XG4gIH07XG5cbiAgLyogKiAqICogKiAqICogKiAqICogKiAqICogKlxuXG4gICAgYmluZFRvRnVuY3Rpb246XG5cbiAgICBBdHRhY2ggJ3dhaXQnIG1ldGhvZCB0byB0aGUgRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIGRlbGVnYXRpbmcgdG8gdGhlIHRpbWVsaW5lJ3MgPHRoaXM+LmFmdGVyKCkgbWV0aG9kLlxuICAgIFVzZWZ1bD8gQ291bGQgYmUuIEludmFzaXZlIG9mIGdsb2JhbCBwcm90b3R5cGVzPyBEZWYuXG5cbiAgKiAqICogKiAqICogKiAqICogKiAqICogKiAqL1xuICBcbiAgaWYgKG9wdGlvbnMuYmluZFRvRnVuY3Rpb24gPT09IHRydWUpIHtcblxuICAgICAgdmFyIF90ID0gdGhpczsgLy8gcmVmZXJlbmNlLCBzaW5jZSB3YWl0IGlzIGluIHRoZSBjb250ZXh0IG9mIHRoZSBjYWxsZWVcblxuICAgICAgdmFyIHdhaXQgPSBmdW5jdGlvbihzZWNvbmRzLCBhcmdzLCBjb250ZXh0KSB7XG4gICAgICAgIF90LmFmdGVyKHNlY29uZHMsIHRoaXMsIGFyZ3MsIGNvbnRleHQpOyBcbiAgICAgIH07XG4gICAgICBcbiAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZS53YWl0ID0gd2FpdDtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmF1dG9zdGFydCA9PT0gdHJ1ZSkgdGhpcy5zdGFydCgpO1xuICBlbHNlIHJldHVybiB0aGlzO1xufTtcbiAgIFxuXG5tb2R1bGUuZXhwb3J0cyA9IENsb2NrO1xuIiwiXG4vKlxuIyBASW5wdXRJbnRlcmZhY2VcbiNcbiovXG5cblxuKGZ1bmN0aW9uKCkge1xuICB2YXIgdXRpbHM7XG5cbiAgdXRpbHMgPSByZXF1aXJlKFwiLi9fdXRpbHNcIik7XG5cbiAgbW9kdWxlLmV4cG9ydHMuSW50ZXJmYWNlID0gZnVuY3Rpb24oY2FudmFzLCBwYXJlbnQsIGVuZ2luZSkge1xuICAgIHZhciAkZWwsIGJvdW5kLCBoYW5kbGVyLCBrZXksIG1vdXNlbW92ZUhhbmRsZXIsIHNjb3BlO1xuICAgIGlmICghJCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgJGVsID0gJChjYW52YXMpO1xuICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICB0aGlzLmVuZ2luZSA9IGVuZ2luZTtcbiAgICAgIHNjb3BlID0gZW5naW5lO1xuICAgIH0gZWxzZSB7XG4gICAgICAkZWwgPSAkKHBhcmVudC5yZW5kZXJlci5kb21FbGVtZW50KTtcbiAgICAgIHRoaXMucGFyZW50ID0gY2FudmFzO1xuICAgICAgdGhpcy5lbmdpbmUgPSBwYXJlbnQ7XG4gICAgICBzY29wZSA9IHBhcmVudDtcbiAgICB9XG4gICAga2V5ID0ge1xuICAgICAgXCJsZWZ0Q2xpY2tcIjogMSxcbiAgICAgIFwic2Nyb2xsd2hlZWxcIjogMixcbiAgICAgIFwicmlnaHRDbGlja1wiOiAzLFxuICAgICAgJ2JhY2tzcGFjZSc6IDgsXG4gICAgICAndGFiJzogOSxcbiAgICAgICdlbnRlcic6IDEzLFxuICAgICAgJ3NoaWZ0JzogMTYsXG4gICAgICAnY3RybCc6IDE3LFxuICAgICAgJ2FsdCc6IDE4LFxuICAgICAgJ3BhdXNlJzogMTksXG4gICAgICAnY2Fwc2xvY2snOiAyMCxcbiAgICAgICdlc2MnOiAyNyxcbiAgICAgICdwYWdldXAnOiAzMyxcbiAgICAgICdwYWdlZG93bic6IDM0LFxuICAgICAgJ2VuZCc6IDM1LFxuICAgICAgJ2hvbWUnOiAzNixcbiAgICAgICdsZWZ0JzogMzcsXG4gICAgICAndXAnOiAzOCxcbiAgICAgICdyaWdodCc6IDM5LFxuICAgICAgJ2Rvd24nOiA0MCxcbiAgICAgICdpbnNlcnQnOiA0NSxcbiAgICAgICdkZWxldGUnOiA0NixcbiAgICAgICcwJzogNDgsXG4gICAgICAnMSc6IDQ5LFxuICAgICAgJzInOiA1MCxcbiAgICAgICczJzogNTEsXG4gICAgICAnNCc6IDUyLFxuICAgICAgJzUnOiA1MyxcbiAgICAgICc2JzogNTQsXG4gICAgICAnNyc6IDU1LFxuICAgICAgJzgnOiA1NixcbiAgICAgICc5JzogNTcsXG4gICAgICAnYSc6IDY1LFxuICAgICAgJ2InOiA2NixcbiAgICAgICdjJzogNjcsXG4gICAgICAnZCc6IDY4LFxuICAgICAgJ2UnOiA2OSxcbiAgICAgICdmJzogNzAsXG4gICAgICAnZyc6IDcxLFxuICAgICAgJ2gnOiA3MixcbiAgICAgICdpJzogNzMsXG4gICAgICAnaic6IDc0LFxuICAgICAgJ2snOiA3NSxcbiAgICAgICdsJzogNzYsXG4gICAgICAnbSc6IDc3LFxuICAgICAgJ24nOiA3OCxcbiAgICAgICdvJzogNzksXG4gICAgICAncCc6IDgwLFxuICAgICAgJ3EnOiA4MSxcbiAgICAgICdyJzogODIsXG4gICAgICAncyc6IDgzLFxuICAgICAgJ3QnOiA4NCxcbiAgICAgICd1JzogODUsXG4gICAgICAndic6IDg2LFxuICAgICAgJ3cnOiA4NyxcbiAgICAgICd4JzogODgsXG4gICAgICAneSc6IDg5LFxuICAgICAgJ3onOiA5MCxcbiAgICAgICdudW1wYWQwJzogOTYsXG4gICAgICAnbnVtcGFkMSc6IDk3LFxuICAgICAgJ251bXBhZDInOiA5OCxcbiAgICAgICdudW1wYWQzJzogOTksXG4gICAgICAnbnVtcGFkNCc6IDEwMCxcbiAgICAgICdudW1wYWQ1JzogMTAxLFxuICAgICAgJ251bXBhZDYnOiAxMDIsXG4gICAgICAnbnVtcGFkNyc6IDEwMyxcbiAgICAgICdudW1wYWQ4JzogMTA0LFxuICAgICAgJ251bXBhZDknOiAxMDUsXG4gICAgICAnbXVsdGlwbHknOiAxMDYsXG4gICAgICAncGx1cyc6IDEwNyxcbiAgICAgICdtaW51dCc6IDEwOSxcbiAgICAgICdkb3QnOiAxMTAsXG4gICAgICAnc2xhc2gxJzogMTExLFxuICAgICAgJ0YxJzogMTEyLFxuICAgICAgJ0YyJzogMTEzLFxuICAgICAgJ0YzJzogMTE0LFxuICAgICAgJ0Y0JzogMTE1LFxuICAgICAgJ0Y1JzogMTE2LFxuICAgICAgJ0Y2JzogMTE3LFxuICAgICAgJ0Y3JzogMTE4LFxuICAgICAgJ0Y4JzogMTE5LFxuICAgICAgJ0Y5JzogMTIwLFxuICAgICAgJ0YxMCc6IDEyMSxcbiAgICAgICdGMTEnOiAxMjIsXG4gICAgICAnRjEyJzogMTIzLFxuICAgICAgJ2VxdWFsJzogMTg3LFxuICAgICAgJ2NvbWEnOiAxODgsXG4gICAgICAnc2xhc2gnOiAxOTEsXG4gICAgICAnYmFja3NsYXNoJzogMjIwXG4gICAgfTtcbiAgICBib3VuZCA9IHt9O1xuICAgIGhhbmRsZXIgPSBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgYiwga2V5bmFtZTtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGIgPSBib3VuZFtlLnR5cGVdO1xuICAgICAgaWYgKCFiKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAoa2V5bmFtZSBpbiBiKSB7XG4gICAgICAgIGlmIChrZXlba2V5bmFtZV0gPT09IGUud2hpY2gpIHtcbiAgICAgICAgICBiW2tleW5hbWVdLmNhbGxiYWNrLmNhbGwoYltrZXluYW1lXSwgYltrZXluYW1lXS5kYXRhKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIG1vdXNlbW92ZUhhbmRsZXIgPSBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgYiwgZGF0YSwgbW91c2UsIG5vcm1hbGl6ZWQsIHgsIHk7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB4ID0gZS5jbGllbnRYO1xuICAgICAgeSA9IGUuY2xpZW50WTtcbiAgICAgIG5vcm1hbGl6ZWQgPSB7XG4gICAgICAgIFwieFwiOiAoeCAvIHdpbmRvdy5pbm5lcldpZHRoKSAqIDIgLSAxLFxuICAgICAgICBcInlcIjogLSh5IC8gd2luZG93LmlubmVySGVpZ2h0KSAqIDIgKyAxXG4gICAgICB9O1xuICAgICAgYiA9IGJvdW5kW1wibW91c2Vtb3ZlXCJdO1xuICAgICAgZGF0YSA9IGIuZGF0YSB8fCB7fTtcbiAgICAgIG1vdXNlID0ge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICBub3JtYWxpemVkOiBub3JtYWxpemVkXG4gICAgICB9O1xuICAgICAgYi5jYWxsYmFjay5jYWxsKHBhcmVudCwgbW91c2UsIGRhdGEsIGUpO1xuICAgIH07XG4gICAgdGhpcy5iaW5kID0gdGhpcy5vbiA9IGZ1bmN0aW9uKGV2ZW50cywga2V5bmFtZSwgY2FsbGJhY2ssIGRhdGEpIHtcbiAgICAgIHZhciBiLCBldmVudFR5cGUsIF9ldmVudHMsIF9pLCBfbGVuO1xuICAgICAgaWYgKCEoYXJndW1lbnRzLmxlbmd0aCA+PSAyKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBfZXZlbnRzID0gZXZlbnRzLnNwbGl0KFwiIFwiKTtcbiAgICAgIGlmIChfZXZlbnRzWzBdID09PSBcIm1vdXNlbW92ZVwiKSB7XG4gICAgICAgIGJvdW5kW1wibW91c2Vtb3ZlXCJdID0ge1xuICAgICAgICAgIFwiY2FsbGJhY2tcIjoga2V5bmFtZSxcbiAgICAgICAgICBcImRhdGFcIjogY2FsbGJhY2tcbiAgICAgICAgfTtcbiAgICAgICAgJGVsLm9uKFwibW91c2Vtb3ZlXCIsIG1vdXNlbW92ZUhhbmRsZXIpO1xuICAgICAgfVxuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfZXZlbnRzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGV2ZW50VHlwZSA9IF9ldmVudHNbX2ldO1xuICAgICAgICBiID0gYm91bmRbZXZlbnRUeXBlXSA9IGJvdW5kW2V2ZW50VHlwZV0gfHwge307XG4gICAgICAgIGJba2V5bmFtZV0gPSB7XG4gICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgfTtcbiAgICAgICAgJGVsLm9uKGV2ZW50VHlwZSwgaGFuZGxlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHRoaXMudW5iaW5kID0gdGhpcy5vZmYgPSBmdW5jdGlvbihldmVudHMsIGtleW5hbWUpIHtcbiAgICAgIHZhciBldmVudFR5cGUsIF9ldmVudHMsIF9pLCBfbGVuO1xuICAgICAgX2V2ZW50cyA9IGV2ZW50cy5zcGxpdChcIiBcIik7XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9ldmVudHMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgZXZlbnRUeXBlID0gX2V2ZW50c1tfaV07XG4gICAgICAgICRlbC5vZmYoZXZlbnRUeXBlLCBoYW5kbGVyKTtcbiAgICAgICAgZGVsZXRlIGJvdW5kW2V2ZW50VHlwZV1ba2V5bmFtZV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHRoaXMudHJpZ2dlciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAkZWwudHJpZ2dlcihldmVudCk7XG4gICAgICByZXR1cm4gYm91bmRbZXZlbnRdO1xuICAgIH07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMuTW91c2VEZXRlY3Rpb24gPSBmdW5jdGlvbihwYXJlbnQsIGVuZ2luZSkge1xuICAgIHZhciBjYW1lcmEsIGVuYWJsZWQsIGhhbmRsZXIsIGlucHV0LCBsYXN0SW50ZXJzZWN0aW9uLCBwcm9qZWN0b3IsIHN0YWdlLCB0aGF0O1xuICAgIGVuYWJsZWQgPSBmYWxzZTtcbiAgICBzdGFnZSA9IHBhcmVudDtcbiAgICBpbnB1dCA9IHBhcmVudC5JbnB1dDtcbiAgICBjYW1lcmEgPSBwYXJlbnQuY2FtZXJhO1xuICAgIHByb2plY3RvciA9IG5ldyBUSFJFRS5Qcm9qZWN0b3IoKTtcbiAgICB0aGlzLmludGVyc2VjdGlvbnMgPSBudWxsO1xuICAgIGxhc3RJbnRlcnNlY3Rpb24gPSBudWxsO1xuICAgIHRoYXQgPSB0aGlzO1xuICAgIGhhbmRsZXIgPSBmdW5jdGlvbihtb3VzZSwgY2FtZXJhKSB7XG4gICAgICB2YXIgZGlyZWN0aW9uLCBpbnRlcnNlY3QsIHJheWNhc3RlciwgdmVjdG9yO1xuICAgICAgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMobW91c2Uubm9ybWFsaXplZC54LCBtb3VzZS5ub3JtYWxpemVkLnksIDEpO1xuICAgICAgcHJvamVjdG9yLnVucHJvamVjdFZlY3Rvcih2ZWN0b3IsIGNhbWVyYSk7XG4gICAgICBkaXJlY3Rpb24gPSB2ZWN0b3Iuc3ViKGNhbWVyYS5wb3NpdGlvbikubm9ybWFsaXplKCk7XG4gICAgICByYXljYXN0ZXIgPSBuZXcgVEhSRUUuUmF5Y2FzdGVyKGNhbWVyYS5wb3NpdGlvbiwgZGlyZWN0aW9uKTtcbiAgICAgIHRoYXQuaW50ZXJzZWN0aW9ucyA9IHJheWNhc3Rlci5pbnRlcnNlY3RPYmplY3RzKHN0YWdlLm1lc2hlcyk7XG4gICAgICBpZiAoIXRoYXQuaW50ZXJzZWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaW50ZXJzZWN0ID0gdGhhdC5pbnRlcnNlY3Rpb25zWzBdLm9iamVjdDtcbiAgICAgIGludGVyc2VjdC5kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgdHlwZTogXCJob3ZlclwiXG4gICAgICB9KTtcbiAgICAgIGlmIChsYXN0SW50ZXJzZWN0aW9uID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBsYXN0SW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0O1xuICAgICAgfSBlbHNlIGlmIChsYXN0SW50ZXJzZWN0aW9uICE9PSBpbnRlcnNlY3QpIHtcbiAgICAgICAgbGFzdEludGVyc2VjdGlvbi5kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICB0eXBlOiBcImxlYXZlXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBsYXN0SW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0O1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5kZXRlY3QgPSBmdW5jdGlvbihldmVudFR5cGUpIHt9O1xuICAgIHRoaXMudG9nZ2xlID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmFibGUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuZGlzYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICBpbnB1dC5vZmYoXCJtb3VzZW1vdmVcIiwgaGFuZGxlciwgY2FtZXJhKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuZW5hYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgICAgZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBpbnB1dC5vbihcIm1vdXNlbW92ZVwiLCBoYW5kbGVyLCBjYW1lcmEpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5lbmFibGUoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxufSkuY2FsbCh0aGlzKTtcblxuLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjUuMC1wcmVcbiIsIihmdW5jdGlvbigpIHtcbiAgdmFyIEN1YmUsIFNreWJveCwgX2NsYXNzO1xuXG4gIG1vZHVsZS5leHBvcnRzLkN1YmUgPSBDdWJlID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgZnVuY3Rpb24gQ3ViZShvcHRpb25zLCBzY2VuZSkge1xuICAgICAgdmFyIG51bWJlciwgdGhhdDtcbiAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcbiAgICAgIGlmICghKG9wdGlvbnMuc2l6ZSAmJiBvcHRpb25zLnBvc2l0aW9uKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMuc2l6ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBudW1iZXIgPSBvcHRpb25zLnNpemU7XG4gICAgICB9XG4gICAgICB0aGlzLnBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMob3B0aW9ucy5wb3NpdGlvbi54LCBvcHRpb25zLnBvc2l0aW9uLnksIG9wdGlvbnMucG9zaXRpb24ueik7XG4gICAgICB0aGlzLmdlb21ldHJ5ID0gbmV3IFRIUkVFLkJveEdlb21ldHJ5KG9wdGlvbnMuc2l6ZS54LCBvcHRpb25zLnNpemUueSwgb3B0aW9ucy5zaXplLnopO1xuICAgICAgaWYgKCFvcHRpb25zLm1hdGVyaWFsKSB7XG4gICAgICAgIHRoaXMubWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICAgICAgICAgIG9wYWNpdHk6IDAuMDEsXG4gICAgICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsXG4gICAgICAgICAgY29sb3I6IDB4ZmZmZmZmLFxuICAgICAgICAgIHdpcmVmcmFtZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5tYXRlcmlhbC5pZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbCB8fCBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICAgICAgICAgIG9wYWNpdHk6IDAuMCxcbiAgICAgICAgICB0cmFuc3BhcmVudDogdHJ1ZSxcbiAgICAgICAgICBjb2xvcjogMHgwMDg4ODgsXG4gICAgICAgICAgd2lyZWZyYW1lOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWVzaCA9IG5ldyBUSFJFRS5NZXNoKHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwpO1xuICAgICAgdGhpcy5tZXNoLnBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgIHRoaXMubWVzaC53cmFwcGVyID0gdGhpcztcbiAgICAgIHRoYXQgPSB0aGlzO1xuICAgICAgdGhpcy5tZXNoLmFkZEV2ZW50TGlzdGVuZXIoXCJob3ZlclwiLCB0aGF0LmhvdmVyKTtcbiAgICAgIHRoaXMubWVzaC5hZGRFdmVudExpc3RlbmVyKFwibGVhdmVcIiwgdGhhdC5sZWF2ZSk7XG4gICAgICBpZiAodGhpcy5zY2VuZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXMuYWRkVG9TY2VuZSh0aGlzLnNjZW5lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBDdWJlLnByb3RvdHlwZS5hZGRUb1NjZW5lID0gZnVuY3Rpb24oc2NlbmUpIHtcbiAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcbiAgICAgIHJldHVybiBzY2VuZS5hZGQodGhpcy5tZXNoKTtcbiAgICB9O1xuXG4gICAgQ3ViZS5wcm90b3R5cGUuaG92ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLm9sZG1hdGVyaWFsID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhpcy5vbGRtYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5tYXRlcmlhbCA9IHRoaXMuaG92ZXJtYXRlcmlhbCB8fCBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICAgICAgICBvcGFjaXR5OiAwLjQ1LFxuICAgICAgICB0cmFuc3BhcmVudDogdHJ1ZSxcbiAgICAgICAgY29sb3I6IDB4ZmZmZmZmLFxuICAgICAgICB3aXJlZnJhbWU6IHRydWVcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBDdWJlLnByb3RvdHlwZS5sZWF2ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWF0ZXJpYWwgPSB0aGlzLm9sZG1hdGVyaWFsIHx8IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7XG4gICAgICAgIGNvbG9yOiAweDAwODg4OFxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBDdWJlO1xuXG4gIH0pKCk7XG5cbiAgbW9kdWxlLmV4cG9ydHMuU2t5Ym94ID0gU2t5Ym94ID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgZnVuY3Rpb24gU2t5Ym94KCkge1xuICAgICAgX2NsYXNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgX2NsYXNzID0gY29uc29sZS5sb2coXCJ3b3dcIik7XG5cbiAgICByZXR1cm4gU2t5Ym94O1xuXG4gIH0pKCk7XG5cbn0pLmNhbGwodGhpcyk7XG5cbi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS41LjAtcHJlXG4iLCJcbi8qXG5cbiAgU3RhZ2VzIGlzIGFuIG9iamVjdCB0byBtYW5hZ2UsIHdlbGwsIHN0YWdlcy5cbiAgd2hpY2ggYSBzdGFnZSBpcyB0aGUgZXF1aXZhbGVudCB0byB0aGUgZ2FtZSBjb25jZXB0IG9mIGEgJ2xldmVsLidcbiAgYnV0IHNvbWVvbmUgY291bGQgdXNlIG11bHRpcGxlIHN0YWdlcyBpbiBvbmUgbGV2ZWwsIHNvIEkgZG9uJ3Qgd2FudCB0byBiZSBwdXNoeSBhbmQgY2FsbCBpdCBhICdsZXZlbCcgbWFuYWdlclxuKi9cblxuXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBDdWJlLCBJbnB1dCwgU2VsZWN0aW9uR3JpZCwgU3RhZ2UsIFN0YWdlTWFuYWdlciwgdXRpbHMsXG4gICAgX19oYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXG4gICAgX19leHRlbmRzID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChfX2hhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH07XG5cbiAgdXRpbHMgPSByZXF1aXJlKFwiLi9fdXRpbHNcIik7XG5cbiAgSW5wdXQgPSByZXF1aXJlKFwiLi9faW5wdXRcIik7XG5cbiAgQ3ViZSA9IHJlcXVpcmUoXCIuL19vYmplY3RzXCIpLkN1YmU7XG5cbiAgLypcbiAgICAgIFNlbGVjdGlvbkdyaWQgQ2xhc3NcbiAgICAgIEhlbHBlciBjbGFzcyBmb3Igc2VsZWN0aW5nIG9iamVjdHMgLyBlbnRpdGllcyBmcm9tIGEgZ3JpZFxuICAgICAgU2hvdWxkIGJlIGF1dG9tYXRpY2FsbHkgY3JlYXRlZCB3aGVuXG4gICovXG5cblxuICBTZWxlY3Rpb25HcmlkID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgZnVuY3Rpb24gU2VsZWN0aW9uR3JpZChkYXRhLCBlbmdpbmUsIHN0YWdlKSB7XG4gICAgICB2YXIgY2VudGVySW5kZXgsIGV2ZW5PZmZzZXQsIGhtLCBpc0ludCwgbywgeCwgeDAsIHksIHkwLCBfcmVmO1xuICAgICAgdGhpcy5tZXNoZXMgPSBbXTtcbiAgICAgIHRoaXMuZW5naW5lID0gZW5naW5lO1xuICAgICAgdGhpcy5zdGFnZSA9IHN0YWdlO1xuICAgICAgdGhpcy53aWR0aCA9IGRhdGEud2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IGRhdGEubGVuZ3RoO1xuICAgICAgdGhpcy5wYWRkaW5nID0gZGF0YS5wYWRkaW5nIHx8IDI7XG4gICAgICB0aGlzLnggPSBkYXRhLng7XG4gICAgICB0aGlzLnkgPSBkYXRhLnk7XG4gICAgICBpc0ludCA9IGZ1bmN0aW9uKG51bSkge1xuICAgICAgICBpZiAobnVtIC8gTWF0aC5mbG9vcihudW0pID09PSAxIHx8IG51bSAvIE1hdGguZmxvb3IobnVtKSA9PT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgICAgLyogQ29udmVydCB0aGUgZGF0YSBpbnRvIGEgbm9ybWFsaXplZCBncmlkIGRhdGFcbiAgICAgICovXG5cbiAgICAgIGV2ZW5PZmZzZXQgPSAoX3JlZiA9IGlzSW50KGRhdGEueCAvIDIpKSAhPSBudWxsID8gX3JlZiA6IHtcbiAgICAgICAgMDogMVxuICAgICAgfTtcbiAgICAgIHgwID0gfn4oZGF0YS54IC8gMik7XG4gICAgICB5MCA9IH5+KGRhdGEueSAvIDIpO1xuICAgICAgY2VudGVySW5kZXggPSBudWxsO1xuICAgICAgeCA9IC0xICogeDA7XG4gICAgICB5ID0gLTEgKiB5MDtcbiAgICAgIGhtID0gdXRpbHMuaXNBcnJheShkYXRhLmhlaWdodG1hcCkgPyBkYXRhLmhlaWdodG1hcCA6IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9pLCBfcmVmMSwgX3Jlc3VsdHM7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAobyA9IF9pID0gMCwgX3JlZjEgPSBkYXRhLnggKiBkYXRhLnk7IDAgPD0gX3JlZjEgPyBfaSA8IF9yZWYxIDogX2kgPiBfcmVmMTsgbyA9IDAgPD0gX3JlZjEgPyArK19pIDogLS1faSkge1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2gobyAtIG8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH0pKCk7XG4gICAgICBkYXRhID0gaG0ubWFwKGZ1bmN0aW9uKGVsLCBpbmRleCwgYXJyKSB7XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICBub2RlID0ge1xuICAgICAgICAgIFwielwiOiBlbCxcbiAgICAgICAgICBcInhcIjogeCxcbiAgICAgICAgICBcInlcIjogeVxuICAgICAgICB9O1xuICAgICAgICBpZiAoeCA9PT0gMCAmJiB5ID09PSAwKSB7XG4gICAgICAgICAgbm9kZS5jZW50ZXIgPSB0cnVlO1xuICAgICAgICAgIGNlbnRlckluZGV4ID0gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHggPT09ICh4MCAtIGV2ZW5PZmZzZXQpKSB7XG4gICAgICAgICAgeCA9IC0xICogeDA7XG4gICAgICAgICAgeSsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHgrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jZW50ZXJJbmRleCA9IGNlbnRlckluZGV4O1xuICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgIHRoaXMuY3JlYXRlR3JpZCgpO1xuICAgIH1cblxuICAgIFNlbGVjdGlvbkdyaWQucHJvdG90eXBlLmNyZWF0ZUdyaWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjdWJlLCBkYXR1bSwgaCwgbWF0ZXJpYWwsIHBhZGRpbmcsIHBvc2l0aW9uLCBzY2VuZSwgc2l6ZSwgdywgeCwgeSwgX2ksIF9sZW4sIF9yZWYsIF9yZXN1bHRzO1xuICAgICAgaWYgKHRoaXMuZGF0YSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMub2JqZWN0cyA9IFtdO1xuICAgICAgeCA9IDA7XG4gICAgICB5ID0gMDtcbiAgICAgIHcgPSB0aGlzLndpZHRoO1xuICAgICAgaCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgcGFkZGluZyA9IHRoaXMucGFkZGluZyB8fCAyO1xuICAgICAgX3JlZiA9IHRoaXMuZGF0YTtcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgZGF0dW0gPSBfcmVmW19pXTtcbiAgICAgICAgc2l6ZSA9IHtcbiAgICAgICAgICB4OiB3LFxuICAgICAgICAgIHk6IHcsXG4gICAgICAgICAgejogMFxuICAgICAgICB9O1xuICAgICAgICBwb3NpdGlvbiA9IHtcbiAgICAgICAgICB4OiBkYXR1bS54ICogKHcgKyBwYWRkaW5nKSxcbiAgICAgICAgICB5OiBkYXR1bS55ICogKHcgKyBwYWRkaW5nKSxcbiAgICAgICAgICB6OiBkYXR1bS56ICogKGggKyBwYWRkaW5nKVxuICAgICAgICB9O1xuICAgICAgICBtYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWw7XG4gICAgICAgIHNjZW5lID0gdGhpcy5zdGFnZS5zY2VuZTtcbiAgICAgICAgY3ViZSA9IG5ldyBDdWJlKHtcbiAgICAgICAgICBzaXplOiBzaXplLFxuICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgICAgICBtYXRlcmlhbDogbWF0ZXJpYWxcbiAgICAgICAgfSwgc2NlbmUpO1xuICAgICAgICB0aGlzLm9iamVjdHMucHVzaChjdWJlKTtcbiAgICAgICAgX3Jlc3VsdHMucHVzaCh0aGlzLnN0YWdlLm1lc2hlcy5wdXNoKGN1YmUubWVzaCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICBTZWxlY3Rpb25HcmlkLnByb3RvdHlwZS5maWx0ZXJEYXRhID0gZnVuY3Rpb24odmVjMykge1xuICAgICAgLypcbiAgICAgICAgYXJndW1lbnQgJ3ZlYzMnIGNhbiBiZSBhbiBvYmplY3Qgb3IgYSBUSFJFRS5WZWN0b3IzIGluc3RhbmNlXG4gICAgICAgICEgVmVjdG9yMyBpbnN0YW5jZXMgZG9uJ3QgYWxsb3cgeW91IHRvIGhhdmUgJ3VuZGVmaW5lZCcgYXMgYSB2YWx1ZSwgc28gdXNpbmcgJyonIGlzIHVzZWRcbiAgICAgICAgaWU6ICAgZmlsdGVyRGF0YSggbmV3IFRIUkVFLlZlY3RvcjMoMCwgXCIqXCIsIFwiKlwiKSApO1xuICAgICAgXG4gICAgICAgIFBsYWluIG9iamVjdHMgZG8gYWxsb3cgdW5kZWZpbmVkIHRob3VnaCwgc28geW91IGNhbiBwYXNzIGluIGFuIG9iamVjdCB3aXRoIGFsbCB0aGUgdmFsdWVzIHlvdSB3YW50XG4gICAgICAgIGllOiAgIGZpbHRlckRhdGEoeyB4OiAyfSk7XG4gICAgICAqL1xuICAgICAgaWYgKCF2ZWMzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmRhdGEuZmlsdGVyKGZ1bmN0aW9uKGVsLCBpLCBhcnIpIHtcbiAgICAgICAgaWYgKGVsLnggPT09IHZlYzMueCB8fCB2ZWMzLnggPT09IFwiKlwiIHx8IHZlYzMueCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgaWYgKGVsLnkgPT09IHZlYzMueSB8fCB2ZWMzLnkgPT09IFwiKlwiIHx8IHZlYzMueSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBpZiAoZWwueiA9PT0gdmVjMy56IHx8IHZlYzMueiA9PT0gXCIqXCIgfHwgdmVjMy56ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBTZWxlY3Rpb25HcmlkO1xuXG4gIH0pKCk7XG5cbiAgU3RhZ2UgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG5cbiAgICBfX2V4dGVuZHMoU3RhZ2UsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBTdGFnZShwYXJlbnQsIG5hbWUsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBiZWZvcmVMb2FkZWQsIGNhbGxiYWNrcywgY2FtZXJhLCB0aGF0O1xuICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICB0aGlzLnJlbmRlcmVyID0gcGFyZW50LnJlbmRlcmVyO1xuICAgICAgdGhpcy5uYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdGhpcy5zY2VuZSA9IG9wdGlvbnMuc2NlbmU7XG4gICAgICBjYW1lcmEgPSBvcHRpb25zLmNhbWVyYTtcbiAgICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuICAgICAgdGhpcy5tZXNoZXMgPSBbXTtcbiAgICAgIGJlZm9yZUxvYWRlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICB0aGlzLklucHV0ID0gbmV3IElucHV0LkludGVyZmFjZSh0aGlzLCBwYXJlbnQpO1xuICAgICAgICB0aGlzLk1vdXNlRGV0ZWN0b3IgPSBuZXcgSW5wdXQuTW91c2VEZXRlY3Rpb24odGhpcywgcGFyZW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXMub25sb2FkLmNhbGwodGhpcyk7XG4gICAgICB9O1xuICAgICAgdGhhdCA9IHRoaXM7XG4gICAgICB0aGF0Lm9uKFwibG9hZFwiLCBiZWZvcmVMb2FkZWQuYmluZCh0aGF0KSk7XG4gICAgICBjYWxsYmFja3MgPSB7XG4gICAgICAgIHNjb3BlOiB0aGF0LFxuICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihyZXNwb25zZVRleHQpIHtcbiAgICAgICAgICB0aGF0LmRhdGEgPSByZXNwb25zZVRleHQ7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJFbmdpbmUgOjogJ1wiICsgbmFtZSArIFwiJyBhamF4J2QuIFwiKTtcbiAgICAgICAgICB0aGF0LmRhdGEuZ3JpZCA9IHRoYXQuZ3JpZCA9IG5ldyBTZWxlY3Rpb25HcmlkKHRoYXQuZGF0YS5ncmlkLCB0aGF0LnBhcmVudCwgdGhhdCk7XG4gICAgICAgICAgcmV0dXJuIHRoYXQudHJpZ2dlcihcImxvYWRcIik7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciByZXRyaWV2aW5nIGRhdGEgZm9yIFN0YWdlXCIpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKG9wdGlvbnMudXJsICE9PSB2b2lkIDApIHtcbiAgICAgICAgdXRpbHMuZ2V0SlNPTihvcHRpb25zLnVybCwgY2FsbGJhY2tzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBTdGFnZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uKHVybFRvSnNvbikge1xuICAgICAgLypcbiAgICAgICAgaW5jYXNlIHdhc24ndCBvcmlnaW5hbGx5IHBhc3NlZCBpblxuICAgICAgKi9cblxuICAgICAgdmFyIGNhbGxiYWNrcywgdGhhdDtcbiAgICAgIHRoYXQgPSB0aGlzO1xuICAgICAgY2FsbGJhY2tzID0ge1xuICAgICAgICBzY29wZTogdGhhdCxcbiAgICAgICAgc3VjY2VzczogZnVuY3Rpb24ocmVzcG9uc2VUZXh0KSB7XG4gICAgICAgICAgdGhhdC5kYXRhID0gcmVzcG9uc2VUZXh0O1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiRW5naW5lIDo6ICdcIiArIG5hbWUgKyBcIicgYWpheCdkLiBcIik7XG4gICAgICAgICAgdGhhdC5kYXRhLmdyaWQgPSB0aGF0LmdyaWQgPSBuZXcgU2VsZWN0aW9uR3JpZCh0aGF0LmRhdGEuZ3JpZCwgdGhhdC5wYXJlbnQsIHRoYXQpO1xuICAgICAgICAgIHJldHVybiB0aGF0LnRyaWdnZXIoXCJsb2FkXCIpO1xuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgcmV0cmlldmluZyBkYXRhIGZvciBTdGFnZVwiKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmICh1cmxUb0pzb24gIT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gdXRpbHMuZ2V0SlNPTih1cmxUb0pzb24sIGNhbGxiYWNrcyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFN0YWdlLnByb3RvdHlwZS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIC8qXG4gICAgICAgIG1lYW50IHRvIGJlIG92ZXJ3cml0dGVuIGJ5IHRoZSB1c2VyXG4gICAgICAgIGFsdGVybmF0aXZlIGlzOiBcbiAgICAgICAgfCBAb24gXCJsb2FkXCIsIGZuXG4gICAgICAgIHdoaWNoIHdpbGwgYmUgdHJpZ2dlcmVkIG9uIGxvYWRpbmdcbiAgICAgICovXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgU3RhZ2UucHJvdG90eXBlLmxvb2tBdCA9IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICB0aGlzLmNhbWVyYS51cCA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDEpO1xuICAgICAgcmV0dXJuIHRoaXMuY2FtZXJhLmxvb2tBdChwb2ludCB8fCB0aGlzLnNjZW5lKTtcbiAgICB9O1xuXG4gICAgU3RhZ2UucHJvdG90eXBlLnNldENhbWVyYVRvSXNvbWV0cmljID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZGlzdGFuY2VGcm9tQ2VudGVyb2ZHcmlkVG9FZGdlLCBoLCB3LCB4LCB4RGlzdGFuY2UsIHksIHlEaXN0YW5jZSwgekRpc3RhbmNlO1xuICAgICAgaWYgKCF0aGlzLmdyaWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdyA9IHRoaXMuZ3JpZC53aWR0aDtcbiAgICAgIGggPSB0aGlzLmdyaWQuaGVpZ2h0O1xuICAgICAgeCA9IHRoaXMuZ3JpZC54O1xuICAgICAgeSA9IHRoaXMuZ3JpZC55O1xuICAgICAgZGlzdGFuY2VGcm9tQ2VudGVyb2ZHcmlkVG9FZGdlID0gdXRpbHMucHl0aGFnKHcgKiB4LCBoICogeSk7XG4gICAgICB6RGlzdGFuY2UgPSBkaXN0YW5jZUZyb21DZW50ZXJvZkdyaWRUb0VkZ2UgLyAyO1xuICAgICAgeURpc3RhbmNlID0gKHcgKyAodGhpcy5ncmlkLnBhZGRpbmcgfHwgMikpICogeDtcbiAgICAgIHhEaXN0YW5jZSA9ICh3ICsgKHRoaXMuZ3JpZC5wYWRkaW5nIHx8IDIpKSAqIHg7XG4gICAgICB0aGlzLmNhbWVyYS5wb3NpdGlvbi5zZXRaKHpEaXN0YW5jZSk7XG4gICAgICB0aGlzLmNhbWVyYS5wb3NpdGlvbi5zZXRZKHlEaXN0YW5jZSk7XG4gICAgICB0aGlzLmNhbWVyYS5wb3NpdGlvbi5zZXRYKHhEaXN0YW5jZSk7XG4gICAgICB0aGlzLmNhbWVyYS51cCA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDEpO1xuICAgICAgdGhpcy5jYW1lcmEubG9va0F0KG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDApKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgICAgLypcbiAgICAgIFxuICAgICAgXG4gICAgICBAY2FtZXJhLnJvdGF0aW9uLnogPSAwLjI1XG4gICAgICAqL1xuXG4gICAgfTtcblxuICAgIFN0YWdlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBMLCBleHRlbnQsIGdlb21ldHJ5LCBsaW5lLCBtYXRlcmlhbDtcbiAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG4gICAgICBleHRlbnQgPSA1MDAwO1xuICAgICAgZ2VvbWV0cnkudmVydGljZXMucHVzaChuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAtZXh0ZW50KSk7XG4gICAgICBnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIGV4dGVudCkpO1xuICAgICAgZ2VvbWV0cnkudmVydGljZXMucHVzaChuZXcgVEhSRUUuVmVjdG9yMygtZXh0ZW50LCAwLCAwKSk7XG4gICAgICBnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKG5ldyBUSFJFRS5WZWN0b3IzKGV4dGVudCwgMCwgMCkpO1xuICAgICAgZ2VvbWV0cnkudmVydGljZXMucHVzaChuZXcgVEhSRUUuVmVjdG9yMygwLCAtZXh0ZW50LCAwKSk7XG4gICAgICBnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKG5ldyBUSFJFRS5WZWN0b3IzKDAsIGV4dGVudCwgMCkpO1xuICAgICAgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoe1xuICAgICAgICBjb2xvcjogMHg1NTU1NTVcbiAgICAgIH0pO1xuICAgICAgbGluZSA9IG5ldyBUSFJFRS5MaW5lKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgICB0aGlzLnNjZW5lLmFkZChsaW5lKTtcbiAgICAgIHRoaXMuc2V0Q2FtZXJhVG9Jc29tZXRyaWMoKTtcbiAgICAgIHRoaXMucGFyZW50LnJlbmRlcmVyLnJlbmRlcih0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSk7XG4gICAgICBMID0gdGhpcy5wYXJlbnQuY2xvY2subG9vcChcInJlbmRlclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LnJlbmRlcmVyLnJlbmRlcih0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSk7XG4gICAgICB9LCBudWxsLCB0aGlzKTtcbiAgICAgIExbXCJmb3JcIl0oe1xuICAgICAgICBpbnRlcnZhbDogMTdcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmNsb2NrLnN0YXJ0KCk7XG4gICAgfTtcblxuICAgIFN0YWdlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQuZGVzdHJveSh0aGlzLm5hbWUpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU3RhZ2U7XG5cbiAgfSkodXRpbHMuRXZlbnRFbWl0dGVyKTtcblxuICBTdGFnZU1hbmFnZXIgPSBmdW5jdGlvbihlbmdpbmUpIHtcbiAgICAvKiBAUFJJVkFURVNcbiAgICAqL1xuXG4gICAgdmFyIGxpc3QsIHBhcmVudDtcbiAgICBwYXJlbnQgPSBlbmdpbmU7XG4gICAgLyogQFBVQkxJQ1NcbiAgICAqL1xuXG4gICAgbGlzdCA9IHt9O1xuICAgIHRoaXMubGlzdCA9IFtdO1xuICAgIHRoaXMuY3JlYXRlID0gZnVuY3Rpb24obmFtZSwgb3B0aW9ucykge1xuICAgICAgdmFyIG8sIHN0YWdlO1xuICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG8gPSBvcHRpb25zIHx8IHt9O1xuICAgICAgc3RhZ2UgPSBuZXcgU3RhZ2UocGFyZW50LCBuYW1lLCBvKTtcbiAgICAgIHRoaXMubGlzdC5wdXNoKG5hbWUpO1xuICAgICAgbGlzdFtuYW1lLnRvTG93ZXJDYXNlKCldID0gc3RhZ2U7XG4gICAgICByZXR1cm4gbGlzdFtuYW1lLnRvTG93ZXJDYXNlKCldO1xuICAgIH07XG4gICAgdGhpcy5jdXJyZW50ID0gdm9pZCAwO1xuICAgIHRoaXMuZGVzdHJveSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHJldHVybiBkZWxldGUgbGlzdFtuYW1lXTtcbiAgICB9O1xuICAgIHRoaXMubG9hZCA9IGZ1bmN0aW9uKG5hbWUsIHRyYW5zaXRpb24pIHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzID0gU3RhZ2VNYW5hZ2VyO1xuXG59KS5jYWxsKHRoaXMpO1xuXG4vLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNS4wLXByZVxuIiwiXG4vKlxuICAgICAgdXRpbGl0aWVzXG4qL1xuXG5cbihmdW5jdGlvbigpIHtcbiAgdmFyIEV2ZW50RW1pdHRlcixcbiAgICBfX3NsaWNlID0gW10uc2xpY2U7XG5cbiAgbW9kdWxlLmV4cG9ydHMubG9nID0gZnVuY3Rpb24obXNnKSB7XG4gICAgdmFyIHByZWZpeDtcbiAgICB0aGlzLmxvZ3MudW5zaGlmdChtc2cpO1xuICAgIGlmICghdGhpcy5kZWJ1Zykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwcmVmaXggPSBcIkVuZ2luZSA6OiBcIjtcbiAgICBpZiAodHlwZW9mIG1zZyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc29sZS5sb2cocHJlZml4ICsgbXNnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2cobXNnKTtcbiAgICB9XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMuZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGJhc2UsIGV4dGVuZGVkLCBrZXksIG9iaiwgb2JqcywgX2ksIF9sZW47XG4gICAgb2JqcyA9IDEgPD0gYXJndW1lbnRzLmxlbmd0aCA/IF9fc2xpY2UuY2FsbChhcmd1bWVudHMsIDApIDogW107XG4gICAgaWYgKG9ianMubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuIG9ianNbMF07XG4gICAgfVxuICAgIGV4dGVuZGVkID0gb2Jqc1swXTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IG9ianMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgIG9iaiA9IG9ianNbX2ldO1xuICAgICAgYmFzZSA9IG9iajtcbiAgICAgIGZvciAoa2V5IGluIGJhc2UpIHtcbiAgICAgICAgZXh0ZW5kZWRba2V5XSA9IGJhc2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV4dGVuZGVkO1xuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzLmlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKHRoaW5nKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0aGluZyA9PT0gXCJbb2JqZWN0IEFycmF5XVwiKTtcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cy5weXRoYWcgPSB3aW5kb3cuTWF0aC5weXRoYWcgPSBmdW5jdGlvbihBLCBCLCBoeXBvdGVudXNlKSB7XG4gICAgdmFyIGEyLCBiMiwgcmVzdWx0O1xuICAgIGlmICghKGFyZ3VtZW50cy5sZW5ndGggPj0gMikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKEIgPT09IG51bGwpIHtcbiAgICAgIHJlc3VsdCA9IChNYXRoLnBvdyhoeXBvdGVudXNlLCAyKSkgLSBNYXRoLnBvdyhBLCAyKTtcbiAgICAgIHJlc3VsdCA9IE1hdGguc3FydChyZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgYTIgPSBNYXRoLnBvdyhBLCAyKTtcbiAgICAgIGIyID0gTWF0aC5wb3coQiwgMik7XG4gICAgICByZXN1bHQgPSBNYXRoLnNxcnQoYTIgKyBiMik7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cy5nZXRKU09OID0gZnVuY3Rpb24odXJsLCBjYWxsYmFja3MpIHtcbiAgICB2YXIgYWpheCwgZGF0YSwgb3B0aW9ucztcbiAgICBvcHRpb25zID0gY2FsbGJhY2tzIHx8IHt9O1xuICAgIGRhdGEgPSB2b2lkIDA7XG4gICAgYWpheCA9ICQuZ2V0SlNPTih1cmwpO1xuICAgIHJldHVybiBhamF4LmNvbXBsZXRlKGZ1bmN0aW9uKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGF0YSA9ICQucGFyc2VKU09OKGFqYXgucmVzcG9uc2VUZXh0KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgb3B0aW9ucy5lcnJvci5jYWxsKG9wdGlvbnMuc2NvcGUgfHwgbnVsbCwgZSwgYWpheCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMuc3VjY2Vzcy5jYWxsKG9wdGlvbnMuc2NvcGUgfHwgbnVsbCwgZGF0YSwgYWpheCk7XG4gICAgfSk7XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge31cblxuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnRzID0ge307XG5cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24obmFtZSwgZm4pIHtcbiAgICAgIHRoaXMuZXZlbnRzW25hbWVdID0gZm47XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICBkZWxldGUgdGhpcy5ldmVudHNbbmFtZV07XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5ldmVudHNbbmFtZV07XG4gICAgfTtcblxuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciBmbjtcbiAgICAgIGZuID0gdGhpcy5nZXQobmFtZSk7XG4gICAgICBpZiAoZm4gPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmbi5jYWxsKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlcjtcblxuICB9KSgpO1xuXG59KS5jYWxsKHRoaXMpO1xuXG4vLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNS4wLXByZVxuIiwiKGZ1bmN0aW9uKCkge1xuXG4gIHJlcXVpcmUoXCIuL19iYXNlXCIpO1xuXG4gIHJlcXVpcmUoXCIuL21haW5cIik7XG5cbn0pLmNhbGwodGhpcyk7XG5cbi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS41LjAtcHJlXG4iLCIoZnVuY3Rpb24oKSB7XG5cblxuXG59KS5jYWxsKHRoaXMpO1xuXG4vLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNS4wLXByZVxuIl19
