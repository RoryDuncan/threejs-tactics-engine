(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

/*
    three-js Tactics Engine
*/


(function() {
  var Clock, Stage, ThreeTacticsEngine, utils;

  utils = require("./_utils");

  Stage = require("./_stage");

  Clock = require("./_clock");

  ThreeTacticsEngine = function() {
    /*
      @PRIVATES
    */

    var THREE, configLoaded, eventMethods, log, name, scene, that, _i, _len;
    if (self.THREE === void 0 || self.$ === void 0) {
      throw new Error("The engine is dependent on THREE.js and jQuery, which one of was not found, or not in the global scope.");
    }
    THREE = self.THREE;
    configLoaded = false;
    scene = false;
    that = this;
    this.debug = true;
    this.logs = [];
    log = (function(msg) {
      return utils.log.call(this, msg, this.logs);
    }).bind(this);
    this.log = log;
    /*
      @PUBLICS
    */

    this.load = function() {};
    this.renderQueue = [];
    this.stage = new Stage(this);
    this.clock = new Clock();
    /* 
      Dynamically add event methods from the clock object (which has an event emitter built into it.)
      this array is the names of the methods that will be added to the events object
    */

    eventMethods = ["on", "off", "defer", "getEvents", "trigger", "remove"];
    this.events = {};
    for (_i = 0, _len = eventMethods.length; _i < _len; _i++) {
      name = eventMethods[_i];
      this.events[name] = this.clock[name];
    }
    this.init = function(options) {
      var config;
      config = $.getJSON((options || {}).config);
      if (typeof config === void 0) {
        return;
      }
      that = this;
      return config.complete(function() {
        var renderer;
        try {
          that.config = $.parseJSON(config.responseText);
        } catch (e) {
          log(e);
          throw new Error("JSON was not parsed.");
        }
        configLoaded = true;
        log("Configuration Loaded.");
        renderer = new THREE.WebGLRenderer({
          antialias: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        that.renderer = renderer;
        log("Initialized.");
        if ((options || {}).autostart === true) {
          return that.start();
        }
      });
    };
    this.start = function() {
      var stage;
      if (!configLoaded) {
        return;
      }
      return stage = this.stage.create("test", {
        "url": "json/test.json",
        "camera": new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100000),
        "scene": new THREE.Scene()
      });
    };
    return this;
  };

  self.Engine = new ThreeTacticsEngine();

  Engine.init({
    "config": "json/config.json",
    "autostart": true
  });

  console.log(Engine);

}).call(this);

// Generated by CoffeeScript 1.5.0-pre

},{"./_clock":2,"./_stage":5,"./_utils":6}],2:[function(require,module,exports){

  /*
    Modified version from

    +-+- GITHUB -+-+
  unmodified version located at:
    https://github.com/RoryDuncan/ClockEventAggreggator
    
    +-+- DOCUMENTATION -+-+
    http://roryduncan.github.io/ClockEventAggreggator/

  */

var utils = require("./_utils");

var Clock = function(args) {

  /* Helpers */

  // Helper for merging objects
  extend = utils.extend;

  var isArray = function(thing){
    // assume 'thing' is not undefined or null as it will throw a TypeError.
    if (typeof thing === "string") return false;
    if ( (thing).length === undefined) return false;
    else return true; 
  }


  /*  Timeline related variables  */

  var defaults = {useRAF: true, tickInterval: 16, autostart: false},
      options = extend(defaults, args),
      ticks = 0,
      lastTick = 0,
      startTime = 0,

      // the 'clock' time, calculated with delta and clockSpeed variables.
      elapsedTime = 0,

      // id for requestAnimationFrame
      rAFID = null,

      // whether this is every other tick
      tick_n = false,

      // the amount of real-time that has passed between ticks
      delta = 0,
      actualElapsedTime = 0;

      // fallback time for setTimeout
      this.tickInterval = options.tickInterval,

      running = false,

      // speed at which the clock runs
      clockspeed = 1,

      // reference
      self = this,

      // wether or not to use request Animation Frame
      useRAF = options.useRAF,

      // dynamic function for rAF or setTimeout functionality,
      tickCallee = function() {
        // set to start() initially in case called before start somehow.
        this.start();
      };

      
      


  /*  Event Aggregator related variables  */

  var events = {};
      events.nominal = {};
      events.ordinal = {};
      events.loops = {};

  
  /*  Internal Functions */

  //  clock's tick mechanism
  var tick = function() {
    
    var now = new Date().getTime(); //cache
    if (!running) return;
    
    ticks += 1 * clockspeed;
    tick_n = !tick_n;
    if (this.debug && tick_n) this.log();

    
    this.delta = delta = (now - lastTick) * clockspeed;

    lastTick = now;

    elapsedTime += delta;

    actualElapsedTime = ( now - startTime );

    this.errorMargin = actualElapsedTime - elapsedTime; 


    // singular events take precedence over loop events.
    triggerCurrentEvents();
    triggerLoopEvents();

    this.trigger("tick");

    
    rAFID = tickCallee();

    return ticks;
  };
  
  var buildDefaultEvents = function() {

    var defaultEvents = ["tick", "start", "after:start", "pause", "resume"],
        addEvent = function(name){

          events.ordinal[name] = [];
        };

    defaultEvents.forEach(addEvent);

  };
  buildDefaultEvents();

  var triggerOrdinalEvents = function() {

    var now = ~~(elapsedTime / 100) * 100;

    if ( events.ordinal[ now ] === undefined ) {return false;}  // return false in case of checks

    
    var eot = events.ordinal[ now ];

    // events.ordinal will be an array, so loop over each function in it.
    for (var _x = 0, _xx = eot.length; _x < _xx; _x++) {

      var fn = eot[_x].fn,
          ctx = eot[_x].context,
          args = eot[_x].args;

      fn.apply(ctx, args);
    }

    // delete it, so that it won't trigger the next ticks that round down to this time.
    delete events.ordinal[ now ];

    return true; // return true in case of checks
  };

  var triggerLoopEvents = function() {

    var now = ~~elapsedTime;

    var expired = [];

    for (var key in events.loops) {

      var loop = events.loops[ key ]

      if (loop.start <= now &&          // Check if it is 'allowed' to start.
          loop.checkInterval( now ) &&  // Check whether the loop should fire at the current time
          loop.delete === false ) {      // Check if it is to be deleted
          
          // there is a reference to _this_ inside of loop,
          // so sending the loop itself as context is enough.
          loop.calledAt.push( now );
          loop.now = now;
          
          loop.fn.apply( loop.scope, loop.args );
          
          loop.lastCall = now;
          loop.calls++;
      }
      // check whether it has expired
      if (loop.stop === now || loop.calls === loop.maxIntervals || loop.delete === true) {
        // put it in the box where bad loops go.
        expired.push( key );
      }
    }

    // Delete any loops marked
    for (var i = 0, ii = expired.length; i < ii; i++) {
      var name = expired[i];
      delete events.loops[name];
    }
  };


  /*  Bindings  */

  this.tick = tick.bind(this);
  var triggerLoopEvents = triggerLoopEvents.bind(this);
  var  triggerCurrentEvents = triggerOrdinalEvents.bind(this);
  


  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
  /* * * * * * * * * * * * *   API   * * * * * * * * * * * * */
  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


  /*  Clock-related methods  */

  this.start = function() {

    if (running === true) { return this; } // simple tests to prevent multiple starts

    // tickLoop is a dynamically constructed function to remove an 'if' statement inside of tick() .
    var tickLoop;  

    if (useRAF === true) {
      tickLoop = new Function(" var id = window.requestAnimationFrame( this.tick ); return id;");
    }
    else {
      tickLoop = new Function(" var id = window.setTimeout(this.tick, this.tickInterval);return id;" );
    }
    // bind into this context
    tickCallee = tickLoop.bind(this);

    this.trigger("before:start");

    var now = new Date().getTime();
    this.startTime = startTime = now;
    running = true;
    lastTick = now;
    this.tick();

    this.enablePauseOnBlur();
    this.trigger("start");

    return this;
  }.bind(this);

  this.stop = function(){

    running = false;
    //reset event lists
    events.nominal = {};
    events.ordinal = [];
    events.loops = {};

    buildDefaultEvents();

    //reset counters
    ticks = 0;
    elapsedTime = 0;
    this.startTime = startTime = 0;

    return this;
  }.bind(this);

  this.reset = function(){

    this.reset();
    this.start();
    return this;
  }.bind(this);

  this.pause = function() {
    running = false;
    this.trigger("pause");
    return this;
  }.bind(this);

  this.resume = function() {
    if (running === true) return this;
    running = true;
    lastTick = new Date().getTime();
    this.tick();
    this.trigger("resume");
    return this;
  }.bind(this);

  this.clockScalar = function(multiplier) {
    // a relative way to affect the clock
    clockspeed *= multiplier || 1;
  };

  this.setClockSpeed = function(value) {
    // for manually entering a speed value
    clockspeed = value || clockspeed;
  };

  this.enablePauseOnBlur = function() {
    // called on start
    // requestAnimationFrame natively pauses onblur, but, this clock doesn't
    // so I've programmed the functionality into it. 

    window.onblur = function(){self.pause();}
    window.onfocus = function(){self.resume();};
  };

  this.disablePauseOnBlur = function(){
    window.onblur = function(){return null};
    window.onfocus = function(){return null};
  };
  
  this.ticks = function(){ return ticks; };

  this.milliseconds = function(){ return elapsedTime;};

  this.seconds = function(){ return elapsedTime / 1000 ; };

  this.minutes = function(){ return (this.seconds() / 60); };

  this.debug = options.debug || false;

  // if debug is true, log is automatically called each tick
  this.log = function() {

    console.clear();
    if (useRAF) console.log("<Using requestAnimationFrame>");
    else console.log("<Using setTimeout>");
    console.log("ticks:", ticks);
    console.log("delta:", delta);
    console.log("lastTick(should change)", ~~lastTick)
    console.log("elapsed time:", elapsedTime / 1000);
    console.log("elapsed seconds:", ~~(elapsedTime / 1000));
    console.log("actual elapsed time:", actualElapsedTime / 1000);
    console.warn("%cdifference (in seconds): " + (this.errorMargin / 1000), "color: #a00" );
    console.log("Ignore differences if you have called pause at any time.");
    console.log("Estimated FPS:", ~~(ticks / ( elapsedTime / 1000 )));
  };

  this.time = this.now = function(){ return elapsedTime; };



  /*  Event-related methods  */
  
  this.trigger = function(eventName) {

    if (events.nominal[eventName] === undefined) return this;

    var l = events.nominal[eventName].length

    for (var _x = 0, _xx = l; _x < _xx; _x++) {

      // wow, much length, many chars, such scary.
      var fn = events.nominal[eventName][_x].fn,
          ctx = events.nominal[eventName][_x].context,
          args = events.nominal[eventName][_x].args;

      fn.apply(ctx, args);

    }
    return this;
  };

  this.on = function( eventName, fn /* [, args, context ] */ ) {

    var context = arguments[3] || this, args = arguments[2] || [];

    // create an array for the event
    events.nominal[eventName] = events.nominal[eventName] || []

    var scope = this; // all events default to the scope of the Timeline object.

    events.nominal[eventName].push({
      'fn': fn,
      'args': args,
      'context': context
    });
    return this;
  };

  this.at = function( elapsedMS, fn /* [, args, context ] */ ) {
    if (elapsedMS === undefined) {throw new Error("at() method requires a clock-time passed in as first parameter."); return;}
    if (fn === undefined) {throw new Error("at() method requires a function passed in as second parameter."); return;}

    var context = arguments[3] || null, args = arguments[2] || this;

    var addTime = function( time ) {

      var t = time.toString();
      events.ordinal[ time ] = events.ordinal[ time ] || [];
      events.ordinal[ time ].push({
        "fn": fn,
        "context": context,
        "args": args
      });

    };

    if ( !isArray(elapsedMS) ) {
      addTime( elapsedMS );
      
      return this;

    }

      elapsedMS.forEach( addTime );


      return this;
  };

  this.after = function( milliseconds, fn /* [, args, context ] */ ) {
    var args = arguments[2], context = arguments[3];
    this.at( elapsedTime + milliseconds, fn, args, context );
  };

  this.loop = function( uniqueName, fn, args, scope ) {

    /*
        this.loop() returns a new loop object, which to alter timing-related options
        you call it's .for() method. 
        
        EX:
        var x = this.loop(*args).for(*args);
    */

    if (!uniqueName) return this;

    var self = this,
        defaults = {
          "autostart": true,
          "start": ~~elapsedTime,
          "stop": Infinity, 
          "interval": Infinity, 
          "maxIntervals": Infinity, 
          "duration": 0, 
          "calledAt": [],
          "startDelay": 0
        },
        required = {
          "name":uniqueName,
          "fn": fn,
          "scope": scope || self,
          "calls": 0,
          "parent": self,
          "args": args || []
        };

    // the loop object that will be returned
    var Loop = function(options) {


      extend(this, defaults, required);

      // the check to determine if the loop is called
      this.checkInterval = function(now) {
        var start = this.start,
            interval = this.interval,
            duration = this.duration,
            doesIntervalMatchNow = (now - (start + this.startDelay))  % (interval + duration),
            intervalHasPassed = now - (this.lastCall === undefined ? start : this.lastCall);
  
        /*
        console.clear();
        console.log("name:", this.name);
        console.log("Delta:", self.delta );
        console.log("-----");
        console.log("start:", start);
        console.log("doesIntervalMatchNow", doesIntervalMatchNow);
        console.log("interval:", interval);
        console.log("now:", now);
        console.log("lastCall'ed:", this.lastCall);
        */
        
        if ( doesIntervalMatchNow >= 0 && doesIntervalMatchNow <= delta && (now - this.lastCall) > (interval*0.99) ) return true;
        else return false;
      };

      this.for = function(options) {
        extend(this, options);
        this.lastCall = this.start - this.interval;
        return this;
      };

      this.delete = false;
      return this;
    };
    var l = new Loop();

    events.loops[ l.name ] = l;

    return l;
  };

  this.remove =  this.off = function(event) {

    if (typeof event === "number") {

      if (events.ordinal[event] === undefined) return {"removed":false, "ctx": this};

      delete events.ordinal[event];
      return {"removed":true, "ctx": this};
    }

    if (typeof event === "string") {

      // if it is a event set with on():
      if (events.nominal[eventName] === undefined) {

        //if it is a loop event 
        if (events.loops[eventName] === undefined) return {"removed":false, "ctx": this};

        // loops terminate themselves automatically when set to delete
        events.loops[eventName].delete = true;
        return {"removed":true, "ctx": this};
      }

      delete events.nominal[eventName];
      return {"removed":true, "ctx": this};
    } 
  };

  this.defer = function(fn){
    // waits for the current stack to clear
    window.setTimeout(0, fn)
  };

  this.getEvents = function() {
    // in case someone wants to view the internally set events
    return events;
  };

  /* * * * * * * * * * * * * *

    bindToFunction:

    Attach 'wait' method to the Function.prototype,
    delegating to the timeline's <this>.after() method.
    Useful? Could be. Invasive of global prototypes? Def.

  * * * * * * * * * * * * * */
  
  if (options.bindToFunction === true) {

      var _t = this; // reference, since wait is in the context of the callee

      var wait = function(seconds, args, context) {
        _t.after(seconds, this, args, context); 
      };
      
      Function.prototype.wait = wait;
  }

  if (options.autostart === true) this.start();
  else return this;
};
   

module.exports = Clock;

},{"./_utils":6}],3:[function(require,module,exports){

/*
# @InputInterface
#
*/


(function() {
  var utils;

  utils = require("./_utils");

  module.exports.Interface = function(canvas, parent, engine) {
    var $el, bound, handler, key, mousemoveHandler, scope;
    if (!$) {
      return;
    }
    if (arguments.length === 3) {
      $el = $(canvas);
      this.parent = parent;
      this.engine = engine;
      scope = engine;
    } else {
      $el = $(parent.renderer.domElement);
      this.parent = canvas;
      this.engine = parent;
      scope = parent;
    }
    key = {
      "leftClick": 1,
      "scrollwheel": 2,
      "rightClick": 3,
      'backspace': 8,
      'tab': 9,
      'enter': 13,
      'shift': 16,
      'ctrl': 17,
      'alt': 18,
      'pause': 19,
      'capslock': 20,
      'esc': 27,
      'pageup': 33,
      'pagedown': 34,
      'end': 35,
      'home': 36,
      'left': 37,
      'up': 38,
      'right': 39,
      'down': 40,
      'insert': 45,
      'delete': 46,
      '0': 48,
      '1': 49,
      '2': 50,
      '3': 51,
      '4': 52,
      '5': 53,
      '6': 54,
      '7': 55,
      '8': 56,
      '9': 57,
      'a': 65,
      'b': 66,
      'c': 67,
      'd': 68,
      'e': 69,
      'f': 70,
      'g': 71,
      'h': 72,
      'i': 73,
      'j': 74,
      'k': 75,
      'l': 76,
      'm': 77,
      'n': 78,
      'o': 79,
      'p': 80,
      'q': 81,
      'r': 82,
      's': 83,
      't': 84,
      'u': 85,
      'v': 86,
      'w': 87,
      'x': 88,
      'y': 89,
      'z': 90,
      'numpad0': 96,
      'numpad1': 97,
      'numpad2': 98,
      'numpad3': 99,
      'numpad4': 100,
      'numpad5': 101,
      'numpad6': 102,
      'numpad7': 103,
      'numpad8': 104,
      'numpad9': 105,
      'multiply': 106,
      'plus': 107,
      'minut': 109,
      'dot': 110,
      'slash1': 111,
      'F1': 112,
      'F2': 113,
      'F3': 114,
      'F4': 115,
      'F5': 116,
      'F6': 117,
      'F7': 118,
      'F8': 119,
      'F9': 120,
      'F10': 121,
      'F11': 122,
      'F12': 123,
      'equal': 187,
      'coma': 188,
      'slash': 191,
      'backslash': 220
    };
    bound = {};
    handler = function(e) {
      var b, keyname;
      e.preventDefault();
      e.position = utils.getMousePosition(e);
      b = bound[e.type];
      if (!b) {
        return;
      }
      for (keyname in b) {
        if (key[keyname] === e.which) {
          b[keyname].callback.call(b[keyname], e, b[keyname].data);
          return;
        }
      }
    };
    mousemoveHandler = function(e) {
      var b, data;
      e.preventDefault();
      e.position = utils.getMousePosition(e);
      b = bound["mousemove"];
      data = b.data || {};
      b.callback.call(parent, e, data);
    };
    this.bind = this.on = function(events, keyname, callback, data) {
      var b, eventType, _events, _i, _len;
      if (!(arguments.length >= 2)) {
        return;
      }
      _events = events.split(" ");
      if (_events[0] === "mousemove") {
        bound["mousemove"] = {
          "callback": keyname,
          "data": callback
        };
        $el.on("mousemove", mousemoveHandler);
      }
      for (_i = 0, _len = _events.length; _i < _len; _i++) {
        eventType = _events[_i];
        b = bound[eventType] = bound[eventType] || {};
        b[keyname] = {
          callback: callback,
          data: data
        };
        $el.on(eventType, handler);
      }
      return this;
    };
    this.unbind = this.off = function(events, keyname) {
      var eventType, _events, _i, _len;
      _events = events.split(" ");
      for (_i = 0, _len = _events.length; _i < _len; _i++) {
        eventType = _events[_i];
        $el.off(eventType, handler);
        delete bound[eventType][keyname];
      }
      return this;
    };
    this.trigger = function(event) {
      $el.trigger(event);
      return bound[event];
    };
    return this;
  };

  module.exports.MouseDetection = function(parent, engine, multiselect, clearAfterEmptySelection) {
    var camera, clickHandler, enabled, handler, input, lastClickIntersect, lastHoverIntersect, mousemoveHandler, projector, selectedObjects, stage, that;
    if (multiselect == null) {
      multiselect = false;
    }
    if (clearAfterEmptySelection == null) {
      clearAfterEmptySelection = false;
    }
    enabled = false;
    stage = parent;
    input = parent.Input;
    camera = parent.camera;
    projector = new THREE.Projector();
    this.intersections = null;
    lastHoverIntersect = null;
    lastClickIntersect = null;
    selectedObjects = [];
    that = this;
    this.mousemove = true;
    this.click = true;
    this.multiselect = multiselect;
    this.clearAfterEmptySelection = clearAfterEmptySelection;
    this.getIntersections = function(mouse, camera) {
      var direction, intersections, raycaster, vector;
      vector = new THREE.Vector3(mouse.normalized.x, mouse.normalized.y, 1);
      projector.unprojectVector(vector, camera);
      direction = vector.sub(camera.position).normalize();
      raycaster = new THREE.Raycaster(camera.position, direction);
      intersections = raycaster.intersectObjects(stage.meshes);
      return intersections;
    };
    handler = function(e, camera) {
      var intersections, mouse;
      mouse = e.position;
      intersections = that.getIntersections(mouse, camera);
      if (e.type === "mousemove") {
        if (that.mousemove !== true) {
          return;
        }
        mousemoveHandler(intersections, mouse, camera, e);
      } else if (e.type === "click") {
        if (that.click !== true) {
          return;
        }
        clickHandler(intersections, mouse, camera, e);
      }
      return e;
    };
    mousemoveHandler = function(intersections, mouse, camera, e) {
      var intersect;
      if (intersections.length === 0) {
        if (lastHoverIntersect === null) {
          return;
        }
        lastHoverIntersect.dispatchEvent({
          type: "leave"
        });
        lastHoverIntersect = null;
        return;
      }
      intersect = intersections[0].object;
      intersect.dispatchEvent({
        type: "hover"
      });
      if (lastHoverIntersect === null) {
        return lastHoverIntersect = intersect;
      } else if (lastHoverIntersect !== intersect) {
        lastHoverIntersect.dispatchEvent({
          type: "leave"
        });
        return lastHoverIntersect = intersect;
      }
    };
    clickHandler = function(intersections, mouse, camera, e) {
      /* deal with things that weren't selected
      */

      var intersect;
      if (intersections.length === 0) {
        if (lastClickIntersect === null) {
          return;
        }
        if (that.clearAfterEmptySelection === false) {
          return;
        }
        that.clear();
        return;
      }
      intersect = intersections[0].object;
      intersect.dispatchEvent({
        type: "click"
      });
      if (lastClickIntersect === null) {
        lastClickIntersect = intersect;
        selectedObjects.push(intersect);
      } else if (lastClickIntersect !== intersect) {
        if (that.multiselect === false) {
          lastClickIntersect.dispatchEvent({
            type: "clear"
          });
        }
        lastClickIntersect = intersect;
        selectedObjects.push(intersect);
      }
    };
    this.clear = function() {
      selectedObjects.forEach(function(el) {
        return el.dispatchEvent({
          type: "clear"
        });
      });
      selectedObjects = [];
      return this;
    };
    this.toggle = function() {
      if (enabled) {
        return this.disable();
      } else {
        return this.enable();
      }
    };
    this.off = function() {
      if (enabled) {
        enabled = false;
        input.off("mousemove", handler, camera);
        input.off("click", handler, camera);
      }
    };
    this.on = function() {
      if (!enabled) {
        enabled = true;
        input.on("mousemove", handler, camera);
        input.on("click", "leftClick", handler, camera);
      }
    };
    this.on();
    return this;
  };

}).call(this);

// Generated by CoffeeScript 1.5.0-pre

},{"./_utils":6}],4:[function(require,module,exports){
(function() {
  var BackgroundPlane, LowPolyTerrain, Selector, utils,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  utils = require("./_utils");

  module.exports.Selector = Selector = (function(_super) {

    __extends(Selector, _super);

    function Selector(options, scene) {
      var number, that;
      this.scene = scene;
      if (!(options.size && options.position)) {
        return;
      }
      if (typeof options.size === "number") {
        number = options.size;
      }
      this.parent = options.parent;
      this.position = new THREE.Vector3(options.position.x, options.position.y, options.position.z);
      this.geometry = new THREE.BoxGeometry(options.size.x, options.size.y, options.size.z);
      this.isSelected = false;
      this.disableHover = false;
      /*
      
        eventMaterials is a hash of the different states, named based on the event triggered
      */

      this.currentState = "default";
      this.mesh = new THREE.Mesh(this.geometry, this.eventMaterials["default"]);
      this.mesh.position = this.position;
      this.mesh.wrapper = this;
      that = this;
      this.mesh.addEventListener("hover", that._hover);
      this.mesh.addEventListener("leave", that._leave);
      this.mesh.addEventListener("click", that._click);
      this.mesh.addEventListener("clear", that._clear);
      if (this.scene !== void 0) {
        this.addToScene(this.scene);
      }
    }

    Selector.prototype.eventMaterials = {
      "default": new THREE.MeshBasicMaterial({
        opacity: 1,
        transparent: true,
        color: 0x444455,
        wireframe: false
      }),
      "hover": new THREE.MeshBasicMaterial({
        opacity: 0.45,
        transparent: true
      }),
      "click": new THREE.MeshBasicMaterial({
        color: 0xcccccc
      }),
      "leave": new THREE.MeshBasicMaterial({
        color: 0x00cc99
      }),
      "range": new THREE.MeshBasicMaterial({
        color: 0x0033aa
      }),
      "range-hover": new THREE.MeshBasicMaterial({
        color: 0xaa4444
      })
    };

    Selector.prototype.addToScene = function(scene) {
      this.scene = scene;
      return scene.add(this.mesh);
    };

    /*  The method to propogate events upwards to the SelectionGrid
    */


    Selector.prototype.callSuperEvent = function(name, args) {
      return this.parent.trigger(name, args);
    };

    /* use changeMaterialState to change the material appearance
    */


    Selector.prototype.changeMaterialState = function(name, disableHover) {
      if (disableHover == null) {
        disableHover = false;
      }
      this.mesh.disableHover = disableHover;
      this.mesh.isSelected = false;
      this.currentState = name;
      return this.mesh.material = this.eventMaterials[name] || this.eventMaterials["default"];
    };

    Selector.prototype.resetMaterial = function() {
      this.disableHover = false;
      return this.changeMaterialState("default");
    };

    /* specific event responses
    */


    Selector.prototype._hover = function(e) {
      if (this.wrapper.currentState === "range") {
        this.material = this.wrapper.eventMaterials["range-hover"];
      }
      if (this.disableHover) {
        return;
      }
      this.wrapper.trigger(e.type);
      this.wrapper.callSuperEvent.call(this.wrapper, e.type, [this.wrapper]);
      if (this.isSelected === true) {
        return;
      }
      this.material = this.wrapper.eventMaterials.hover;
      return this.wrapper.currentState = e.type;
    };

    Selector.prototype._leave = function(e) {
      this.wrapper.trigger(e.type);
      this.wrapper.callSuperEvent.call(this.wrapper, e.type, [this.wrapper]);
      if (this.wrapper.currentState === "range") {
        this.material = this.wrapper.eventMaterials["range"];
      }
      if (this.isSelected || this.disableHover || this.wrapper.currentState === "range") {

      } else {
        this.material = this.wrapper.eventMaterials["default"];
        return this.wrapper.currentState = e.type;
      }
    };

    Selector.prototype._click = function(e) {
      this.wrapper.trigger(e.type);
      this.wrapper.callSuperEvent.call(this.wrapper, e.type, [this.wrapper]);
      this.isSelected = !this.isSelected;
      if (this.isSelected) {
        this.material = this.wrapper.eventMaterials.click;
        return this.wrapper.currentState = e.type;
      } else {
        this.material = this.wrapper.eventMaterials.hover;
        return this.wrapper.currentState = "hover";
      }
    };

    Selector.prototype._clear = function(e) {
      this.wrapper.trigger(e.type);
      this.wrapper.callSuperEvent.call(this.wrapper, e.type, [this.wrapper]);
      if (this.wrapper.currentState = "range") {
        return;
      } else {
        this.material = this.wrapper.eventMaterials["default"];
        this.wrapper.currentState = "default";
      }
      return this.isSelected = false;
    };

    return Selector;

  })(utils.EventEmitter);

  module.exports.Skybox = BackgroundPlane = (function() {

    function BackgroundPlane() {
      console.log("wow");
    }

    return BackgroundPlane;

  })();

  module.exports.LowPolyTerrain = LowPolyTerrain = (function() {

    function LowPolyTerrain() {
      console.log("wow");
    }

    return LowPolyTerrain;

  })();

}).call(this);

// Generated by CoffeeScript 1.5.0-pre

},{"./_utils":6}],5:[function(require,module,exports){

/*

  Stages is an object to manage, well, stages.
  which a stage is the equivalent to the game concept of a 'level.'
  but someone could use multiple stages in one level, so I don't want to be pushy and call it a 'level' manager
*/


(function() {
  var Input, SelectionGrid, Selector, Stage, StageManager, utils,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  utils = require("./_utils");

  Input = require("./_input");

  Selector = require("./_objects").Selector;

  /*
      SelectionGrid Class
      Helper class for selecting objects / entities from a grid
      Should be automatically created when
  */


  SelectionGrid = (function(_super) {

    __extends(SelectionGrid, _super);

    function SelectionGrid(data, engine, stage) {
      var centerIndex, evenOffset, hm, o, x, x0, z, z0, _ref;
      this.engine = engine;
      this.stage = stage;
      this.width = data.width;
      this.height = data.length;
      this.padding = data.padding || 2;
      this.x = data.x;
      this.z = data.z;
      this.on("click", function(selector) {
        return this.displayRange(selector, 5);
      }, this);
      /* Convert the data into a normalized grid data
      */

      evenOffset = (_ref = utils.isInt(data.x / 2)) != null ? _ref : {
        0: 1
      };
      x0 = ~~(data.x / 2);
      z0 = ~~(data.z / 2);
      centerIndex = null;
      x = -1 * x0;
      z = -1 * z0;
      hm = utils.isArray(data.heightmap) ? data.heightmap : (function() {
        var _i, _ref1, _results;
        _results = [];
        for (o = _i = 1, _ref1 = data.x * data.z; 1 <= _ref1 ? _i <= _ref1 : _i >= _ref1; o = 1 <= _ref1 ? ++_i : --_i) {
          _results.push(data.heightmap);
        }
        return _results;
      })();
      data = hm.map(function(el, index, arr) {
        var node;
        node = {
          "z": z,
          "x": x,
          "y": el,
          "id": index
        };
        if (x === 0 && z === 0) {
          node.center = true;
          centerIndex = index;
        }
        if (x === (x0 - evenOffset)) {
          x = -1 * x0;
          z += 1;
        } else {
          x++;
        }
        return node;
      });
      this.centerIndex = centerIndex;
      this.data = data;
      this.createGrid();
    }

    SelectionGrid.prototype.createGrid = function(showHelper) {
      var datum, h, material, padding, parent, position, scene, selector, size, w, _i, _len, _ref;
      if (showHelper == null) {
        showHelper = true;
      }
      if (this.data === void 0) {
        return;
      }
      this.selectors = [];
      w = this.width;
      h = this.height;
      padding = this.padding || 2;
      parent = this;
      _ref = this.data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        datum = _ref[_i];
        size = {
          x: w,
          y: 0,
          z: w
        };
        position = {
          x: datum.x * (w + padding),
          y: datum.y * (h + padding),
          z: datum.z * (w + padding)
        };
        material = this.material;
        scene = this.stage.scene;
        selector = new Selector({
          parent: parent,
          size: size,
          position: position,
          material: material
        }, scene);
        datum.selector = selector;
        selector.datum = datum;
        this.selectors.push(selector);
        this.stage.meshes.push(selector.mesh);
      }
      return this.helper.grid.call(this, showHelper);
    };

    SelectionGrid.prototype.filterData = function(vec3) {
      /*
        argument 'vec3' can be an object or a THREE.Vector3 instance
        ! Vector3 instances don't allow you to have 'undefined' as a value, so using '*' is used
        ie:   filterData( new THREE.Vector3(0, "*", "*") );
      
        Plain objects do allow undefined though, so you can pass in an object with all the values you want
        ie:   filterData({ x: 2});
      */

      var results;
      if (!vec3) {
        return;
      }
      results = [];
      results = results.concat(this.data.filter(function(el, i, arr) {
        if (el.x === vec3.x || vec3.x === "*" || vec3.x === void 0) {
          if (el.y === vec3.y || vec3.y === "*" || vec3.y === void 0) {
            if (el.z === vec3.z || vec3.z === "*" || vec3.z === void 0) {
              return el;
            }
          }
        }
      }));
      return results;
    };

    SelectionGrid.prototype.getRange = function(vec3, steps) {
      var count, getStepCount, results, x, _i, _len, _ref;
      if (steps == null) {
        steps = 4;
      }
      getStepCount = utils.steps;
      results = [];
      _ref = this.data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        x = _ref[_i];
        count = getStepCount(vec3, x);
        if (count < steps + 1) {
          results.push(x);
        }
      }
      return results;
    };

    SelectionGrid.prototype.getRangeFromSelector = function(selector, steps) {
      if (!(selector instanceof Selector)) {
        return;
      }
      return this.getRange(selector.datum, steps);
    };

    SelectionGrid.prototype.displayRange = function(selector, steps, clearOtherRanges) {
      var selectors;
      if (clearOtherRanges == null) {
        clearOtherRanges = true;
      }
      if (!(selector instanceof Selector)) {
        return;
      }
      if (clearOtherRanges) {
        this.clearAllRanges();
      }
      selectors = this.getRangeFromSelector(selector, steps);
      return selectors.forEach(function(el) {
        return el.selector.changeMaterialState.call(el.selector, "range", true);
      });
    };

    SelectionGrid.prototype.clearAllRanges = function() {
      var type;
      type = "default";
      return this.selectors.forEach(function(el) {
        return el.resetMaterial.call(el, type);
      });
    };

    SelectionGrid.prototype.helper = {
      grid: function(remove) {
        var grid, height, padding, size, step, width;
        if (remove == null) {
          remove = false;
        }
        console.log(this);
        padding = this.padding;
        width = this.width;
        height = this.height;
        size = ((width + padding) * this.x) / 2;
        step = (width + height + (padding * 2)) / 2;
        grid = new THREE.GridHelper(size, step);
        this._helpergrid = grid;
        grid.setColors("#224", "#224");
        this.stage.scene.add(grid);
        return grid;
      },
      range: function() {}
    };

    return SelectionGrid;

  })(utils.EventEmitter);

  Stage = (function(_super) {

    __extends(Stage, _super);

    function Stage(parent, name, options) {
      var beforeLoaded, callbacks, camera, that;
      this.parent = parent;
      this.renderer = parent.renderer;
      this.name = name.toLowerCase();
      this.scene = options.scene;
      camera = options.camera;
      this.camera = camera;
      this.meshes = [];
      beforeLoaded = function() {
        this.render();
        this.Input = new Input.Interface(this, parent);
        this.MouseDetector = new Input.MouseDetection(this, parent);
        return this.onload.call(this);
      };
      that = this;
      that.on("load", beforeLoaded.bind(that));
      callbacks = {
        scope: that,
        success: function(responseText) {
          that.data = responseText;
          console.log("Engine :: '" + name + "' ajax'd. ");
          that.data.grid = that.grid = new SelectionGrid(that.data.grid, that.parent, that);
          return that.trigger("load");
        },
        error: function() {
          throw new Error("Error retrieving data for Stage");
        }
      };
      if (options.url !== void 0) {
        utils.getJSON(options.url, callbacks);
      }
    }

    Stage.prototype.load = function(urlToJson) {
      /*
        incase wasn't originally passed in
      */

      var callbacks, that;
      that = this;
      callbacks = {
        scope: that,
        success: function(responseText) {
          that.data = responseText;
          console.log("Engine :: '" + name + "' ajax'd. ");
          that.data.grid = that.grid = new SelectionGrid(that.data.grid, that.parent, that);
          return that.trigger("load");
        },
        error: function() {
          throw new Error("Error retrieving data for Stage");
        }
      };
      if (urlToJson !== void 0) {
        return utils.getJSON(urlToJson, callbacks);
      }
    };

    Stage.prototype.onload = function() {
      /*
        meant to be overwritten by the user
        alternative is: 
        | @on "load", fn
        which will be triggered on loading
      */
      return this;
    };

    Stage.prototype.lookAt = function(point) {
      this.camera.up = new THREE.Vector3(0, 0, 1);
      return this.camera.lookAt(point || this.scene);
    };

    Stage.prototype.setCameraToIsometric = function() {
      var distanceFromCenterofGridToEdge, h, w, x, xDistance, yDistance, z, zDistance;
      if (!this.grid) {
        return;
      }
      w = this.grid.width;
      h = this.grid.height;
      x = this.grid.x;
      z = this.grid.z;
      distanceFromCenterofGridToEdge = utils.pythag(w * x, h * z);
      yDistance = distanceFromCenterofGridToEdge / 2;
      zDistance = (w + (this.grid.padding || 2)) * z;
      xDistance = (w + (this.grid.padding || 2)) * x;
      this.camera.position.setZ(zDistance);
      this.camera.position.setY(yDistance);
      this.camera.position.setX(xDistance);
      this.camera.lookAt(new THREE.Vector3(0, 0, 0));
      return this;
      /*
      
      
      @camera.rotation.z = 0.25
      */

    };

    Stage.prototype.render = function() {
      var L, extent, geometry, line, material;
      geometry = new THREE.Geometry();
      extent = 5000;
      geometry.vertices.push(new THREE.Vector3(0, 0, -extent));
      geometry.vertices.push(new THREE.Vector3(0, 0, extent));
      geometry.vertices.push(new THREE.Vector3(-extent, 0, 0));
      geometry.vertices.push(new THREE.Vector3(extent, 0, 0));
      geometry.vertices.push(new THREE.Vector3(0, -extent, 0));
      geometry.vertices.push(new THREE.Vector3(0, extent, 0));
      material = new THREE.LineBasicMaterial({
        color: 0x555555
      });
      line = new THREE.Line(geometry, material);
      this.scene.add(line);
      this.setCameraToIsometric();
      this.parent.renderer.render(this.scene, this.camera);
      L = this.parent.clock.loop("render", function() {
        return this.parent.renderer.render(this.scene, this.camera);
      }, null, this);
      L["for"]({
        interval: 17
      });
      return this.parent.clock.start();
    };

    Stage.prototype.destroy = function() {
      return this.parent.destroy(this.name);
    };

    return Stage;

  })(utils.EventEmitter);

  StageManager = function(engine) {
    /* @PRIVATES
    */

    var list, parent;
    parent = engine;
    /* @PUBLICS
    */

    list = {};
    this.list = [];
    this.create = function(name, options) {
      var o, stage;
      if (!name) {
        return;
      }
      o = options || {};
      stage = new Stage(parent, name, o);
      this.list.push(name);
      list[name.toLowerCase()] = stage;
      return list[name.toLowerCase()];
    };
    this.current = void 0;
    this.destroy = function(name) {
      return delete list[name];
    };
    this.load = function(name, transition) {};
    return this;
  };

  module.exports = StageManager;

}).call(this);

// Generated by CoffeeScript 1.5.0-pre

},{"./_input":3,"./_objects":4,"./_utils":6}],6:[function(require,module,exports){

/*
      utilities
*/


(function() {
  var EventEmitter,
    __slice = [].slice;

  module.exports.log = function(msg) {
    var prefix;
    this.logs.unshift(msg);
    if (!this.debug) {
      return;
    }
    prefix = "Engine :: ";
    if (typeof msg === "string") {
      console.log(prefix + msg);
    } else {
      console.log(msg);
    }
  };

  module.exports.extend = function() {
    var base, extended, key, obj, objs, _i, _len;
    objs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (objs.length < 2) {
      return objs[0];
    }
    extended = objs[0];
    for (_i = 0, _len = objs.length; _i < _len; _i++) {
      obj = objs[_i];
      base = obj;
      for (key in base) {
        extended[key] = base[key];
      }
    }
    return extended;
  };

  module.exports.isArray = Array.isArray || function(thing) {
    return Object.prototype.toString.call(thing === "[object Array]");
  };

  module.exports.isInt = function(num) {
    if (num / Math.floor(num) === 1 || num / Math.floor(num) === -1) {
      return true;
    }
    return false;
  };

  module.exports.pythag = function(A, B, hypotenuse) {
    var a2, b2, result;
    if (!(arguments.length >= 2)) {
      return;
    }
    if (B === null) {
      result = (Math.pow(hypotenuse, 2)) - Math.pow(A, 2);
      result = Math.sqrt(result);
      return result;
    } else {
      a2 = Math.pow(A, 2);
      b2 = Math.pow(B, 2);
      result = Math.sqrt(a2 + b2);
      return result;
    }
  };

  module.exports.steps = function(base, target, yAxis) {
    var x, y, z;
    if (yAxis == null) {
      yAxis = false;
    }
    x = Math.abs(base.x - target.x);
    z = Math.abs(base.z - target.z);
    y = yAxis ? Math.abs(base.y - target.y) : 0;
    return x + y + z;
  };

  module.exports.getJSON = function(url, callbacks) {
    var ajax, data, options;
    options = callbacks || {};
    data = void 0;
    ajax = $.getJSON(url);
    return ajax.complete(function() {
      try {
        data = $.parseJSON(ajax.responseText);
      } catch (e) {
        options.error.call(options.scope || null, e, ajax);
        return;
      }
      options.success.call(options.scope || null, data, ajax);
    });
  };

  module.exports.getMousePosition = function($e) {
    var normalized, x, y;
    if (!($e.type === "click" || $e.type === "mousemove")) {
      return;
    }
    x = $e.clientX;
    y = $e.clientY;
    normalized = {
      "x": (x / window.innerWidth) * 2 - 1,
      "y": -(y / window.innerHeight) * 2 + 1
    };
    return {
      x: x,
      y: y,
      normalized: normalized
    };
  };

  module.exports.EventEmitter = EventEmitter = (function() {

    function EventEmitter() {
      this.__events = {};
    }

    EventEmitter.prototype.on = function(name, fn, context) {
      if (this.__events === void 0) {
        this.__events = {};
      }
      this.__events[name] = {
        fn: fn,
        context: context
      };
      return this;
    };

    EventEmitter.prototype.off = function(name) {
      delete this.__events[name];
      return this;
    };

    EventEmitter.prototype.get = function(name) {
      if (this.__events === void 0) {
        return;
      }
      return this.__events[name];
    };

    EventEmitter.prototype.trigger = function(name, args) {
      var f;
      if (args == null) {
        args = [];
      }
      if (this.__events === void 0) {
        return;
      }
      f = this.get(name);
      if (f === void 0) {
        return;
      }
      f.fn.apply(f.context, args);
      return this;
    };

    return EventEmitter;

  })();

}).call(this);

// Generated by CoffeeScript 1.5.0-pre

},{}],7:[function(require,module,exports){
(function() {

  require("./_base");

  require("./main");

}).call(this);

// Generated by CoffeeScript 1.5.0-pre

},{"./_base":1,"./main":8}],8:[function(require,module,exports){
(function() {



}).call(this);

// Generated by CoffeeScript 1.5.0-pre

},{}]},{},[7])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFJvYXItWWF3blxcc2FuZGJveFxcdGhyZWVqcy10YWN0aWNzLWVuZ2luZVxcbm9kZV9tb2R1bGVzXFxicm93c2VyaWZ5XFxub2RlX21vZHVsZXNcXGJyb3dzZXItcGFja1xcX3ByZWx1ZGUuanMiLCJDOi9Vc2Vycy9Sb2FyLVlhd24vc2FuZGJveC90aHJlZWpzLXRhY3RpY3MtZW5naW5lL3B1YmxpYy9qYXZhc2NyaXB0L3NyYy9fYmFzZS5qcyIsIkM6L1VzZXJzL1JvYXItWWF3bi9zYW5kYm94L3RocmVlanMtdGFjdGljcy1lbmdpbmUvcHVibGljL2phdmFzY3JpcHQvc3JjL19jbG9jay5qcyIsIkM6L1VzZXJzL1JvYXItWWF3bi9zYW5kYm94L3RocmVlanMtdGFjdGljcy1lbmdpbmUvcHVibGljL2phdmFzY3JpcHQvc3JjL19pbnB1dC5qcyIsIkM6L1VzZXJzL1JvYXItWWF3bi9zYW5kYm94L3RocmVlanMtdGFjdGljcy1lbmdpbmUvcHVibGljL2phdmFzY3JpcHQvc3JjL19vYmplY3RzLmpzIiwiQzovVXNlcnMvUm9hci1ZYXduL3NhbmRib3gvdGhyZWVqcy10YWN0aWNzLWVuZ2luZS9wdWJsaWMvamF2YXNjcmlwdC9zcmMvX3N0YWdlLmpzIiwiQzovVXNlcnMvUm9hci1ZYXduL3NhbmRib3gvdGhyZWVqcy10YWN0aWNzLWVuZ2luZS9wdWJsaWMvamF2YXNjcmlwdC9zcmMvX3V0aWxzLmpzIiwiQzovVXNlcnMvUm9hci1ZYXduL3NhbmRib3gvdGhyZWVqcy10YWN0aWNzLWVuZ2luZS9wdWJsaWMvamF2YXNjcmlwdC9zcmMvYnJvd3Nlci5qcyIsIkM6L1VzZXJzL1JvYXItWWF3bi9zYW5kYm94L3RocmVlanMtdGFjdGljcy1lbmdpbmUvcHVibGljL2phdmFzY3JpcHQvc3JjL21haW4uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6aUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKX12YXIgZj1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwoZi5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxmLGYuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiXG4vKlxuICAgIHRocmVlLWpzIFRhY3RpY3MgRW5naW5lXG4qL1xuXG5cbihmdW5jdGlvbigpIHtcbiAgdmFyIENsb2NrLCBTdGFnZSwgVGhyZWVUYWN0aWNzRW5naW5lLCB1dGlscztcblxuICB1dGlscyA9IHJlcXVpcmUoXCIuL191dGlsc1wiKTtcblxuICBTdGFnZSA9IHJlcXVpcmUoXCIuL19zdGFnZVwiKTtcblxuICBDbG9jayA9IHJlcXVpcmUoXCIuL19jbG9ja1wiKTtcblxuICBUaHJlZVRhY3RpY3NFbmdpbmUgPSBmdW5jdGlvbigpIHtcbiAgICAvKlxuICAgICAgQFBSSVZBVEVTXG4gICAgKi9cblxuICAgIHZhciBUSFJFRSwgY29uZmlnTG9hZGVkLCBldmVudE1ldGhvZHMsIGxvZywgbmFtZSwgc2NlbmUsIHRoYXQsIF9pLCBfbGVuO1xuICAgIGlmIChzZWxmLlRIUkVFID09PSB2b2lkIDAgfHwgc2VsZi4kID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBlbmdpbmUgaXMgZGVwZW5kZW50IG9uIFRIUkVFLmpzIGFuZCBqUXVlcnksIHdoaWNoIG9uZSBvZiB3YXMgbm90IGZvdW5kLCBvciBub3QgaW4gdGhlIGdsb2JhbCBzY29wZS5cIik7XG4gICAgfVxuICAgIFRIUkVFID0gc2VsZi5USFJFRTtcbiAgICBjb25maWdMb2FkZWQgPSBmYWxzZTtcbiAgICBzY2VuZSA9IGZhbHNlO1xuICAgIHRoYXQgPSB0aGlzO1xuICAgIHRoaXMuZGVidWcgPSB0cnVlO1xuICAgIHRoaXMubG9ncyA9IFtdO1xuICAgIGxvZyA9IChmdW5jdGlvbihtc2cpIHtcbiAgICAgIHJldHVybiB1dGlscy5sb2cuY2FsbCh0aGlzLCBtc2csIHRoaXMubG9ncyk7XG4gICAgfSkuYmluZCh0aGlzKTtcbiAgICB0aGlzLmxvZyA9IGxvZztcbiAgICAvKlxuICAgICAgQFBVQkxJQ1NcbiAgICAqL1xuXG4gICAgdGhpcy5sb2FkID0gZnVuY3Rpb24oKSB7fTtcbiAgICB0aGlzLnJlbmRlclF1ZXVlID0gW107XG4gICAgdGhpcy5zdGFnZSA9IG5ldyBTdGFnZSh0aGlzKTtcbiAgICB0aGlzLmNsb2NrID0gbmV3IENsb2NrKCk7XG4gICAgLyogXG4gICAgICBEeW5hbWljYWxseSBhZGQgZXZlbnQgbWV0aG9kcyBmcm9tIHRoZSBjbG9jayBvYmplY3QgKHdoaWNoIGhhcyBhbiBldmVudCBlbWl0dGVyIGJ1aWx0IGludG8gaXQuKVxuICAgICAgdGhpcyBhcnJheSBpcyB0aGUgbmFtZXMgb2YgdGhlIG1ldGhvZHMgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBldmVudHMgb2JqZWN0XG4gICAgKi9cblxuICAgIGV2ZW50TWV0aG9kcyA9IFtcIm9uXCIsIFwib2ZmXCIsIFwiZGVmZXJcIiwgXCJnZXRFdmVudHNcIiwgXCJ0cmlnZ2VyXCIsIFwicmVtb3ZlXCJdO1xuICAgIHRoaXMuZXZlbnRzID0ge307XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBldmVudE1ldGhvZHMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgIG5hbWUgPSBldmVudE1ldGhvZHNbX2ldO1xuICAgICAgdGhpcy5ldmVudHNbbmFtZV0gPSB0aGlzLmNsb2NrW25hbWVdO1xuICAgIH1cbiAgICB0aGlzLmluaXQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgY29uZmlnO1xuICAgICAgY29uZmlnID0gJC5nZXRKU09OKChvcHRpb25zIHx8IHt9KS5jb25maWcpO1xuICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGF0ID0gdGhpcztcbiAgICAgIHJldHVybiBjb25maWcuY29tcGxldGUoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZW5kZXJlcjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGF0LmNvbmZpZyA9ICQucGFyc2VKU09OKGNvbmZpZy5yZXNwb25zZVRleHQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgbG9nKGUpO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkpTT04gd2FzIG5vdCBwYXJzZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbmZpZ0xvYWRlZCA9IHRydWU7XG4gICAgICAgIGxvZyhcIkNvbmZpZ3VyYXRpb24gTG9hZGVkLlwiKTtcbiAgICAgICAgcmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlcih7XG4gICAgICAgICAgYW50aWFsaWFzOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZW5kZXJlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHJlbmRlcmVyLmRvbUVsZW1lbnQpO1xuICAgICAgICB0aGF0LnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIGxvZyhcIkluaXRpYWxpemVkLlwiKTtcbiAgICAgICAgaWYgKChvcHRpb25zIHx8IHt9KS5hdXRvc3RhcnQgPT09IHRydWUpIHtcbiAgICAgICAgICByZXR1cm4gdGhhdC5zdGFydCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMuc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzdGFnZTtcbiAgICAgIGlmICghY29uZmlnTG9hZGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdGFnZSA9IHRoaXMuc3RhZ2UuY3JlYXRlKFwidGVzdFwiLCB7XG4gICAgICAgIFwidXJsXCI6IFwianNvbi90ZXN0Lmpzb25cIixcbiAgICAgICAgXCJjYW1lcmFcIjogbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKDQ1LCB3aW5kb3cuaW5uZXJXaWR0aCAvIHdpbmRvdy5pbm5lckhlaWdodCwgMC4xLCAxMDAwMDApLFxuICAgICAgICBcInNjZW5lXCI6IG5ldyBUSFJFRS5TY2VuZSgpXG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHNlbGYuRW5naW5lID0gbmV3IFRocmVlVGFjdGljc0VuZ2luZSgpO1xuXG4gIEVuZ2luZS5pbml0KHtcbiAgICBcImNvbmZpZ1wiOiBcImpzb24vY29uZmlnLmpzb25cIixcbiAgICBcImF1dG9zdGFydFwiOiB0cnVlXG4gIH0pO1xuXG4gIGNvbnNvbGUubG9nKEVuZ2luZSk7XG5cbn0pLmNhbGwodGhpcyk7XG5cbi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS41LjAtcHJlXG4iLCJcbiAgLypcbiAgICBNb2RpZmllZCB2ZXJzaW9uIGZyb21cblxuICAgICstKy0gR0lUSFVCIC0rLStcbiAgdW5tb2RpZmllZCB2ZXJzaW9uIGxvY2F0ZWQgYXQ6XG4gICAgaHR0cHM6Ly9naXRodWIuY29tL1JvcnlEdW5jYW4vQ2xvY2tFdmVudEFnZ3JlZ2dhdG9yXG4gICAgXG4gICAgKy0rLSBET0NVTUVOVEFUSU9OIC0rLStcbiAgICBodHRwOi8vcm9yeWR1bmNhbi5naXRodWIuaW8vQ2xvY2tFdmVudEFnZ3JlZ2dhdG9yL1xuXG4gICovXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuL191dGlsc1wiKTtcblxudmFyIENsb2NrID0gZnVuY3Rpb24oYXJncykge1xuXG4gIC8qIEhlbHBlcnMgKi9cblxuICAvLyBIZWxwZXIgZm9yIG1lcmdpbmcgb2JqZWN0c1xuICBleHRlbmQgPSB1dGlscy5leHRlbmQ7XG5cbiAgdmFyIGlzQXJyYXkgPSBmdW5jdGlvbih0aGluZyl7XG4gICAgLy8gYXNzdW1lICd0aGluZycgaXMgbm90IHVuZGVmaW5lZCBvciBudWxsIGFzIGl0IHdpbGwgdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKHR5cGVvZiB0aGluZyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGZhbHNlO1xuICAgIGlmICggKHRoaW5nKS5sZW5ndGggPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZhbHNlO1xuICAgIGVsc2UgcmV0dXJuIHRydWU7IFxuICB9XG5cblxuICAvKiAgVGltZWxpbmUgcmVsYXRlZCB2YXJpYWJsZXMgICovXG5cbiAgdmFyIGRlZmF1bHRzID0ge3VzZVJBRjogdHJ1ZSwgdGlja0ludGVydmFsOiAxNiwgYXV0b3N0YXJ0OiBmYWxzZX0sXG4gICAgICBvcHRpb25zID0gZXh0ZW5kKGRlZmF1bHRzLCBhcmdzKSxcbiAgICAgIHRpY2tzID0gMCxcbiAgICAgIGxhc3RUaWNrID0gMCxcbiAgICAgIHN0YXJ0VGltZSA9IDAsXG5cbiAgICAgIC8vIHRoZSAnY2xvY2snIHRpbWUsIGNhbGN1bGF0ZWQgd2l0aCBkZWx0YSBhbmQgY2xvY2tTcGVlZCB2YXJpYWJsZXMuXG4gICAgICBlbGFwc2VkVGltZSA9IDAsXG5cbiAgICAgIC8vIGlkIGZvciByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgIHJBRklEID0gbnVsbCxcblxuICAgICAgLy8gd2hldGhlciB0aGlzIGlzIGV2ZXJ5IG90aGVyIHRpY2tcbiAgICAgIHRpY2tfbiA9IGZhbHNlLFxuXG4gICAgICAvLyB0aGUgYW1vdW50IG9mIHJlYWwtdGltZSB0aGF0IGhhcyBwYXNzZWQgYmV0d2VlbiB0aWNrc1xuICAgICAgZGVsdGEgPSAwLFxuICAgICAgYWN0dWFsRWxhcHNlZFRpbWUgPSAwO1xuXG4gICAgICAvLyBmYWxsYmFjayB0aW1lIGZvciBzZXRUaW1lb3V0XG4gICAgICB0aGlzLnRpY2tJbnRlcnZhbCA9IG9wdGlvbnMudGlja0ludGVydmFsLFxuXG4gICAgICBydW5uaW5nID0gZmFsc2UsXG5cbiAgICAgIC8vIHNwZWVkIGF0IHdoaWNoIHRoZSBjbG9jayBydW5zXG4gICAgICBjbG9ja3NwZWVkID0gMSxcblxuICAgICAgLy8gcmVmZXJlbmNlXG4gICAgICBzZWxmID0gdGhpcyxcblxuICAgICAgLy8gd2V0aGVyIG9yIG5vdCB0byB1c2UgcmVxdWVzdCBBbmltYXRpb24gRnJhbWVcbiAgICAgIHVzZVJBRiA9IG9wdGlvbnMudXNlUkFGLFxuXG4gICAgICAvLyBkeW5hbWljIGZ1bmN0aW9uIGZvciByQUYgb3Igc2V0VGltZW91dCBmdW5jdGlvbmFsaXR5LFxuICAgICAgdGlja0NhbGxlZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBzZXQgdG8gc3RhcnQoKSBpbml0aWFsbHkgaW4gY2FzZSBjYWxsZWQgYmVmb3JlIHN0YXJ0IHNvbWVob3cuXG4gICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgIH07XG5cbiAgICAgIFxuICAgICAgXG5cblxuICAvKiAgRXZlbnQgQWdncmVnYXRvciByZWxhdGVkIHZhcmlhYmxlcyAgKi9cblxuICB2YXIgZXZlbnRzID0ge307XG4gICAgICBldmVudHMubm9taW5hbCA9IHt9O1xuICAgICAgZXZlbnRzLm9yZGluYWwgPSB7fTtcbiAgICAgIGV2ZW50cy5sb29wcyA9IHt9O1xuXG4gIFxuICAvKiAgSW50ZXJuYWwgRnVuY3Rpb25zICovXG5cbiAgLy8gIGNsb2NrJ3MgdGljayBtZWNoYW5pc21cbiAgdmFyIHRpY2sgPSBmdW5jdGlvbigpIHtcbiAgICBcbiAgICB2YXIgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7IC8vY2FjaGVcbiAgICBpZiAoIXJ1bm5pbmcpIHJldHVybjtcbiAgICBcbiAgICB0aWNrcyArPSAxICogY2xvY2tzcGVlZDtcbiAgICB0aWNrX24gPSAhdGlja19uO1xuICAgIGlmICh0aGlzLmRlYnVnICYmIHRpY2tfbikgdGhpcy5sb2coKTtcblxuICAgIFxuICAgIHRoaXMuZGVsdGEgPSBkZWx0YSA9IChub3cgLSBsYXN0VGljaykgKiBjbG9ja3NwZWVkO1xuXG4gICAgbGFzdFRpY2sgPSBub3c7XG5cbiAgICBlbGFwc2VkVGltZSArPSBkZWx0YTtcblxuICAgIGFjdHVhbEVsYXBzZWRUaW1lID0gKCBub3cgLSBzdGFydFRpbWUgKTtcblxuICAgIHRoaXMuZXJyb3JNYXJnaW4gPSBhY3R1YWxFbGFwc2VkVGltZSAtIGVsYXBzZWRUaW1lOyBcblxuXG4gICAgLy8gc2luZ3VsYXIgZXZlbnRzIHRha2UgcHJlY2VkZW5jZSBvdmVyIGxvb3AgZXZlbnRzLlxuICAgIHRyaWdnZXJDdXJyZW50RXZlbnRzKCk7XG4gICAgdHJpZ2dlckxvb3BFdmVudHMoKTtcblxuICAgIHRoaXMudHJpZ2dlcihcInRpY2tcIik7XG5cbiAgICBcbiAgICByQUZJRCA9IHRpY2tDYWxsZWUoKTtcblxuICAgIHJldHVybiB0aWNrcztcbiAgfTtcbiAgXG4gIHZhciBidWlsZERlZmF1bHRFdmVudHMgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBkZWZhdWx0RXZlbnRzID0gW1widGlja1wiLCBcInN0YXJ0XCIsIFwiYWZ0ZXI6c3RhcnRcIiwgXCJwYXVzZVwiLCBcInJlc3VtZVwiXSxcbiAgICAgICAgYWRkRXZlbnQgPSBmdW5jdGlvbihuYW1lKXtcblxuICAgICAgICAgIGV2ZW50cy5vcmRpbmFsW25hbWVdID0gW107XG4gICAgICAgIH07XG5cbiAgICBkZWZhdWx0RXZlbnRzLmZvckVhY2goYWRkRXZlbnQpO1xuXG4gIH07XG4gIGJ1aWxkRGVmYXVsdEV2ZW50cygpO1xuXG4gIHZhciB0cmlnZ2VyT3JkaW5hbEV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIG5vdyA9IH5+KGVsYXBzZWRUaW1lIC8gMTAwKSAqIDEwMDtcblxuICAgIGlmICggZXZlbnRzLm9yZGluYWxbIG5vdyBdID09PSB1bmRlZmluZWQgKSB7cmV0dXJuIGZhbHNlO30gIC8vIHJldHVybiBmYWxzZSBpbiBjYXNlIG9mIGNoZWNrc1xuXG4gICAgXG4gICAgdmFyIGVvdCA9IGV2ZW50cy5vcmRpbmFsWyBub3cgXTtcblxuICAgIC8vIGV2ZW50cy5vcmRpbmFsIHdpbGwgYmUgYW4gYXJyYXksIHNvIGxvb3Agb3ZlciBlYWNoIGZ1bmN0aW9uIGluIGl0LlxuICAgIGZvciAodmFyIF94ID0gMCwgX3h4ID0gZW90Lmxlbmd0aDsgX3ggPCBfeHg7IF94KyspIHtcblxuICAgICAgdmFyIGZuID0gZW90W194XS5mbixcbiAgICAgICAgICBjdHggPSBlb3RbX3hdLmNvbnRleHQsXG4gICAgICAgICAgYXJncyA9IGVvdFtfeF0uYXJncztcblxuICAgICAgZm4uYXBwbHkoY3R4LCBhcmdzKTtcbiAgICB9XG5cbiAgICAvLyBkZWxldGUgaXQsIHNvIHRoYXQgaXQgd29uJ3QgdHJpZ2dlciB0aGUgbmV4dCB0aWNrcyB0aGF0IHJvdW5kIGRvd24gdG8gdGhpcyB0aW1lLlxuICAgIGRlbGV0ZSBldmVudHMub3JkaW5hbFsgbm93IF07XG5cbiAgICByZXR1cm4gdHJ1ZTsgLy8gcmV0dXJuIHRydWUgaW4gY2FzZSBvZiBjaGVja3NcbiAgfTtcblxuICB2YXIgdHJpZ2dlckxvb3BFdmVudHMgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBub3cgPSB+fmVsYXBzZWRUaW1lO1xuXG4gICAgdmFyIGV4cGlyZWQgPSBbXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBldmVudHMubG9vcHMpIHtcblxuICAgICAgdmFyIGxvb3AgPSBldmVudHMubG9vcHNbIGtleSBdXG5cbiAgICAgIGlmIChsb29wLnN0YXJ0IDw9IG5vdyAmJiAgICAgICAgICAvLyBDaGVjayBpZiBpdCBpcyAnYWxsb3dlZCcgdG8gc3RhcnQuXG4gICAgICAgICAgbG9vcC5jaGVja0ludGVydmFsKCBub3cgKSAmJiAgLy8gQ2hlY2sgd2hldGhlciB0aGUgbG9vcCBzaG91bGQgZmlyZSBhdCB0aGUgY3VycmVudCB0aW1lXG4gICAgICAgICAgbG9vcC5kZWxldGUgPT09IGZhbHNlICkgeyAgICAgIC8vIENoZWNrIGlmIGl0IGlzIHRvIGJlIGRlbGV0ZWRcbiAgICAgICAgICBcbiAgICAgICAgICAvLyB0aGVyZSBpcyBhIHJlZmVyZW5jZSB0byBfdGhpc18gaW5zaWRlIG9mIGxvb3AsXG4gICAgICAgICAgLy8gc28gc2VuZGluZyB0aGUgbG9vcCBpdHNlbGYgYXMgY29udGV4dCBpcyBlbm91Z2guXG4gICAgICAgICAgbG9vcC5jYWxsZWRBdC5wdXNoKCBub3cgKTtcbiAgICAgICAgICBsb29wLm5vdyA9IG5vdztcbiAgICAgICAgICBcbiAgICAgICAgICBsb29wLmZuLmFwcGx5KCBsb29wLnNjb3BlLCBsb29wLmFyZ3MgKTtcbiAgICAgICAgICBcbiAgICAgICAgICBsb29wLmxhc3RDYWxsID0gbm93O1xuICAgICAgICAgIGxvb3AuY2FsbHMrKztcbiAgICAgIH1cbiAgICAgIC8vIGNoZWNrIHdoZXRoZXIgaXQgaGFzIGV4cGlyZWRcbiAgICAgIGlmIChsb29wLnN0b3AgPT09IG5vdyB8fCBsb29wLmNhbGxzID09PSBsb29wLm1heEludGVydmFscyB8fCBsb29wLmRlbGV0ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyBwdXQgaXQgaW4gdGhlIGJveCB3aGVyZSBiYWQgbG9vcHMgZ28uXG4gICAgICAgIGV4cGlyZWQucHVzaCgga2V5ICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGVsZXRlIGFueSBsb29wcyBtYXJrZWRcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBleHBpcmVkLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIHZhciBuYW1lID0gZXhwaXJlZFtpXTtcbiAgICAgIGRlbGV0ZSBldmVudHMubG9vcHNbbmFtZV07XG4gICAgfVxuICB9O1xuXG5cbiAgLyogIEJpbmRpbmdzICAqL1xuXG4gIHRoaXMudGljayA9IHRpY2suYmluZCh0aGlzKTtcbiAgdmFyIHRyaWdnZXJMb29wRXZlbnRzID0gdHJpZ2dlckxvb3BFdmVudHMuYmluZCh0aGlzKTtcbiAgdmFyICB0cmlnZ2VyQ3VycmVudEV2ZW50cyA9IHRyaWdnZXJPcmRpbmFsRXZlbnRzLmJpbmQodGhpcyk7XG4gIFxuXG5cbiAgLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqL1xuICAvKiAqICogKiAqICogKiAqICogKiAqICogKiAgIEFQSSAgICogKiAqICogKiAqICogKiAqICogKiAqICovXG4gIC8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKi9cblxuXG4gIC8qICBDbG9jay1yZWxhdGVkIG1ldGhvZHMgICovXG5cbiAgdGhpcy5zdGFydCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgaWYgKHJ1bm5pbmcgPT09IHRydWUpIHsgcmV0dXJuIHRoaXM7IH0gLy8gc2ltcGxlIHRlc3RzIHRvIHByZXZlbnQgbXVsdGlwbGUgc3RhcnRzXG5cbiAgICAvLyB0aWNrTG9vcCBpcyBhIGR5bmFtaWNhbGx5IGNvbnN0cnVjdGVkIGZ1bmN0aW9uIHRvIHJlbW92ZSBhbiAnaWYnIHN0YXRlbWVudCBpbnNpZGUgb2YgdGljaygpIC5cbiAgICB2YXIgdGlja0xvb3A7ICBcblxuICAgIGlmICh1c2VSQUYgPT09IHRydWUpIHtcbiAgICAgIHRpY2tMb29wID0gbmV3IEZ1bmN0aW9uKFwiIHZhciBpZCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHRoaXMudGljayApOyByZXR1cm4gaWQ7XCIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRpY2tMb29wID0gbmV3IEZ1bmN0aW9uKFwiIHZhciBpZCA9IHdpbmRvdy5zZXRUaW1lb3V0KHRoaXMudGljaywgdGhpcy50aWNrSW50ZXJ2YWwpO3JldHVybiBpZDtcIiApO1xuICAgIH1cbiAgICAvLyBiaW5kIGludG8gdGhpcyBjb250ZXh0XG4gICAgdGlja0NhbGxlZSA9IHRpY2tMb29wLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLnRyaWdnZXIoXCJiZWZvcmU6c3RhcnRcIik7XG5cbiAgICB2YXIgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgdGhpcy5zdGFydFRpbWUgPSBzdGFydFRpbWUgPSBub3c7XG4gICAgcnVubmluZyA9IHRydWU7XG4gICAgbGFzdFRpY2sgPSBub3c7XG4gICAgdGhpcy50aWNrKCk7XG5cbiAgICB0aGlzLmVuYWJsZVBhdXNlT25CbHVyKCk7XG4gICAgdGhpcy50cmlnZ2VyKFwic3RhcnRcIik7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfS5iaW5kKHRoaXMpO1xuXG4gIHRoaXMuc3RvcCA9IGZ1bmN0aW9uKCl7XG5cbiAgICBydW5uaW5nID0gZmFsc2U7XG4gICAgLy9yZXNldCBldmVudCBsaXN0c1xuICAgIGV2ZW50cy5ub21pbmFsID0ge307XG4gICAgZXZlbnRzLm9yZGluYWwgPSBbXTtcbiAgICBldmVudHMubG9vcHMgPSB7fTtcblxuICAgIGJ1aWxkRGVmYXVsdEV2ZW50cygpO1xuXG4gICAgLy9yZXNldCBjb3VudGVyc1xuICAgIHRpY2tzID0gMDtcbiAgICBlbGFwc2VkVGltZSA9IDA7XG4gICAgdGhpcy5zdGFydFRpbWUgPSBzdGFydFRpbWUgPSAwO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0uYmluZCh0aGlzKTtcblxuICB0aGlzLnJlc2V0ID0gZnVuY3Rpb24oKXtcblxuICAgIHRoaXMucmVzZXQoKTtcbiAgICB0aGlzLnN0YXJ0KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0uYmluZCh0aGlzKTtcblxuICB0aGlzLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gICAgcnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMudHJpZ2dlcihcInBhdXNlXCIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LmJpbmQodGhpcyk7XG5cbiAgdGhpcy5yZXN1bWUgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAocnVubmluZyA9PT0gdHJ1ZSkgcmV0dXJuIHRoaXM7XG4gICAgcnVubmluZyA9IHRydWU7XG4gICAgbGFzdFRpY2sgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB0aGlzLnRpY2soKTtcbiAgICB0aGlzLnRyaWdnZXIoXCJyZXN1bWVcIik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0uYmluZCh0aGlzKTtcblxuICB0aGlzLmNsb2NrU2NhbGFyID0gZnVuY3Rpb24obXVsdGlwbGllcikge1xuICAgIC8vIGEgcmVsYXRpdmUgd2F5IHRvIGFmZmVjdCB0aGUgY2xvY2tcbiAgICBjbG9ja3NwZWVkICo9IG11bHRpcGxpZXIgfHwgMTtcbiAgfTtcblxuICB0aGlzLnNldENsb2NrU3BlZWQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIC8vIGZvciBtYW51YWxseSBlbnRlcmluZyBhIHNwZWVkIHZhbHVlXG4gICAgY2xvY2tzcGVlZCA9IHZhbHVlIHx8IGNsb2Nrc3BlZWQ7XG4gIH07XG5cbiAgdGhpcy5lbmFibGVQYXVzZU9uQmx1ciA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIGNhbGxlZCBvbiBzdGFydFxuICAgIC8vIHJlcXVlc3RBbmltYXRpb25GcmFtZSBuYXRpdmVseSBwYXVzZXMgb25ibHVyLCBidXQsIHRoaXMgY2xvY2sgZG9lc24ndFxuICAgIC8vIHNvIEkndmUgcHJvZ3JhbW1lZCB0aGUgZnVuY3Rpb25hbGl0eSBpbnRvIGl0LiBcblxuICAgIHdpbmRvdy5vbmJsdXIgPSBmdW5jdGlvbigpe3NlbGYucGF1c2UoKTt9XG4gICAgd2luZG93Lm9uZm9jdXMgPSBmdW5jdGlvbigpe3NlbGYucmVzdW1lKCk7fTtcbiAgfTtcblxuICB0aGlzLmRpc2FibGVQYXVzZU9uQmx1ciA9IGZ1bmN0aW9uKCl7XG4gICAgd2luZG93Lm9uYmx1ciA9IGZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9O1xuICAgIHdpbmRvdy5vbmZvY3VzID0gZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH07XG4gIH07XG4gIFxuICB0aGlzLnRpY2tzID0gZnVuY3Rpb24oKXsgcmV0dXJuIHRpY2tzOyB9O1xuXG4gIHRoaXMubWlsbGlzZWNvbmRzID0gZnVuY3Rpb24oKXsgcmV0dXJuIGVsYXBzZWRUaW1lO307XG5cbiAgdGhpcy5zZWNvbmRzID0gZnVuY3Rpb24oKXsgcmV0dXJuIGVsYXBzZWRUaW1lIC8gMTAwMCA7IH07XG5cbiAgdGhpcy5taW51dGVzID0gZnVuY3Rpb24oKXsgcmV0dXJuICh0aGlzLnNlY29uZHMoKSAvIDYwKTsgfTtcblxuICB0aGlzLmRlYnVnID0gb3B0aW9ucy5kZWJ1ZyB8fCBmYWxzZTtcblxuICAvLyBpZiBkZWJ1ZyBpcyB0cnVlLCBsb2cgaXMgYXV0b21hdGljYWxseSBjYWxsZWQgZWFjaCB0aWNrXG4gIHRoaXMubG9nID0gZnVuY3Rpb24oKSB7XG5cbiAgICBjb25zb2xlLmNsZWFyKCk7XG4gICAgaWYgKHVzZVJBRikgY29uc29sZS5sb2coXCI8VXNpbmcgcmVxdWVzdEFuaW1hdGlvbkZyYW1lPlwiKTtcbiAgICBlbHNlIGNvbnNvbGUubG9nKFwiPFVzaW5nIHNldFRpbWVvdXQ+XCIpO1xuICAgIGNvbnNvbGUubG9nKFwidGlja3M6XCIsIHRpY2tzKTtcbiAgICBjb25zb2xlLmxvZyhcImRlbHRhOlwiLCBkZWx0YSk7XG4gICAgY29uc29sZS5sb2coXCJsYXN0VGljayhzaG91bGQgY2hhbmdlKVwiLCB+fmxhc3RUaWNrKVxuICAgIGNvbnNvbGUubG9nKFwiZWxhcHNlZCB0aW1lOlwiLCBlbGFwc2VkVGltZSAvIDEwMDApO1xuICAgIGNvbnNvbGUubG9nKFwiZWxhcHNlZCBzZWNvbmRzOlwiLCB+fihlbGFwc2VkVGltZSAvIDEwMDApKTtcbiAgICBjb25zb2xlLmxvZyhcImFjdHVhbCBlbGFwc2VkIHRpbWU6XCIsIGFjdHVhbEVsYXBzZWRUaW1lIC8gMTAwMCk7XG4gICAgY29uc29sZS53YXJuKFwiJWNkaWZmZXJlbmNlIChpbiBzZWNvbmRzKTogXCIgKyAodGhpcy5lcnJvck1hcmdpbiAvIDEwMDApLCBcImNvbG9yOiAjYTAwXCIgKTtcbiAgICBjb25zb2xlLmxvZyhcIklnbm9yZSBkaWZmZXJlbmNlcyBpZiB5b3UgaGF2ZSBjYWxsZWQgcGF1c2UgYXQgYW55IHRpbWUuXCIpO1xuICAgIGNvbnNvbGUubG9nKFwiRXN0aW1hdGVkIEZQUzpcIiwgfn4odGlja3MgLyAoIGVsYXBzZWRUaW1lIC8gMTAwMCApKSk7XG4gIH07XG5cbiAgdGhpcy50aW1lID0gdGhpcy5ub3cgPSBmdW5jdGlvbigpeyByZXR1cm4gZWxhcHNlZFRpbWU7IH07XG5cblxuXG4gIC8qICBFdmVudC1yZWxhdGVkIG1ldGhvZHMgICovXG4gIFxuICB0aGlzLnRyaWdnZXIgPSBmdW5jdGlvbihldmVudE5hbWUpIHtcblxuICAgIGlmIChldmVudHMubm9taW5hbFtldmVudE5hbWVdID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzO1xuXG4gICAgdmFyIGwgPSBldmVudHMubm9taW5hbFtldmVudE5hbWVdLmxlbmd0aFxuXG4gICAgZm9yICh2YXIgX3ggPSAwLCBfeHggPSBsOyBfeCA8IF94eDsgX3grKykge1xuXG4gICAgICAvLyB3b3csIG11Y2ggbGVuZ3RoLCBtYW55IGNoYXJzLCBzdWNoIHNjYXJ5LlxuICAgICAgdmFyIGZuID0gZXZlbnRzLm5vbWluYWxbZXZlbnROYW1lXVtfeF0uZm4sXG4gICAgICAgICAgY3R4ID0gZXZlbnRzLm5vbWluYWxbZXZlbnROYW1lXVtfeF0uY29udGV4dCxcbiAgICAgICAgICBhcmdzID0gZXZlbnRzLm5vbWluYWxbZXZlbnROYW1lXVtfeF0uYXJncztcblxuICAgICAgZm4uYXBwbHkoY3R4LCBhcmdzKTtcblxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB0aGlzLm9uID0gZnVuY3Rpb24oIGV2ZW50TmFtZSwgZm4gLyogWywgYXJncywgY29udGV4dCBdICovICkge1xuXG4gICAgdmFyIGNvbnRleHQgPSBhcmd1bWVudHNbM10gfHwgdGhpcywgYXJncyA9IGFyZ3VtZW50c1syXSB8fCBbXTtcblxuICAgIC8vIGNyZWF0ZSBhbiBhcnJheSBmb3IgdGhlIGV2ZW50XG4gICAgZXZlbnRzLm5vbWluYWxbZXZlbnROYW1lXSA9IGV2ZW50cy5ub21pbmFsW2V2ZW50TmFtZV0gfHwgW11cblxuICAgIHZhciBzY29wZSA9IHRoaXM7IC8vIGFsbCBldmVudHMgZGVmYXVsdCB0byB0aGUgc2NvcGUgb2YgdGhlIFRpbWVsaW5lIG9iamVjdC5cblxuICAgIGV2ZW50cy5ub21pbmFsW2V2ZW50TmFtZV0ucHVzaCh7XG4gICAgICAnZm4nOiBmbixcbiAgICAgICdhcmdzJzogYXJncyxcbiAgICAgICdjb250ZXh0JzogY29udGV4dFxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHRoaXMuYXQgPSBmdW5jdGlvbiggZWxhcHNlZE1TLCBmbiAvKiBbLCBhcmdzLCBjb250ZXh0IF0gKi8gKSB7XG4gICAgaWYgKGVsYXBzZWRNUyA9PT0gdW5kZWZpbmVkKSB7dGhyb3cgbmV3IEVycm9yKFwiYXQoKSBtZXRob2QgcmVxdWlyZXMgYSBjbG9jay10aW1lIHBhc3NlZCBpbiBhcyBmaXJzdCBwYXJhbWV0ZXIuXCIpOyByZXR1cm47fVxuICAgIGlmIChmbiA9PT0gdW5kZWZpbmVkKSB7dGhyb3cgbmV3IEVycm9yKFwiYXQoKSBtZXRob2QgcmVxdWlyZXMgYSBmdW5jdGlvbiBwYXNzZWQgaW4gYXMgc2Vjb25kIHBhcmFtZXRlci5cIik7IHJldHVybjt9XG5cbiAgICB2YXIgY29udGV4dCA9IGFyZ3VtZW50c1szXSB8fCBudWxsLCBhcmdzID0gYXJndW1lbnRzWzJdIHx8IHRoaXM7XG5cbiAgICB2YXIgYWRkVGltZSA9IGZ1bmN0aW9uKCB0aW1lICkge1xuXG4gICAgICB2YXIgdCA9IHRpbWUudG9TdHJpbmcoKTtcbiAgICAgIGV2ZW50cy5vcmRpbmFsWyB0aW1lIF0gPSBldmVudHMub3JkaW5hbFsgdGltZSBdIHx8IFtdO1xuICAgICAgZXZlbnRzLm9yZGluYWxbIHRpbWUgXS5wdXNoKHtcbiAgICAgICAgXCJmblwiOiBmbixcbiAgICAgICAgXCJjb250ZXh0XCI6IGNvbnRleHQsXG4gICAgICAgIFwiYXJnc1wiOiBhcmdzXG4gICAgICB9KTtcblxuICAgIH07XG5cbiAgICBpZiAoICFpc0FycmF5KGVsYXBzZWRNUykgKSB7XG4gICAgICBhZGRUaW1lKCBlbGFwc2VkTVMgKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9XG5cbiAgICAgIGVsYXBzZWRNUy5mb3JFYWNoKCBhZGRUaW1lICk7XG5cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdGhpcy5hZnRlciA9IGZ1bmN0aW9uKCBtaWxsaXNlY29uZHMsIGZuIC8qIFssIGFyZ3MsIGNvbnRleHQgXSAqLyApIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50c1syXSwgY29udGV4dCA9IGFyZ3VtZW50c1szXTtcbiAgICB0aGlzLmF0KCBlbGFwc2VkVGltZSArIG1pbGxpc2Vjb25kcywgZm4sIGFyZ3MsIGNvbnRleHQgKTtcbiAgfTtcblxuICB0aGlzLmxvb3AgPSBmdW5jdGlvbiggdW5pcXVlTmFtZSwgZm4sIGFyZ3MsIHNjb3BlICkge1xuXG4gICAgLypcbiAgICAgICAgdGhpcy5sb29wKCkgcmV0dXJucyBhIG5ldyBsb29wIG9iamVjdCwgd2hpY2ggdG8gYWx0ZXIgdGltaW5nLXJlbGF0ZWQgb3B0aW9uc1xuICAgICAgICB5b3UgY2FsbCBpdCdzIC5mb3IoKSBtZXRob2QuIFxuICAgICAgICBcbiAgICAgICAgRVg6XG4gICAgICAgIHZhciB4ID0gdGhpcy5sb29wKCphcmdzKS5mb3IoKmFyZ3MpO1xuICAgICovXG5cbiAgICBpZiAoIXVuaXF1ZU5hbWUpIHJldHVybiB0aGlzO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBkZWZhdWx0cyA9IHtcbiAgICAgICAgICBcImF1dG9zdGFydFwiOiB0cnVlLFxuICAgICAgICAgIFwic3RhcnRcIjogfn5lbGFwc2VkVGltZSxcbiAgICAgICAgICBcInN0b3BcIjogSW5maW5pdHksIFxuICAgICAgICAgIFwiaW50ZXJ2YWxcIjogSW5maW5pdHksIFxuICAgICAgICAgIFwibWF4SW50ZXJ2YWxzXCI6IEluZmluaXR5LCBcbiAgICAgICAgICBcImR1cmF0aW9uXCI6IDAsIFxuICAgICAgICAgIFwiY2FsbGVkQXRcIjogW10sXG4gICAgICAgICAgXCJzdGFydERlbGF5XCI6IDBcbiAgICAgICAgfSxcbiAgICAgICAgcmVxdWlyZWQgPSB7XG4gICAgICAgICAgXCJuYW1lXCI6dW5pcXVlTmFtZSxcbiAgICAgICAgICBcImZuXCI6IGZuLFxuICAgICAgICAgIFwic2NvcGVcIjogc2NvcGUgfHwgc2VsZixcbiAgICAgICAgICBcImNhbGxzXCI6IDAsXG4gICAgICAgICAgXCJwYXJlbnRcIjogc2VsZixcbiAgICAgICAgICBcImFyZ3NcIjogYXJncyB8fCBbXVxuICAgICAgICB9O1xuXG4gICAgLy8gdGhlIGxvb3Agb2JqZWN0IHRoYXQgd2lsbCBiZSByZXR1cm5lZFxuICAgIHZhciBMb29wID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXG5cbiAgICAgIGV4dGVuZCh0aGlzLCBkZWZhdWx0cywgcmVxdWlyZWQpO1xuXG4gICAgICAvLyB0aGUgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRoZSBsb29wIGlzIGNhbGxlZFxuICAgICAgdGhpcy5jaGVja0ludGVydmFsID0gZnVuY3Rpb24obm93KSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuc3RhcnQsXG4gICAgICAgICAgICBpbnRlcnZhbCA9IHRoaXMuaW50ZXJ2YWwsXG4gICAgICAgICAgICBkdXJhdGlvbiA9IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICBkb2VzSW50ZXJ2YWxNYXRjaE5vdyA9IChub3cgLSAoc3RhcnQgKyB0aGlzLnN0YXJ0RGVsYXkpKSAgJSAoaW50ZXJ2YWwgKyBkdXJhdGlvbiksXG4gICAgICAgICAgICBpbnRlcnZhbEhhc1Bhc3NlZCA9IG5vdyAtICh0aGlzLmxhc3RDYWxsID09PSB1bmRlZmluZWQgPyBzdGFydCA6IHRoaXMubGFzdENhbGwpO1xuICBcbiAgICAgICAgLypcbiAgICAgICAgY29uc29sZS5jbGVhcigpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIm5hbWU6XCIsIHRoaXMubmFtZSk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiRGVsdGE6XCIsIHNlbGYuZGVsdGEgKTtcbiAgICAgICAgY29uc29sZS5sb2coXCItLS0tLVwiKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJzdGFydDpcIiwgc3RhcnQpO1xuICAgICAgICBjb25zb2xlLmxvZyhcImRvZXNJbnRlcnZhbE1hdGNoTm93XCIsIGRvZXNJbnRlcnZhbE1hdGNoTm93KTtcbiAgICAgICAgY29uc29sZS5sb2coXCJpbnRlcnZhbDpcIiwgaW50ZXJ2YWwpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIm5vdzpcIiwgbm93KTtcbiAgICAgICAgY29uc29sZS5sb2coXCJsYXN0Q2FsbCdlZDpcIiwgdGhpcy5sYXN0Q2FsbCk7XG4gICAgICAgICovXG4gICAgICAgIFxuICAgICAgICBpZiAoIGRvZXNJbnRlcnZhbE1hdGNoTm93ID49IDAgJiYgZG9lc0ludGVydmFsTWF0Y2hOb3cgPD0gZGVsdGEgJiYgKG5vdyAtIHRoaXMubGFzdENhbGwpID4gKGludGVydmFsKjAuOTkpICkgcmV0dXJuIHRydWU7XG4gICAgICAgIGVsc2UgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5mb3IgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIGV4dGVuZCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5sYXN0Q2FsbCA9IHRoaXMuc3RhcnQgLSB0aGlzLmludGVydmFsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuZGVsZXRlID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHZhciBsID0gbmV3IExvb3AoKTtcblxuICAgIGV2ZW50cy5sb29wc1sgbC5uYW1lIF0gPSBsO1xuXG4gICAgcmV0dXJuIGw7XG4gIH07XG5cbiAgdGhpcy5yZW1vdmUgPSAgdGhpcy5vZmYgPSBmdW5jdGlvbihldmVudCkge1xuXG4gICAgaWYgKHR5cGVvZiBldmVudCA9PT0gXCJudW1iZXJcIikge1xuXG4gICAgICBpZiAoZXZlbnRzLm9yZGluYWxbZXZlbnRdID09PSB1bmRlZmluZWQpIHJldHVybiB7XCJyZW1vdmVkXCI6ZmFsc2UsIFwiY3R4XCI6IHRoaXN9O1xuXG4gICAgICBkZWxldGUgZXZlbnRzLm9yZGluYWxbZXZlbnRdO1xuICAgICAgcmV0dXJuIHtcInJlbW92ZWRcIjp0cnVlLCBcImN0eFwiOiB0aGlzfTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGV2ZW50ID09PSBcInN0cmluZ1wiKSB7XG5cbiAgICAgIC8vIGlmIGl0IGlzIGEgZXZlbnQgc2V0IHdpdGggb24oKTpcbiAgICAgIGlmIChldmVudHMubm9taW5hbFtldmVudE5hbWVdID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAvL2lmIGl0IGlzIGEgbG9vcCBldmVudCBcbiAgICAgICAgaWYgKGV2ZW50cy5sb29wc1tldmVudE5hbWVdID09PSB1bmRlZmluZWQpIHJldHVybiB7XCJyZW1vdmVkXCI6ZmFsc2UsIFwiY3R4XCI6IHRoaXN9O1xuXG4gICAgICAgIC8vIGxvb3BzIHRlcm1pbmF0ZSB0aGVtc2VsdmVzIGF1dG9tYXRpY2FsbHkgd2hlbiBzZXQgdG8gZGVsZXRlXG4gICAgICAgIGV2ZW50cy5sb29wc1tldmVudE5hbWVdLmRlbGV0ZSA9IHRydWU7XG4gICAgICAgIHJldHVybiB7XCJyZW1vdmVkXCI6dHJ1ZSwgXCJjdHhcIjogdGhpc307XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSBldmVudHMubm9taW5hbFtldmVudE5hbWVdO1xuICAgICAgcmV0dXJuIHtcInJlbW92ZWRcIjp0cnVlLCBcImN0eFwiOiB0aGlzfTtcbiAgICB9IFxuICB9O1xuXG4gIHRoaXMuZGVmZXIgPSBmdW5jdGlvbihmbil7XG4gICAgLy8gd2FpdHMgZm9yIHRoZSBjdXJyZW50IHN0YWNrIHRvIGNsZWFyXG4gICAgd2luZG93LnNldFRpbWVvdXQoMCwgZm4pXG4gIH07XG5cbiAgdGhpcy5nZXRFdmVudHMgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBpbiBjYXNlIHNvbWVvbmUgd2FudHMgdG8gdmlldyB0aGUgaW50ZXJuYWxseSBzZXQgZXZlbnRzXG4gICAgcmV0dXJuIGV2ZW50cztcbiAgfTtcblxuICAvKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG5cbiAgICBiaW5kVG9GdW5jdGlvbjpcblxuICAgIEF0dGFjaCAnd2FpdCcgbWV0aG9kIHRvIHRoZSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgZGVsZWdhdGluZyB0byB0aGUgdGltZWxpbmUncyA8dGhpcz4uYWZ0ZXIoKSBtZXRob2QuXG4gICAgVXNlZnVsPyBDb3VsZCBiZS4gSW52YXNpdmUgb2YgZ2xvYmFsIHByb3RvdHlwZXM/IERlZi5cblxuICAqICogKiAqICogKiAqICogKiAqICogKiAqICovXG4gIFxuICBpZiAob3B0aW9ucy5iaW5kVG9GdW5jdGlvbiA9PT0gdHJ1ZSkge1xuXG4gICAgICB2YXIgX3QgPSB0aGlzOyAvLyByZWZlcmVuY2UsIHNpbmNlIHdhaXQgaXMgaW4gdGhlIGNvbnRleHQgb2YgdGhlIGNhbGxlZVxuXG4gICAgICB2YXIgd2FpdCA9IGZ1bmN0aW9uKHNlY29uZHMsIGFyZ3MsIGNvbnRleHQpIHtcbiAgICAgICAgX3QuYWZ0ZXIoc2Vjb25kcywgdGhpcywgYXJncywgY29udGV4dCk7IFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgRnVuY3Rpb24ucHJvdG90eXBlLndhaXQgPSB3YWl0O1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuYXV0b3N0YXJ0ID09PSB0cnVlKSB0aGlzLnN0YXJ0KCk7XG4gIGVsc2UgcmV0dXJuIHRoaXM7XG59O1xuICAgXG5cbm1vZHVsZS5leHBvcnRzID0gQ2xvY2s7XG4iLCJcbi8qXG4jIEBJbnB1dEludGVyZmFjZVxuI1xuKi9cblxuXG4oZnVuY3Rpb24oKSB7XG4gIHZhciB1dGlscztcblxuICB1dGlscyA9IHJlcXVpcmUoXCIuL191dGlsc1wiKTtcblxuICBtb2R1bGUuZXhwb3J0cy5JbnRlcmZhY2UgPSBmdW5jdGlvbihjYW52YXMsIHBhcmVudCwgZW5naW5lKSB7XG4gICAgdmFyICRlbCwgYm91bmQsIGhhbmRsZXIsIGtleSwgbW91c2Vtb3ZlSGFuZGxlciwgc2NvcGU7XG4gICAgaWYgKCEkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICAkZWwgPSAkKGNhbnZhcyk7XG4gICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgIHRoaXMuZW5naW5lID0gZW5naW5lO1xuICAgICAgc2NvcGUgPSBlbmdpbmU7XG4gICAgfSBlbHNlIHtcbiAgICAgICRlbCA9ICQocGFyZW50LnJlbmRlcmVyLmRvbUVsZW1lbnQpO1xuICAgICAgdGhpcy5wYXJlbnQgPSBjYW52YXM7XG4gICAgICB0aGlzLmVuZ2luZSA9IHBhcmVudDtcbiAgICAgIHNjb3BlID0gcGFyZW50O1xuICAgIH1cbiAgICBrZXkgPSB7XG4gICAgICBcImxlZnRDbGlja1wiOiAxLFxuICAgICAgXCJzY3JvbGx3aGVlbFwiOiAyLFxuICAgICAgXCJyaWdodENsaWNrXCI6IDMsXG4gICAgICAnYmFja3NwYWNlJzogOCxcbiAgICAgICd0YWInOiA5LFxuICAgICAgJ2VudGVyJzogMTMsXG4gICAgICAnc2hpZnQnOiAxNixcbiAgICAgICdjdHJsJzogMTcsXG4gICAgICAnYWx0JzogMTgsXG4gICAgICAncGF1c2UnOiAxOSxcbiAgICAgICdjYXBzbG9jayc6IDIwLFxuICAgICAgJ2VzYyc6IDI3LFxuICAgICAgJ3BhZ2V1cCc6IDMzLFxuICAgICAgJ3BhZ2Vkb3duJzogMzQsXG4gICAgICAnZW5kJzogMzUsXG4gICAgICAnaG9tZSc6IDM2LFxuICAgICAgJ2xlZnQnOiAzNyxcbiAgICAgICd1cCc6IDM4LFxuICAgICAgJ3JpZ2h0JzogMzksXG4gICAgICAnZG93bic6IDQwLFxuICAgICAgJ2luc2VydCc6IDQ1LFxuICAgICAgJ2RlbGV0ZSc6IDQ2LFxuICAgICAgJzAnOiA0OCxcbiAgICAgICcxJzogNDksXG4gICAgICAnMic6IDUwLFxuICAgICAgJzMnOiA1MSxcbiAgICAgICc0JzogNTIsXG4gICAgICAnNSc6IDUzLFxuICAgICAgJzYnOiA1NCxcbiAgICAgICc3JzogNTUsXG4gICAgICAnOCc6IDU2LFxuICAgICAgJzknOiA1NyxcbiAgICAgICdhJzogNjUsXG4gICAgICAnYic6IDY2LFxuICAgICAgJ2MnOiA2NyxcbiAgICAgICdkJzogNjgsXG4gICAgICAnZSc6IDY5LFxuICAgICAgJ2YnOiA3MCxcbiAgICAgICdnJzogNzEsXG4gICAgICAnaCc6IDcyLFxuICAgICAgJ2knOiA3MyxcbiAgICAgICdqJzogNzQsXG4gICAgICAnayc6IDc1LFxuICAgICAgJ2wnOiA3NixcbiAgICAgICdtJzogNzcsXG4gICAgICAnbic6IDc4LFxuICAgICAgJ28nOiA3OSxcbiAgICAgICdwJzogODAsXG4gICAgICAncSc6IDgxLFxuICAgICAgJ3InOiA4MixcbiAgICAgICdzJzogODMsXG4gICAgICAndCc6IDg0LFxuICAgICAgJ3UnOiA4NSxcbiAgICAgICd2JzogODYsXG4gICAgICAndyc6IDg3LFxuICAgICAgJ3gnOiA4OCxcbiAgICAgICd5JzogODksXG4gICAgICAneic6IDkwLFxuICAgICAgJ251bXBhZDAnOiA5NixcbiAgICAgICdudW1wYWQxJzogOTcsXG4gICAgICAnbnVtcGFkMic6IDk4LFxuICAgICAgJ251bXBhZDMnOiA5OSxcbiAgICAgICdudW1wYWQ0JzogMTAwLFxuICAgICAgJ251bXBhZDUnOiAxMDEsXG4gICAgICAnbnVtcGFkNic6IDEwMixcbiAgICAgICdudW1wYWQ3JzogMTAzLFxuICAgICAgJ251bXBhZDgnOiAxMDQsXG4gICAgICAnbnVtcGFkOSc6IDEwNSxcbiAgICAgICdtdWx0aXBseSc6IDEwNixcbiAgICAgICdwbHVzJzogMTA3LFxuICAgICAgJ21pbnV0JzogMTA5LFxuICAgICAgJ2RvdCc6IDExMCxcbiAgICAgICdzbGFzaDEnOiAxMTEsXG4gICAgICAnRjEnOiAxMTIsXG4gICAgICAnRjInOiAxMTMsXG4gICAgICAnRjMnOiAxMTQsXG4gICAgICAnRjQnOiAxMTUsXG4gICAgICAnRjUnOiAxMTYsXG4gICAgICAnRjYnOiAxMTcsXG4gICAgICAnRjcnOiAxMTgsXG4gICAgICAnRjgnOiAxMTksXG4gICAgICAnRjknOiAxMjAsXG4gICAgICAnRjEwJzogMTIxLFxuICAgICAgJ0YxMSc6IDEyMixcbiAgICAgICdGMTInOiAxMjMsXG4gICAgICAnZXF1YWwnOiAxODcsXG4gICAgICAnY29tYSc6IDE4OCxcbiAgICAgICdzbGFzaCc6IDE5MSxcbiAgICAgICdiYWNrc2xhc2gnOiAyMjBcbiAgICB9O1xuICAgIGJvdW5kID0ge307XG4gICAgaGFuZGxlciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciBiLCBrZXluYW1lO1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZS5wb3NpdGlvbiA9IHV0aWxzLmdldE1vdXNlUG9zaXRpb24oZSk7XG4gICAgICBiID0gYm91bmRbZS50eXBlXTtcbiAgICAgIGlmICghYikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKGtleW5hbWUgaW4gYikge1xuICAgICAgICBpZiAoa2V5W2tleW5hbWVdID09PSBlLndoaWNoKSB7XG4gICAgICAgICAgYltrZXluYW1lXS5jYWxsYmFjay5jYWxsKGJba2V5bmFtZV0sIGUsIGJba2V5bmFtZV0uZGF0YSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBtb3VzZW1vdmVIYW5kbGVyID0gZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIGIsIGRhdGE7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBlLnBvc2l0aW9uID0gdXRpbHMuZ2V0TW91c2VQb3NpdGlvbihlKTtcbiAgICAgIGIgPSBib3VuZFtcIm1vdXNlbW92ZVwiXTtcbiAgICAgIGRhdGEgPSBiLmRhdGEgfHwge307XG4gICAgICBiLmNhbGxiYWNrLmNhbGwocGFyZW50LCBlLCBkYXRhKTtcbiAgICB9O1xuICAgIHRoaXMuYmluZCA9IHRoaXMub24gPSBmdW5jdGlvbihldmVudHMsIGtleW5hbWUsIGNhbGxiYWNrLCBkYXRhKSB7XG4gICAgICB2YXIgYiwgZXZlbnRUeXBlLCBfZXZlbnRzLCBfaSwgX2xlbjtcbiAgICAgIGlmICghKGFyZ3VtZW50cy5sZW5ndGggPj0gMikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgX2V2ZW50cyA9IGV2ZW50cy5zcGxpdChcIiBcIik7XG4gICAgICBpZiAoX2V2ZW50c1swXSA9PT0gXCJtb3VzZW1vdmVcIikge1xuICAgICAgICBib3VuZFtcIm1vdXNlbW92ZVwiXSA9IHtcbiAgICAgICAgICBcImNhbGxiYWNrXCI6IGtleW5hbWUsXG4gICAgICAgICAgXCJkYXRhXCI6IGNhbGxiYWNrXG4gICAgICAgIH07XG4gICAgICAgICRlbC5vbihcIm1vdXNlbW92ZVwiLCBtb3VzZW1vdmVIYW5kbGVyKTtcbiAgICAgIH1cbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX2V2ZW50cy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBldmVudFR5cGUgPSBfZXZlbnRzW19pXTtcbiAgICAgICAgYiA9IGJvdW5kW2V2ZW50VHlwZV0gPSBib3VuZFtldmVudFR5cGVdIHx8IHt9O1xuICAgICAgICBiW2tleW5hbWVdID0ge1xuICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgIH07XG4gICAgICAgICRlbC5vbihldmVudFR5cGUsIGhhbmRsZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICB0aGlzLnVuYmluZCA9IHRoaXMub2ZmID0gZnVuY3Rpb24oZXZlbnRzLCBrZXluYW1lKSB7XG4gICAgICB2YXIgZXZlbnRUeXBlLCBfZXZlbnRzLCBfaSwgX2xlbjtcbiAgICAgIF9ldmVudHMgPSBldmVudHMuc3BsaXQoXCIgXCIpO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfZXZlbnRzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGV2ZW50VHlwZSA9IF9ldmVudHNbX2ldO1xuICAgICAgICAkZWwub2ZmKGV2ZW50VHlwZSwgaGFuZGxlcik7XG4gICAgICAgIGRlbGV0ZSBib3VuZFtldmVudFR5cGVdW2tleW5hbWVdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICB0aGlzLnRyaWdnZXIgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgJGVsLnRyaWdnZXIoZXZlbnQpO1xuICAgICAgcmV0dXJuIGJvdW5kW2V2ZW50XTtcbiAgICB9O1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzLk1vdXNlRGV0ZWN0aW9uID0gZnVuY3Rpb24ocGFyZW50LCBlbmdpbmUsIG11bHRpc2VsZWN0LCBjbGVhckFmdGVyRW1wdHlTZWxlY3Rpb24pIHtcbiAgICB2YXIgY2FtZXJhLCBjbGlja0hhbmRsZXIsIGVuYWJsZWQsIGhhbmRsZXIsIGlucHV0LCBsYXN0Q2xpY2tJbnRlcnNlY3QsIGxhc3RIb3ZlckludGVyc2VjdCwgbW91c2Vtb3ZlSGFuZGxlciwgcHJvamVjdG9yLCBzZWxlY3RlZE9iamVjdHMsIHN0YWdlLCB0aGF0O1xuICAgIGlmIChtdWx0aXNlbGVjdCA9PSBudWxsKSB7XG4gICAgICBtdWx0aXNlbGVjdCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoY2xlYXJBZnRlckVtcHR5U2VsZWN0aW9uID09IG51bGwpIHtcbiAgICAgIGNsZWFyQWZ0ZXJFbXB0eVNlbGVjdGlvbiA9IGZhbHNlO1xuICAgIH1cbiAgICBlbmFibGVkID0gZmFsc2U7XG4gICAgc3RhZ2UgPSBwYXJlbnQ7XG4gICAgaW5wdXQgPSBwYXJlbnQuSW5wdXQ7XG4gICAgY2FtZXJhID0gcGFyZW50LmNhbWVyYTtcbiAgICBwcm9qZWN0b3IgPSBuZXcgVEhSRUUuUHJvamVjdG9yKCk7XG4gICAgdGhpcy5pbnRlcnNlY3Rpb25zID0gbnVsbDtcbiAgICBsYXN0SG92ZXJJbnRlcnNlY3QgPSBudWxsO1xuICAgIGxhc3RDbGlja0ludGVyc2VjdCA9IG51bGw7XG4gICAgc2VsZWN0ZWRPYmplY3RzID0gW107XG4gICAgdGhhdCA9IHRoaXM7XG4gICAgdGhpcy5tb3VzZW1vdmUgPSB0cnVlO1xuICAgIHRoaXMuY2xpY2sgPSB0cnVlO1xuICAgIHRoaXMubXVsdGlzZWxlY3QgPSBtdWx0aXNlbGVjdDtcbiAgICB0aGlzLmNsZWFyQWZ0ZXJFbXB0eVNlbGVjdGlvbiA9IGNsZWFyQWZ0ZXJFbXB0eVNlbGVjdGlvbjtcbiAgICB0aGlzLmdldEludGVyc2VjdGlvbnMgPSBmdW5jdGlvbihtb3VzZSwgY2FtZXJhKSB7XG4gICAgICB2YXIgZGlyZWN0aW9uLCBpbnRlcnNlY3Rpb25zLCByYXljYXN0ZXIsIHZlY3RvcjtcbiAgICAgIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKG1vdXNlLm5vcm1hbGl6ZWQueCwgbW91c2Uubm9ybWFsaXplZC55LCAxKTtcbiAgICAgIHByb2plY3Rvci51bnByb2plY3RWZWN0b3IodmVjdG9yLCBjYW1lcmEpO1xuICAgICAgZGlyZWN0aW9uID0gdmVjdG9yLnN1YihjYW1lcmEucG9zaXRpb24pLm5vcm1hbGl6ZSgpO1xuICAgICAgcmF5Y2FzdGVyID0gbmV3IFRIUkVFLlJheWNhc3RlcihjYW1lcmEucG9zaXRpb24sIGRpcmVjdGlvbik7XG4gICAgICBpbnRlcnNlY3Rpb25zID0gcmF5Y2FzdGVyLmludGVyc2VjdE9iamVjdHMoc3RhZ2UubWVzaGVzKTtcbiAgICAgIHJldHVybiBpbnRlcnNlY3Rpb25zO1xuICAgIH07XG4gICAgaGFuZGxlciA9IGZ1bmN0aW9uKGUsIGNhbWVyYSkge1xuICAgICAgdmFyIGludGVyc2VjdGlvbnMsIG1vdXNlO1xuICAgICAgbW91c2UgPSBlLnBvc2l0aW9uO1xuICAgICAgaW50ZXJzZWN0aW9ucyA9IHRoYXQuZ2V0SW50ZXJzZWN0aW9ucyhtb3VzZSwgY2FtZXJhKTtcbiAgICAgIGlmIChlLnR5cGUgPT09IFwibW91c2Vtb3ZlXCIpIHtcbiAgICAgICAgaWYgKHRoYXQubW91c2Vtb3ZlICE9PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG1vdXNlbW92ZUhhbmRsZXIoaW50ZXJzZWN0aW9ucywgbW91c2UsIGNhbWVyYSwgZSk7XG4gICAgICB9IGVsc2UgaWYgKGUudHlwZSA9PT0gXCJjbGlja1wiKSB7XG4gICAgICAgIGlmICh0aGF0LmNsaWNrICE9PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNsaWNrSGFuZGxlcihpbnRlcnNlY3Rpb25zLCBtb3VzZSwgY2FtZXJhLCBlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlO1xuICAgIH07XG4gICAgbW91c2Vtb3ZlSGFuZGxlciA9IGZ1bmN0aW9uKGludGVyc2VjdGlvbnMsIG1vdXNlLCBjYW1lcmEsIGUpIHtcbiAgICAgIHZhciBpbnRlcnNlY3Q7XG4gICAgICBpZiAoaW50ZXJzZWN0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWYgKGxhc3RIb3ZlckludGVyc2VjdCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsYXN0SG92ZXJJbnRlcnNlY3QuZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgdHlwZTogXCJsZWF2ZVwiXG4gICAgICAgIH0pO1xuICAgICAgICBsYXN0SG92ZXJJbnRlcnNlY3QgPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpbnRlcnNlY3QgPSBpbnRlcnNlY3Rpb25zWzBdLm9iamVjdDtcbiAgICAgIGludGVyc2VjdC5kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgdHlwZTogXCJob3ZlclwiXG4gICAgICB9KTtcbiAgICAgIGlmIChsYXN0SG92ZXJJbnRlcnNlY3QgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGxhc3RIb3ZlckludGVyc2VjdCA9IGludGVyc2VjdDtcbiAgICAgIH0gZWxzZSBpZiAobGFzdEhvdmVySW50ZXJzZWN0ICE9PSBpbnRlcnNlY3QpIHtcbiAgICAgICAgbGFzdEhvdmVySW50ZXJzZWN0LmRpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgIHR5cGU6IFwibGVhdmVcIlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGxhc3RIb3ZlckludGVyc2VjdCA9IGludGVyc2VjdDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNsaWNrSGFuZGxlciA9IGZ1bmN0aW9uKGludGVyc2VjdGlvbnMsIG1vdXNlLCBjYW1lcmEsIGUpIHtcbiAgICAgIC8qIGRlYWwgd2l0aCB0aGluZ3MgdGhhdCB3ZXJlbid0IHNlbGVjdGVkXG4gICAgICAqL1xuXG4gICAgICB2YXIgaW50ZXJzZWN0O1xuICAgICAgaWYgKGludGVyc2VjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlmIChsYXN0Q2xpY2tJbnRlcnNlY3QgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoYXQuY2xlYXJBZnRlckVtcHR5U2VsZWN0aW9uID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGF0LmNsZWFyKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGludGVyc2VjdCA9IGludGVyc2VjdGlvbnNbMF0ub2JqZWN0O1xuICAgICAgaW50ZXJzZWN0LmRpc3BhdGNoRXZlbnQoe1xuICAgICAgICB0eXBlOiBcImNsaWNrXCJcbiAgICAgIH0pO1xuICAgICAgaWYgKGxhc3RDbGlja0ludGVyc2VjdCA9PT0gbnVsbCkge1xuICAgICAgICBsYXN0Q2xpY2tJbnRlcnNlY3QgPSBpbnRlcnNlY3Q7XG4gICAgICAgIHNlbGVjdGVkT2JqZWN0cy5wdXNoKGludGVyc2VjdCk7XG4gICAgICB9IGVsc2UgaWYgKGxhc3RDbGlja0ludGVyc2VjdCAhPT0gaW50ZXJzZWN0KSB7XG4gICAgICAgIGlmICh0aGF0Lm11bHRpc2VsZWN0ID09PSBmYWxzZSkge1xuICAgICAgICAgIGxhc3RDbGlja0ludGVyc2VjdC5kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgIHR5cGU6IFwiY2xlYXJcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RDbGlja0ludGVyc2VjdCA9IGludGVyc2VjdDtcbiAgICAgICAgc2VsZWN0ZWRPYmplY3RzLnB1c2goaW50ZXJzZWN0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGVjdGVkT2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIHJldHVybiBlbC5kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICB0eXBlOiBcImNsZWFyXCJcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHNlbGVjdGVkT2JqZWN0cyA9IFtdO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICB0aGlzLnRvZ2dsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5hYmxlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLm9mZiA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICBpbnB1dC5vZmYoXCJtb3VzZW1vdmVcIiwgaGFuZGxlciwgY2FtZXJhKTtcbiAgICAgICAgaW5wdXQub2ZmKFwiY2xpY2tcIiwgaGFuZGxlciwgY2FtZXJhKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMub24gPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgICBlbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgaW5wdXQub24oXCJtb3VzZW1vdmVcIiwgaGFuZGxlciwgY2FtZXJhKTtcbiAgICAgICAgaW5wdXQub24oXCJjbGlja1wiLCBcImxlZnRDbGlja1wiLCBoYW5kbGVyLCBjYW1lcmEpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5vbigpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG59KS5jYWxsKHRoaXMpO1xuXG4vLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNS4wLXByZVxuIiwiKGZ1bmN0aW9uKCkge1xuICB2YXIgQmFja2dyb3VuZFBsYW5lLCBMb3dQb2x5VGVycmFpbiwgU2VsZWN0b3IsIHV0aWxzLFxuICAgIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LFxuICAgIF9fZXh0ZW5kcyA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoX19oYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9O1xuXG4gIHV0aWxzID0gcmVxdWlyZShcIi4vX3V0aWxzXCIpO1xuXG4gIG1vZHVsZS5leHBvcnRzLlNlbGVjdG9yID0gU2VsZWN0b3IgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG5cbiAgICBfX2V4dGVuZHMoU2VsZWN0b3IsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBTZWxlY3RvcihvcHRpb25zLCBzY2VuZSkge1xuICAgICAgdmFyIG51bWJlciwgdGhhdDtcbiAgICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcbiAgICAgIGlmICghKG9wdGlvbnMuc2l6ZSAmJiBvcHRpb25zLnBvc2l0aW9uKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMuc2l6ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBudW1iZXIgPSBvcHRpb25zLnNpemU7XG4gICAgICB9XG4gICAgICB0aGlzLnBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICAgICAgdGhpcy5wb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKG9wdGlvbnMucG9zaXRpb24ueCwgb3B0aW9ucy5wb3NpdGlvbi55LCBvcHRpb25zLnBvc2l0aW9uLnopO1xuICAgICAgdGhpcy5nZW9tZXRyeSA9IG5ldyBUSFJFRS5Cb3hHZW9tZXRyeShvcHRpb25zLnNpemUueCwgb3B0aW9ucy5zaXplLnksIG9wdGlvbnMuc2l6ZS56KTtcbiAgICAgIHRoaXMuaXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5kaXNhYmxlSG92ZXIgPSBmYWxzZTtcbiAgICAgIC8qXG4gICAgICBcbiAgICAgICAgZXZlbnRNYXRlcmlhbHMgaXMgYSBoYXNoIG9mIHRoZSBkaWZmZXJlbnQgc3RhdGVzLCBuYW1lZCBiYXNlZCBvbiB0aGUgZXZlbnQgdHJpZ2dlcmVkXG4gICAgICAqL1xuXG4gICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IFwiZGVmYXVsdFwiO1xuICAgICAgdGhpcy5tZXNoID0gbmV3IFRIUkVFLk1lc2godGhpcy5nZW9tZXRyeSwgdGhpcy5ldmVudE1hdGVyaWFsc1tcImRlZmF1bHRcIl0pO1xuICAgICAgdGhpcy5tZXNoLnBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgIHRoaXMubWVzaC53cmFwcGVyID0gdGhpcztcbiAgICAgIHRoYXQgPSB0aGlzO1xuICAgICAgdGhpcy5tZXNoLmFkZEV2ZW50TGlzdGVuZXIoXCJob3ZlclwiLCB0aGF0Ll9ob3Zlcik7XG4gICAgICB0aGlzLm1lc2guYWRkRXZlbnRMaXN0ZW5lcihcImxlYXZlXCIsIHRoYXQuX2xlYXZlKTtcbiAgICAgIHRoaXMubWVzaC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhhdC5fY2xpY2spO1xuICAgICAgdGhpcy5tZXNoLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGVhclwiLCB0aGF0Ll9jbGVhcik7XG4gICAgICBpZiAodGhpcy5zY2VuZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXMuYWRkVG9TY2VuZSh0aGlzLnNjZW5lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBTZWxlY3Rvci5wcm90b3R5cGUuZXZlbnRNYXRlcmlhbHMgPSB7XG4gICAgICBcImRlZmF1bHRcIjogbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsXG4gICAgICAgIGNvbG9yOiAweDQ0NDQ1NSxcbiAgICAgICAgd2lyZWZyYW1lOiBmYWxzZVxuICAgICAgfSksXG4gICAgICBcImhvdmVyXCI6IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7XG4gICAgICAgIG9wYWNpdHk6IDAuNDUsXG4gICAgICAgIHRyYW5zcGFyZW50OiB0cnVlXG4gICAgICB9KSxcbiAgICAgIFwiY2xpY2tcIjogbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAgICAgICAgY29sb3I6IDB4Y2NjY2NjXG4gICAgICB9KSxcbiAgICAgIFwibGVhdmVcIjogbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAgICAgICAgY29sb3I6IDB4MDBjYzk5XG4gICAgICB9KSxcbiAgICAgIFwicmFuZ2VcIjogbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAgICAgICAgY29sb3I6IDB4MDAzM2FhXG4gICAgICB9KSxcbiAgICAgIFwicmFuZ2UtaG92ZXJcIjogbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAgICAgICAgY29sb3I6IDB4YWE0NDQ0XG4gICAgICB9KVxuICAgIH07XG5cbiAgICBTZWxlY3Rvci5wcm90b3R5cGUuYWRkVG9TY2VuZSA9IGZ1bmN0aW9uKHNjZW5lKSB7XG4gICAgICB0aGlzLnNjZW5lID0gc2NlbmU7XG4gICAgICByZXR1cm4gc2NlbmUuYWRkKHRoaXMubWVzaCk7XG4gICAgfTtcblxuICAgIC8qICBUaGUgbWV0aG9kIHRvIHByb3BvZ2F0ZSBldmVudHMgdXB3YXJkcyB0byB0aGUgU2VsZWN0aW9uR3JpZFxuICAgICovXG5cblxuICAgIFNlbGVjdG9yLnByb3RvdHlwZS5jYWxsU3VwZXJFdmVudCA9IGZ1bmN0aW9uKG5hbWUsIGFyZ3MpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC50cmlnZ2VyKG5hbWUsIGFyZ3MpO1xuICAgIH07XG5cbiAgICAvKiB1c2UgY2hhbmdlTWF0ZXJpYWxTdGF0ZSB0byBjaGFuZ2UgdGhlIG1hdGVyaWFsIGFwcGVhcmFuY2VcbiAgICAqL1xuXG5cbiAgICBTZWxlY3Rvci5wcm90b3R5cGUuY2hhbmdlTWF0ZXJpYWxTdGF0ZSA9IGZ1bmN0aW9uKG5hbWUsIGRpc2FibGVIb3Zlcikge1xuICAgICAgaWYgKGRpc2FibGVIb3ZlciA9PSBudWxsKSB7XG4gICAgICAgIGRpc2FibGVIb3ZlciA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpcy5tZXNoLmRpc2FibGVIb3ZlciA9IGRpc2FibGVIb3ZlcjtcbiAgICAgIHRoaXMubWVzaC5pc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IG5hbWU7XG4gICAgICByZXR1cm4gdGhpcy5tZXNoLm1hdGVyaWFsID0gdGhpcy5ldmVudE1hdGVyaWFsc1tuYW1lXSB8fCB0aGlzLmV2ZW50TWF0ZXJpYWxzW1wiZGVmYXVsdFwiXTtcbiAgICB9O1xuXG4gICAgU2VsZWN0b3IucHJvdG90eXBlLnJlc2V0TWF0ZXJpYWwgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZGlzYWJsZUhvdmVyID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcy5jaGFuZ2VNYXRlcmlhbFN0YXRlKFwiZGVmYXVsdFwiKTtcbiAgICB9O1xuXG4gICAgLyogc3BlY2lmaWMgZXZlbnQgcmVzcG9uc2VzXG4gICAgKi9cblxuXG4gICAgU2VsZWN0b3IucHJvdG90eXBlLl9ob3ZlciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmICh0aGlzLndyYXBwZXIuY3VycmVudFN0YXRlID09PSBcInJhbmdlXCIpIHtcbiAgICAgICAgdGhpcy5tYXRlcmlhbCA9IHRoaXMud3JhcHBlci5ldmVudE1hdGVyaWFsc1tcInJhbmdlLWhvdmVyXCJdO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZGlzYWJsZUhvdmVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMud3JhcHBlci50cmlnZ2VyKGUudHlwZSk7XG4gICAgICB0aGlzLndyYXBwZXIuY2FsbFN1cGVyRXZlbnQuY2FsbCh0aGlzLndyYXBwZXIsIGUudHlwZSwgW3RoaXMud3JhcHBlcl0pO1xuICAgICAgaWYgKHRoaXMuaXNTZWxlY3RlZCA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLm1hdGVyaWFsID0gdGhpcy53cmFwcGVyLmV2ZW50TWF0ZXJpYWxzLmhvdmVyO1xuICAgICAgcmV0dXJuIHRoaXMud3JhcHBlci5jdXJyZW50U3RhdGUgPSBlLnR5cGU7XG4gICAgfTtcblxuICAgIFNlbGVjdG9yLnByb3RvdHlwZS5fbGVhdmUgPSBmdW5jdGlvbihlKSB7XG4gICAgICB0aGlzLndyYXBwZXIudHJpZ2dlcihlLnR5cGUpO1xuICAgICAgdGhpcy53cmFwcGVyLmNhbGxTdXBlckV2ZW50LmNhbGwodGhpcy53cmFwcGVyLCBlLnR5cGUsIFt0aGlzLndyYXBwZXJdKTtcbiAgICAgIGlmICh0aGlzLndyYXBwZXIuY3VycmVudFN0YXRlID09PSBcInJhbmdlXCIpIHtcbiAgICAgICAgdGhpcy5tYXRlcmlhbCA9IHRoaXMud3JhcHBlci5ldmVudE1hdGVyaWFsc1tcInJhbmdlXCJdO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNTZWxlY3RlZCB8fCB0aGlzLmRpc2FibGVIb3ZlciB8fCB0aGlzLndyYXBwZXIuY3VycmVudFN0YXRlID09PSBcInJhbmdlXCIpIHtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tYXRlcmlhbCA9IHRoaXMud3JhcHBlci5ldmVudE1hdGVyaWFsc1tcImRlZmF1bHRcIl07XG4gICAgICAgIHJldHVybiB0aGlzLndyYXBwZXIuY3VycmVudFN0YXRlID0gZS50eXBlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBTZWxlY3Rvci5wcm90b3R5cGUuX2NsaWNrID0gZnVuY3Rpb24oZSkge1xuICAgICAgdGhpcy53cmFwcGVyLnRyaWdnZXIoZS50eXBlKTtcbiAgICAgIHRoaXMud3JhcHBlci5jYWxsU3VwZXJFdmVudC5jYWxsKHRoaXMud3JhcHBlciwgZS50eXBlLCBbdGhpcy53cmFwcGVyXSk7XG4gICAgICB0aGlzLmlzU2VsZWN0ZWQgPSAhdGhpcy5pc1NlbGVjdGVkO1xuICAgICAgaWYgKHRoaXMuaXNTZWxlY3RlZCkge1xuICAgICAgICB0aGlzLm1hdGVyaWFsID0gdGhpcy53cmFwcGVyLmV2ZW50TWF0ZXJpYWxzLmNsaWNrO1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwcGVyLmN1cnJlbnRTdGF0ZSA9IGUudHlwZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubWF0ZXJpYWwgPSB0aGlzLndyYXBwZXIuZXZlbnRNYXRlcmlhbHMuaG92ZXI7XG4gICAgICAgIHJldHVybiB0aGlzLndyYXBwZXIuY3VycmVudFN0YXRlID0gXCJob3ZlclwiO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBTZWxlY3Rvci5wcm90b3R5cGUuX2NsZWFyID0gZnVuY3Rpb24oZSkge1xuICAgICAgdGhpcy53cmFwcGVyLnRyaWdnZXIoZS50eXBlKTtcbiAgICAgIHRoaXMud3JhcHBlci5jYWxsU3VwZXJFdmVudC5jYWxsKHRoaXMud3JhcHBlciwgZS50eXBlLCBbdGhpcy53cmFwcGVyXSk7XG4gICAgICBpZiAodGhpcy53cmFwcGVyLmN1cnJlbnRTdGF0ZSA9IFwicmFuZ2VcIikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm1hdGVyaWFsID0gdGhpcy53cmFwcGVyLmV2ZW50TWF0ZXJpYWxzW1wiZGVmYXVsdFwiXTtcbiAgICAgICAgdGhpcy53cmFwcGVyLmN1cnJlbnRTdGF0ZSA9IFwiZGVmYXVsdFwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuaXNTZWxlY3RlZCA9IGZhbHNlO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2VsZWN0b3I7XG5cbiAgfSkodXRpbHMuRXZlbnRFbWl0dGVyKTtcblxuICBtb2R1bGUuZXhwb3J0cy5Ta3lib3ggPSBCYWNrZ3JvdW5kUGxhbmUgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICBmdW5jdGlvbiBCYWNrZ3JvdW5kUGxhbmUoKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIndvd1wiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gQmFja2dyb3VuZFBsYW5lO1xuXG4gIH0pKCk7XG5cbiAgbW9kdWxlLmV4cG9ydHMuTG93UG9seVRlcnJhaW4gPSBMb3dQb2x5VGVycmFpbiA9IChmdW5jdGlvbigpIHtcblxuICAgIGZ1bmN0aW9uIExvd1BvbHlUZXJyYWluKCkge1xuICAgICAgY29uc29sZS5sb2coXCJ3b3dcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIExvd1BvbHlUZXJyYWluO1xuXG4gIH0pKCk7XG5cbn0pLmNhbGwodGhpcyk7XG5cbi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS41LjAtcHJlXG4iLCJcbi8qXG5cbiAgU3RhZ2VzIGlzIGFuIG9iamVjdCB0byBtYW5hZ2UsIHdlbGwsIHN0YWdlcy5cbiAgd2hpY2ggYSBzdGFnZSBpcyB0aGUgZXF1aXZhbGVudCB0byB0aGUgZ2FtZSBjb25jZXB0IG9mIGEgJ2xldmVsLidcbiAgYnV0IHNvbWVvbmUgY291bGQgdXNlIG11bHRpcGxlIHN0YWdlcyBpbiBvbmUgbGV2ZWwsIHNvIEkgZG9uJ3Qgd2FudCB0byBiZSBwdXNoeSBhbmQgY2FsbCBpdCBhICdsZXZlbCcgbWFuYWdlclxuKi9cblxuXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBJbnB1dCwgU2VsZWN0aW9uR3JpZCwgU2VsZWN0b3IsIFN0YWdlLCBTdGFnZU1hbmFnZXIsIHV0aWxzLFxuICAgIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LFxuICAgIF9fZXh0ZW5kcyA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoX19oYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9O1xuXG4gIHV0aWxzID0gcmVxdWlyZShcIi4vX3V0aWxzXCIpO1xuXG4gIElucHV0ID0gcmVxdWlyZShcIi4vX2lucHV0XCIpO1xuXG4gIFNlbGVjdG9yID0gcmVxdWlyZShcIi4vX29iamVjdHNcIikuU2VsZWN0b3I7XG5cbiAgLypcbiAgICAgIFNlbGVjdGlvbkdyaWQgQ2xhc3NcbiAgICAgIEhlbHBlciBjbGFzcyBmb3Igc2VsZWN0aW5nIG9iamVjdHMgLyBlbnRpdGllcyBmcm9tIGEgZ3JpZFxuICAgICAgU2hvdWxkIGJlIGF1dG9tYXRpY2FsbHkgY3JlYXRlZCB3aGVuXG4gICovXG5cblxuICBTZWxlY3Rpb25HcmlkID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuXG4gICAgX19leHRlbmRzKFNlbGVjdGlvbkdyaWQsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBTZWxlY3Rpb25HcmlkKGRhdGEsIGVuZ2luZSwgc3RhZ2UpIHtcbiAgICAgIHZhciBjZW50ZXJJbmRleCwgZXZlbk9mZnNldCwgaG0sIG8sIHgsIHgwLCB6LCB6MCwgX3JlZjtcbiAgICAgIHRoaXMuZW5naW5lID0gZW5naW5lO1xuICAgICAgdGhpcy5zdGFnZSA9IHN0YWdlO1xuICAgICAgdGhpcy53aWR0aCA9IGRhdGEud2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IGRhdGEubGVuZ3RoO1xuICAgICAgdGhpcy5wYWRkaW5nID0gZGF0YS5wYWRkaW5nIHx8IDI7XG4gICAgICB0aGlzLnggPSBkYXRhLng7XG4gICAgICB0aGlzLnogPSBkYXRhLno7XG4gICAgICB0aGlzLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGxheVJhbmdlKHNlbGVjdG9yLCA1KTtcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgLyogQ29udmVydCB0aGUgZGF0YSBpbnRvIGEgbm9ybWFsaXplZCBncmlkIGRhdGFcbiAgICAgICovXG5cbiAgICAgIGV2ZW5PZmZzZXQgPSAoX3JlZiA9IHV0aWxzLmlzSW50KGRhdGEueCAvIDIpKSAhPSBudWxsID8gX3JlZiA6IHtcbiAgICAgICAgMDogMVxuICAgICAgfTtcbiAgICAgIHgwID0gfn4oZGF0YS54IC8gMik7XG4gICAgICB6MCA9IH5+KGRhdGEueiAvIDIpO1xuICAgICAgY2VudGVySW5kZXggPSBudWxsO1xuICAgICAgeCA9IC0xICogeDA7XG4gICAgICB6ID0gLTEgKiB6MDtcbiAgICAgIGhtID0gdXRpbHMuaXNBcnJheShkYXRhLmhlaWdodG1hcCkgPyBkYXRhLmhlaWdodG1hcCA6IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9pLCBfcmVmMSwgX3Jlc3VsdHM7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAobyA9IF9pID0gMSwgX3JlZjEgPSBkYXRhLnggKiBkYXRhLno7IDEgPD0gX3JlZjEgPyBfaSA8PSBfcmVmMSA6IF9pID49IF9yZWYxOyBvID0gMSA8PSBfcmVmMSA/ICsrX2kgOiAtLV9pKSB7XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaChkYXRhLmhlaWdodG1hcCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfSkoKTtcbiAgICAgIGRhdGEgPSBobS5tYXAoZnVuY3Rpb24oZWwsIGluZGV4LCBhcnIpIHtcbiAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgIG5vZGUgPSB7XG4gICAgICAgICAgXCJ6XCI6IHosXG4gICAgICAgICAgXCJ4XCI6IHgsXG4gICAgICAgICAgXCJ5XCI6IGVsLFxuICAgICAgICAgIFwiaWRcIjogaW5kZXhcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHggPT09IDAgJiYgeiA9PT0gMCkge1xuICAgICAgICAgIG5vZGUuY2VudGVyID0gdHJ1ZTtcbiAgICAgICAgICBjZW50ZXJJbmRleCA9IGluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmICh4ID09PSAoeDAgLSBldmVuT2Zmc2V0KSkge1xuICAgICAgICAgIHggPSAtMSAqIHgwO1xuICAgICAgICAgIHogKz0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4Kys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuY2VudGVySW5kZXggPSBjZW50ZXJJbmRleDtcbiAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICB0aGlzLmNyZWF0ZUdyaWQoKTtcbiAgICB9XG5cbiAgICBTZWxlY3Rpb25HcmlkLnByb3RvdHlwZS5jcmVhdGVHcmlkID0gZnVuY3Rpb24oc2hvd0hlbHBlcikge1xuICAgICAgdmFyIGRhdHVtLCBoLCBtYXRlcmlhbCwgcGFkZGluZywgcGFyZW50LCBwb3NpdGlvbiwgc2NlbmUsIHNlbGVjdG9yLCBzaXplLCB3LCBfaSwgX2xlbiwgX3JlZjtcbiAgICAgIGlmIChzaG93SGVscGVyID09IG51bGwpIHtcbiAgICAgICAgc2hvd0hlbHBlciA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5kYXRhID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zZWxlY3RvcnMgPSBbXTtcbiAgICAgIHcgPSB0aGlzLndpZHRoO1xuICAgICAgaCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgcGFkZGluZyA9IHRoaXMucGFkZGluZyB8fCAyO1xuICAgICAgcGFyZW50ID0gdGhpcztcbiAgICAgIF9yZWYgPSB0aGlzLmRhdGE7XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgZGF0dW0gPSBfcmVmW19pXTtcbiAgICAgICAgc2l6ZSA9IHtcbiAgICAgICAgICB4OiB3LFxuICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgejogd1xuICAgICAgICB9O1xuICAgICAgICBwb3NpdGlvbiA9IHtcbiAgICAgICAgICB4OiBkYXR1bS54ICogKHcgKyBwYWRkaW5nKSxcbiAgICAgICAgICB5OiBkYXR1bS55ICogKGggKyBwYWRkaW5nKSxcbiAgICAgICAgICB6OiBkYXR1bS56ICogKHcgKyBwYWRkaW5nKVxuICAgICAgICB9O1xuICAgICAgICBtYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWw7XG4gICAgICAgIHNjZW5lID0gdGhpcy5zdGFnZS5zY2VuZTtcbiAgICAgICAgc2VsZWN0b3IgPSBuZXcgU2VsZWN0b3Ioe1xuICAgICAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgICAgIHNpemU6IHNpemUsXG4gICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgICAgICAgIG1hdGVyaWFsOiBtYXRlcmlhbFxuICAgICAgICB9LCBzY2VuZSk7XG4gICAgICAgIGRhdHVtLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgIHNlbGVjdG9yLmRhdHVtID0gZGF0dW07XG4gICAgICAgIHRoaXMuc2VsZWN0b3JzLnB1c2goc2VsZWN0b3IpO1xuICAgICAgICB0aGlzLnN0YWdlLm1lc2hlcy5wdXNoKHNlbGVjdG9yLm1lc2gpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuaGVscGVyLmdyaWQuY2FsbCh0aGlzLCBzaG93SGVscGVyKTtcbiAgICB9O1xuXG4gICAgU2VsZWN0aW9uR3JpZC5wcm90b3R5cGUuZmlsdGVyRGF0YSA9IGZ1bmN0aW9uKHZlYzMpIHtcbiAgICAgIC8qXG4gICAgICAgIGFyZ3VtZW50ICd2ZWMzJyBjYW4gYmUgYW4gb2JqZWN0IG9yIGEgVEhSRUUuVmVjdG9yMyBpbnN0YW5jZVxuICAgICAgICAhIFZlY3RvcjMgaW5zdGFuY2VzIGRvbid0IGFsbG93IHlvdSB0byBoYXZlICd1bmRlZmluZWQnIGFzIGEgdmFsdWUsIHNvIHVzaW5nICcqJyBpcyB1c2VkXG4gICAgICAgIGllOiAgIGZpbHRlckRhdGEoIG5ldyBUSFJFRS5WZWN0b3IzKDAsIFwiKlwiLCBcIipcIikgKTtcbiAgICAgIFxuICAgICAgICBQbGFpbiBvYmplY3RzIGRvIGFsbG93IHVuZGVmaW5lZCB0aG91Z2gsIHNvIHlvdSBjYW4gcGFzcyBpbiBhbiBvYmplY3Qgd2l0aCBhbGwgdGhlIHZhbHVlcyB5b3Ugd2FudFxuICAgICAgICBpZTogICBmaWx0ZXJEYXRhKHsgeDogMn0pO1xuICAgICAgKi9cblxuICAgICAgdmFyIHJlc3VsdHM7XG4gICAgICBpZiAoIXZlYzMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuY29uY2F0KHRoaXMuZGF0YS5maWx0ZXIoZnVuY3Rpb24oZWwsIGksIGFycikge1xuICAgICAgICBpZiAoZWwueCA9PT0gdmVjMy54IHx8IHZlYzMueCA9PT0gXCIqXCIgfHwgdmVjMy54ID09PSB2b2lkIDApIHtcbiAgICAgICAgICBpZiAoZWwueSA9PT0gdmVjMy55IHx8IHZlYzMueSA9PT0gXCIqXCIgfHwgdmVjMy55ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGlmIChlbC56ID09PSB2ZWMzLnogfHwgdmVjMy56ID09PSBcIipcIiB8fCB2ZWMzLnogPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuXG4gICAgU2VsZWN0aW9uR3JpZC5wcm90b3R5cGUuZ2V0UmFuZ2UgPSBmdW5jdGlvbih2ZWMzLCBzdGVwcykge1xuICAgICAgdmFyIGNvdW50LCBnZXRTdGVwQ291bnQsIHJlc3VsdHMsIHgsIF9pLCBfbGVuLCBfcmVmO1xuICAgICAgaWYgKHN0ZXBzID09IG51bGwpIHtcbiAgICAgICAgc3RlcHMgPSA0O1xuICAgICAgfVxuICAgICAgZ2V0U3RlcENvdW50ID0gdXRpbHMuc3RlcHM7XG4gICAgICByZXN1bHRzID0gW107XG4gICAgICBfcmVmID0gdGhpcy5kYXRhO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIHggPSBfcmVmW19pXTtcbiAgICAgICAgY291bnQgPSBnZXRTdGVwQ291bnQodmVjMywgeCk7XG4gICAgICAgIGlmIChjb3VudCA8IHN0ZXBzICsgMSkge1xuICAgICAgICAgIHJlc3VsdHMucHVzaCh4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcblxuICAgIFNlbGVjdGlvbkdyaWQucHJvdG90eXBlLmdldFJhbmdlRnJvbVNlbGVjdG9yID0gZnVuY3Rpb24oc2VsZWN0b3IsIHN0ZXBzKSB7XG4gICAgICBpZiAoIShzZWxlY3RvciBpbnN0YW5jZW9mIFNlbGVjdG9yKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5nZXRSYW5nZShzZWxlY3Rvci5kYXR1bSwgc3RlcHMpO1xuICAgIH07XG5cbiAgICBTZWxlY3Rpb25HcmlkLnByb3RvdHlwZS5kaXNwbGF5UmFuZ2UgPSBmdW5jdGlvbihzZWxlY3Rvciwgc3RlcHMsIGNsZWFyT3RoZXJSYW5nZXMpIHtcbiAgICAgIHZhciBzZWxlY3RvcnM7XG4gICAgICBpZiAoY2xlYXJPdGhlclJhbmdlcyA9PSBudWxsKSB7XG4gICAgICAgIGNsZWFyT3RoZXJSYW5nZXMgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKCEoc2VsZWN0b3IgaW5zdGFuY2VvZiBTZWxlY3RvcikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGNsZWFyT3RoZXJSYW5nZXMpIHtcbiAgICAgICAgdGhpcy5jbGVhckFsbFJhbmdlcygpO1xuICAgICAgfVxuICAgICAgc2VsZWN0b3JzID0gdGhpcy5nZXRSYW5nZUZyb21TZWxlY3RvcihzZWxlY3Rvciwgc3RlcHMpO1xuICAgICAgcmV0dXJuIHNlbGVjdG9ycy5mb3JFYWNoKGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIHJldHVybiBlbC5zZWxlY3Rvci5jaGFuZ2VNYXRlcmlhbFN0YXRlLmNhbGwoZWwuc2VsZWN0b3IsIFwicmFuZ2VcIiwgdHJ1ZSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgU2VsZWN0aW9uR3JpZC5wcm90b3R5cGUuY2xlYXJBbGxSYW5nZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0eXBlO1xuICAgICAgdHlwZSA9IFwiZGVmYXVsdFwiO1xuICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0b3JzLmZvckVhY2goZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgcmV0dXJuIGVsLnJlc2V0TWF0ZXJpYWwuY2FsbChlbCwgdHlwZSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgU2VsZWN0aW9uR3JpZC5wcm90b3R5cGUuaGVscGVyID0ge1xuICAgICAgZ3JpZDogZnVuY3Rpb24ocmVtb3ZlKSB7XG4gICAgICAgIHZhciBncmlkLCBoZWlnaHQsIHBhZGRpbmcsIHNpemUsIHN0ZXAsIHdpZHRoO1xuICAgICAgICBpZiAocmVtb3ZlID09IG51bGwpIHtcbiAgICAgICAgICByZW1vdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZyh0aGlzKTtcbiAgICAgICAgcGFkZGluZyA9IHRoaXMucGFkZGluZztcbiAgICAgICAgd2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgICBoZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgICAgc2l6ZSA9ICgod2lkdGggKyBwYWRkaW5nKSAqIHRoaXMueCkgLyAyO1xuICAgICAgICBzdGVwID0gKHdpZHRoICsgaGVpZ2h0ICsgKHBhZGRpbmcgKiAyKSkgLyAyO1xuICAgICAgICBncmlkID0gbmV3IFRIUkVFLkdyaWRIZWxwZXIoc2l6ZSwgc3RlcCk7XG4gICAgICAgIHRoaXMuX2hlbHBlcmdyaWQgPSBncmlkO1xuICAgICAgICBncmlkLnNldENvbG9ycyhcIiMyMjRcIiwgXCIjMjI0XCIpO1xuICAgICAgICB0aGlzLnN0YWdlLnNjZW5lLmFkZChncmlkKTtcbiAgICAgICAgcmV0dXJuIGdyaWQ7XG4gICAgICB9LFxuICAgICAgcmFuZ2U6IGZ1bmN0aW9uKCkge31cbiAgICB9O1xuXG4gICAgcmV0dXJuIFNlbGVjdGlvbkdyaWQ7XG5cbiAgfSkodXRpbHMuRXZlbnRFbWl0dGVyKTtcblxuICBTdGFnZSA9IChmdW5jdGlvbihfc3VwZXIpIHtcblxuICAgIF9fZXh0ZW5kcyhTdGFnZSwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIFN0YWdlKHBhcmVudCwgbmFtZSwgb3B0aW9ucykge1xuICAgICAgdmFyIGJlZm9yZUxvYWRlZCwgY2FsbGJhY2tzLCBjYW1lcmEsIHRoYXQ7XG4gICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgIHRoaXMucmVuZGVyZXIgPSBwYXJlbnQucmVuZGVyZXI7XG4gICAgICB0aGlzLm5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICB0aGlzLnNjZW5lID0gb3B0aW9ucy5zY2VuZTtcbiAgICAgIGNhbWVyYSA9IG9wdGlvbnMuY2FtZXJhO1xuICAgICAgdGhpcy5jYW1lcmEgPSBjYW1lcmE7XG4gICAgICB0aGlzLm1lc2hlcyA9IFtdO1xuICAgICAgYmVmb3JlTG9hZGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIHRoaXMuSW5wdXQgPSBuZXcgSW5wdXQuSW50ZXJmYWNlKHRoaXMsIHBhcmVudCk7XG4gICAgICAgIHRoaXMuTW91c2VEZXRlY3RvciA9IG5ldyBJbnB1dC5Nb3VzZURldGVjdGlvbih0aGlzLCBwYXJlbnQpO1xuICAgICAgICByZXR1cm4gdGhpcy5vbmxvYWQuY2FsbCh0aGlzKTtcbiAgICAgIH07XG4gICAgICB0aGF0ID0gdGhpcztcbiAgICAgIHRoYXQub24oXCJsb2FkXCIsIGJlZm9yZUxvYWRlZC5iaW5kKHRoYXQpKTtcbiAgICAgIGNhbGxiYWNrcyA9IHtcbiAgICAgICAgc2NvcGU6IHRoYXQsXG4gICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKHJlc3BvbnNlVGV4dCkge1xuICAgICAgICAgIHRoYXQuZGF0YSA9IHJlc3BvbnNlVGV4dDtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIkVuZ2luZSA6OiAnXCIgKyBuYW1lICsgXCInIGFqYXgnZC4gXCIpO1xuICAgICAgICAgIHRoYXQuZGF0YS5ncmlkID0gdGhhdC5ncmlkID0gbmV3IFNlbGVjdGlvbkdyaWQodGhhdC5kYXRhLmdyaWQsIHRoYXQucGFyZW50LCB0aGF0KTtcbiAgICAgICAgICByZXR1cm4gdGhhdC50cmlnZ2VyKFwibG9hZFwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIHJldHJpZXZpbmcgZGF0YSBmb3IgU3RhZ2VcIik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAob3B0aW9ucy51cmwgIT09IHZvaWQgMCkge1xuICAgICAgICB1dGlscy5nZXRKU09OKG9wdGlvbnMudXJsLCBjYWxsYmFja3MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIFN0YWdlLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24odXJsVG9Kc29uKSB7XG4gICAgICAvKlxuICAgICAgICBpbmNhc2Ugd2Fzbid0IG9yaWdpbmFsbHkgcGFzc2VkIGluXG4gICAgICAqL1xuXG4gICAgICB2YXIgY2FsbGJhY2tzLCB0aGF0O1xuICAgICAgdGhhdCA9IHRoaXM7XG4gICAgICBjYWxsYmFja3MgPSB7XG4gICAgICAgIHNjb3BlOiB0aGF0LFxuICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihyZXNwb25zZVRleHQpIHtcbiAgICAgICAgICB0aGF0LmRhdGEgPSByZXNwb25zZVRleHQ7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJFbmdpbmUgOjogJ1wiICsgbmFtZSArIFwiJyBhamF4J2QuIFwiKTtcbiAgICAgICAgICB0aGF0LmRhdGEuZ3JpZCA9IHRoYXQuZ3JpZCA9IG5ldyBTZWxlY3Rpb25HcmlkKHRoYXQuZGF0YS5ncmlkLCB0aGF0LnBhcmVudCwgdGhhdCk7XG4gICAgICAgICAgcmV0dXJuIHRoYXQudHJpZ2dlcihcImxvYWRcIik7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciByZXRyaWV2aW5nIGRhdGEgZm9yIFN0YWdlXCIpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKHVybFRvSnNvbiAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiB1dGlscy5nZXRKU09OKHVybFRvSnNvbiwgY2FsbGJhY2tzKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgU3RhZ2UucHJvdG90eXBlLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgLypcbiAgICAgICAgbWVhbnQgdG8gYmUgb3ZlcndyaXR0ZW4gYnkgdGhlIHVzZXJcbiAgICAgICAgYWx0ZXJuYXRpdmUgaXM6IFxuICAgICAgICB8IEBvbiBcImxvYWRcIiwgZm5cbiAgICAgICAgd2hpY2ggd2lsbCBiZSB0cmlnZ2VyZWQgb24gbG9hZGluZ1xuICAgICAgKi9cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBTdGFnZS5wcm90b3R5cGUubG9va0F0ID0gZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgIHRoaXMuY2FtZXJhLnVwID0gbmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgMSk7XG4gICAgICByZXR1cm4gdGhpcy5jYW1lcmEubG9va0F0KHBvaW50IHx8IHRoaXMuc2NlbmUpO1xuICAgIH07XG5cbiAgICBTdGFnZS5wcm90b3R5cGUuc2V0Q2FtZXJhVG9Jc29tZXRyaWMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkaXN0YW5jZUZyb21DZW50ZXJvZkdyaWRUb0VkZ2UsIGgsIHcsIHgsIHhEaXN0YW5jZSwgeURpc3RhbmNlLCB6LCB6RGlzdGFuY2U7XG4gICAgICBpZiAoIXRoaXMuZ3JpZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB3ID0gdGhpcy5ncmlkLndpZHRoO1xuICAgICAgaCA9IHRoaXMuZ3JpZC5oZWlnaHQ7XG4gICAgICB4ID0gdGhpcy5ncmlkLng7XG4gICAgICB6ID0gdGhpcy5ncmlkLno7XG4gICAgICBkaXN0YW5jZUZyb21DZW50ZXJvZkdyaWRUb0VkZ2UgPSB1dGlscy5weXRoYWcodyAqIHgsIGggKiB6KTtcbiAgICAgIHlEaXN0YW5jZSA9IGRpc3RhbmNlRnJvbUNlbnRlcm9mR3JpZFRvRWRnZSAvIDI7XG4gICAgICB6RGlzdGFuY2UgPSAodyArICh0aGlzLmdyaWQucGFkZGluZyB8fCAyKSkgKiB6O1xuICAgICAgeERpc3RhbmNlID0gKHcgKyAodGhpcy5ncmlkLnBhZGRpbmcgfHwgMikpICogeDtcbiAgICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLnNldFooekRpc3RhbmNlKTtcbiAgICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLnNldFkoeURpc3RhbmNlKTtcbiAgICAgIHRoaXMuY2FtZXJhLnBvc2l0aW9uLnNldFgoeERpc3RhbmNlKTtcbiAgICAgIHRoaXMuY2FtZXJhLmxvb2tBdChuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAwKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICAgIC8qXG4gICAgICBcbiAgICAgIFxuICAgICAgQGNhbWVyYS5yb3RhdGlvbi56ID0gMC4yNVxuICAgICAgKi9cblxuICAgIH07XG5cbiAgICBTdGFnZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgTCwgZXh0ZW50LCBnZW9tZXRyeSwgbGluZSwgbWF0ZXJpYWw7XG4gICAgICBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuICAgICAgZXh0ZW50ID0gNTAwMDtcbiAgICAgIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2gobmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgLWV4dGVudCkpO1xuICAgICAgZ2VvbWV0cnkudmVydGljZXMucHVzaChuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCBleHRlbnQpKTtcbiAgICAgIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2gobmV3IFRIUkVFLlZlY3RvcjMoLWV4dGVudCwgMCwgMCkpO1xuICAgICAgZ2VvbWV0cnkudmVydGljZXMucHVzaChuZXcgVEhSRUUuVmVjdG9yMyhleHRlbnQsIDAsIDApKTtcbiAgICAgIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2gobmV3IFRIUkVFLlZlY3RvcjMoMCwgLWV4dGVudCwgMCkpO1xuICAgICAgZ2VvbWV0cnkudmVydGljZXMucHVzaChuZXcgVEhSRUUuVmVjdG9yMygwLCBleHRlbnQsIDApKTtcbiAgICAgIG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKHtcbiAgICAgICAgY29sb3I6IDB4NTU1NTU1XG4gICAgICB9KTtcbiAgICAgIGxpbmUgPSBuZXcgVEhSRUUuTGluZShnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICAgICAgdGhpcy5zY2VuZS5hZGQobGluZSk7XG4gICAgICB0aGlzLnNldENhbWVyYVRvSXNvbWV0cmljKCk7XG4gICAgICB0aGlzLnBhcmVudC5yZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpO1xuICAgICAgTCA9IHRoaXMucGFyZW50LmNsb2NrLmxvb3AoXCJyZW5kZXJcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5yZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpO1xuICAgICAgfSwgbnVsbCwgdGhpcyk7XG4gICAgICBMW1wiZm9yXCJdKHtcbiAgICAgICAgaW50ZXJ2YWw6IDE3XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5jbG9jay5zdGFydCgpO1xuICAgIH07XG5cbiAgICBTdGFnZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmRlc3Ryb3kodGhpcy5uYW1lKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFN0YWdlO1xuXG4gIH0pKHV0aWxzLkV2ZW50RW1pdHRlcik7XG5cbiAgU3RhZ2VNYW5hZ2VyID0gZnVuY3Rpb24oZW5naW5lKSB7XG4gICAgLyogQFBSSVZBVEVTXG4gICAgKi9cblxuICAgIHZhciBsaXN0LCBwYXJlbnQ7XG4gICAgcGFyZW50ID0gZW5naW5lO1xuICAgIC8qIEBQVUJMSUNTXG4gICAgKi9cblxuICAgIGxpc3QgPSB7fTtcbiAgICB0aGlzLmxpc3QgPSBbXTtcbiAgICB0aGlzLmNyZWF0ZSA9IGZ1bmN0aW9uKG5hbWUsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBvLCBzdGFnZTtcbiAgICAgIGlmICghbmFtZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBvID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIHN0YWdlID0gbmV3IFN0YWdlKHBhcmVudCwgbmFtZSwgbyk7XG4gICAgICB0aGlzLmxpc3QucHVzaChuYW1lKTtcbiAgICAgIGxpc3RbbmFtZS50b0xvd2VyQ2FzZSgpXSA9IHN0YWdlO1xuICAgICAgcmV0dXJuIGxpc3RbbmFtZS50b0xvd2VyQ2FzZSgpXTtcbiAgICB9O1xuICAgIHRoaXMuY3VycmVudCA9IHZvaWQgMDtcbiAgICB0aGlzLmRlc3Ryb3kgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICByZXR1cm4gZGVsZXRlIGxpc3RbbmFtZV07XG4gICAgfTtcbiAgICB0aGlzLmxvYWQgPSBmdW5jdGlvbihuYW1lLCB0cmFuc2l0aW9uKSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFN0YWdlTWFuYWdlcjtcblxufSkuY2FsbCh0aGlzKTtcblxuLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjUuMC1wcmVcbiIsIlxuLypcbiAgICAgIHV0aWxpdGllc1xuKi9cblxuXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBFdmVudEVtaXR0ZXIsXG4gICAgX19zbGljZSA9IFtdLnNsaWNlO1xuXG4gIG1vZHVsZS5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKG1zZykge1xuICAgIHZhciBwcmVmaXg7XG4gICAgdGhpcy5sb2dzLnVuc2hpZnQobXNnKTtcbiAgICBpZiAoIXRoaXMuZGVidWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcHJlZml4ID0gXCJFbmdpbmUgOjogXCI7XG4gICAgaWYgKHR5cGVvZiBtc2cgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnNvbGUubG9nKHByZWZpeCArIG1zZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKG1zZyk7XG4gICAgfVxuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBiYXNlLCBleHRlbmRlZCwga2V5LCBvYmosIG9ianMsIF9pLCBfbGVuO1xuICAgIG9ianMgPSAxIDw9IGFyZ3VtZW50cy5sZW5ndGggPyBfX3NsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSA6IFtdO1xuICAgIGlmIChvYmpzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybiBvYmpzWzBdO1xuICAgIH1cbiAgICBleHRlbmRlZCA9IG9ianNbMF07XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBvYmpzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICBvYmogPSBvYmpzW19pXTtcbiAgICAgIGJhc2UgPSBvYmo7XG4gICAgICBmb3IgKGtleSBpbiBiYXNlKSB7XG4gICAgICAgIGV4dGVuZGVkW2tleV0gPSBiYXNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBleHRlbmRlZDtcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cy5pc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbih0aGluZykge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGhpbmcgPT09IFwiW29iamVjdCBBcnJheV1cIik7XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMuaXNJbnQgPSBmdW5jdGlvbihudW0pIHtcbiAgICBpZiAobnVtIC8gTWF0aC5mbG9vcihudW0pID09PSAxIHx8IG51bSAvIE1hdGguZmxvb3IobnVtKSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMucHl0aGFnID0gZnVuY3Rpb24oQSwgQiwgaHlwb3RlbnVzZSkge1xuICAgIHZhciBhMiwgYjIsIHJlc3VsdDtcbiAgICBpZiAoIShhcmd1bWVudHMubGVuZ3RoID49IDIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChCID09PSBudWxsKSB7XG4gICAgICByZXN1bHQgPSAoTWF0aC5wb3coaHlwb3RlbnVzZSwgMikpIC0gTWF0aC5wb3coQSwgMik7XG4gICAgICByZXN1bHQgPSBNYXRoLnNxcnQocmVzdWx0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGEyID0gTWF0aC5wb3coQSwgMik7XG4gICAgICBiMiA9IE1hdGgucG93KEIsIDIpO1xuICAgICAgcmVzdWx0ID0gTWF0aC5zcXJ0KGEyICsgYjIpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMuc3RlcHMgPSBmdW5jdGlvbihiYXNlLCB0YXJnZXQsIHlBeGlzKSB7XG4gICAgdmFyIHgsIHksIHo7XG4gICAgaWYgKHlBeGlzID09IG51bGwpIHtcbiAgICAgIHlBeGlzID0gZmFsc2U7XG4gICAgfVxuICAgIHggPSBNYXRoLmFicyhiYXNlLnggLSB0YXJnZXQueCk7XG4gICAgeiA9IE1hdGguYWJzKGJhc2UueiAtIHRhcmdldC56KTtcbiAgICB5ID0geUF4aXMgPyBNYXRoLmFicyhiYXNlLnkgLSB0YXJnZXQueSkgOiAwO1xuICAgIHJldHVybiB4ICsgeSArIHo7XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMuZ2V0SlNPTiA9IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2tzKSB7XG4gICAgdmFyIGFqYXgsIGRhdGEsIG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IGNhbGxiYWNrcyB8fCB7fTtcbiAgICBkYXRhID0gdm9pZCAwO1xuICAgIGFqYXggPSAkLmdldEpTT04odXJsKTtcbiAgICByZXR1cm4gYWpheC5jb21wbGV0ZShmdW5jdGlvbigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRhdGEgPSAkLnBhcnNlSlNPTihhamF4LnJlc3BvbnNlVGV4dCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIG9wdGlvbnMuZXJyb3IuY2FsbChvcHRpb25zLnNjb3BlIHx8IG51bGwsIGUsIGFqYXgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBvcHRpb25zLnN1Y2Nlc3MuY2FsbChvcHRpb25zLnNjb3BlIHx8IG51bGwsIGRhdGEsIGFqYXgpO1xuICAgIH0pO1xuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzLmdldE1vdXNlUG9zaXRpb24gPSBmdW5jdGlvbigkZSkge1xuICAgIHZhciBub3JtYWxpemVkLCB4LCB5O1xuICAgIGlmICghKCRlLnR5cGUgPT09IFwiY2xpY2tcIiB8fCAkZS50eXBlID09PSBcIm1vdXNlbW92ZVwiKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB4ID0gJGUuY2xpZW50WDtcbiAgICB5ID0gJGUuY2xpZW50WTtcbiAgICBub3JtYWxpemVkID0ge1xuICAgICAgXCJ4XCI6ICh4IC8gd2luZG93LmlubmVyV2lkdGgpICogMiAtIDEsXG4gICAgICBcInlcIjogLSh5IC8gd2luZG93LmlubmVySGVpZ2h0KSAqIDIgKyAxXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogeCxcbiAgICAgIHk6IHksXG4gICAgICBub3JtYWxpemVkOiBub3JtYWxpemVkXG4gICAgfTtcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXIgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICBmdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gICAgICB0aGlzLl9fZXZlbnRzID0ge307XG4gICAgfVxuXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKG5hbWUsIGZuLCBjb250ZXh0KSB7XG4gICAgICBpZiAodGhpcy5fX2V2ZW50cyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXMuX19ldmVudHMgPSB7fTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19ldmVudHNbbmFtZV0gPSB7XG4gICAgICAgIGZuOiBmbixcbiAgICAgICAgY29udGV4dDogY29udGV4dFxuICAgICAgfTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9fZXZlbnRzW25hbWVdO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgaWYgKHRoaXMuX19ldmVudHMgPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fX2V2ZW50c1tuYW1lXTtcbiAgICB9O1xuXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24obmFtZSwgYXJncykge1xuICAgICAgdmFyIGY7XG4gICAgICBpZiAoYXJncyA9PSBudWxsKSB7XG4gICAgICAgIGFyZ3MgPSBbXTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9fZXZlbnRzID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZiA9IHRoaXMuZ2V0KG5hbWUpO1xuICAgICAgaWYgKGYgPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmLmZuLmFwcGx5KGYuY29udGV4dCwgYXJncyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlcjtcblxuICB9KSgpO1xuXG59KS5jYWxsKHRoaXMpO1xuXG4vLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNS4wLXByZVxuIiwiKGZ1bmN0aW9uKCkge1xuXG4gIHJlcXVpcmUoXCIuL19iYXNlXCIpO1xuXG4gIHJlcXVpcmUoXCIuL21haW5cIik7XG5cbn0pLmNhbGwodGhpcyk7XG5cbi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS41LjAtcHJlXG4iLCIoZnVuY3Rpb24oKSB7XG5cblxuXG59KS5jYWxsKHRoaXMpO1xuXG4vLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNS4wLXByZVxuIl19
