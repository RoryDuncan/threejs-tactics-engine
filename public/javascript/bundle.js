(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

/*
    three-js Tactics Engine
*/


(function() {
  var Clock, Stage, ThreeTacticsEngine, utils;

  console.log("_base");

  utils = require("./_utils");

  Stage = require("./_stage");

  Clock = require("./_clock");

  ThreeTacticsEngine = function() {
    /*
      @PRIVATES
    */

    var THREE, configLoaded, eventMethods, log, name, scene, that, _i, _len;
    if (self.THREE === void 0 || self.$ === void 0) {
      throw new Error("The engine is dependent on THREE.js and jQuery, which one of was not found, or not in the global scope.");
    }
    THREE = self.THREE;
    configLoaded = false;
    scene = false;
    that = this;
    this.debug = true;
    this.logs = [];
    log = (function(msg) {
      return utils.log.call(this, msg, this.logs);
    }).bind(this);
    this.log = log;
    /*
      @PUBLICS
    */

    this.load = function() {};
    this.renderQueue = [];
    this.stage = new Stage(this);
    this.clock = new Clock();
    /* 
      Dynamically add event methods from the clock object (which has an event emitter built into it.)
      this array is the names of the methods that will be added to the events object
    */

    eventMethods = ["on", "off", "defer", "getEvents", "trigger", "remove"];
    this.events = {};
    for (_i = 0, _len = eventMethods.length; _i < _len; _i++) {
      name = eventMethods[_i];
      this.events[name] = this.clock[name];
    }
    this.init = function(options) {
      var config;
      config = $.getJSON((options || {}).config);
      if (typeof config === void 0) {
        return;
      }
      that = this;
      return config.complete(function() {
        var renderer;
        try {
          that.config = $.parseJSON(config.responseText);
        } catch (e) {
          log(e);
          throw new Error("JSON was not parsed.");
        }
        configLoaded = true;
        log("Configuration Loaded.");
        renderer = new THREE.WebGLRenderer({
          antialias: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        that.renderer = renderer;
        log("Initialized.");
        if ((options || {}).autostart === true) {
          return that.start();
        }
      });
    };
    this.start = function() {
      var stage;
      if (!configLoaded) {
        return;
      }
      return stage = this.stage.create("test", {
        "url": "json/test.json",
        "camera": new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100000),
        "scene": new THREE.Scene()
      });
    };
    return this;
  };

  self.Engine = new ThreeTacticsEngine();

  Engine.init({
    "config": "json/config.json",
    "autostart": true
  });

  console.log(Engine);

}).call(this);

// Generated by CoffeeScript 1.5.0-pre

},{"./_clock":2,"./_stage":5,"./_utils":6}],2:[function(require,module,exports){

  /*
    Modified version from

    +-+- GITHUB -+-+
  unmodified version located at:
    https://github.com/RoryDuncan/ClockEventAggreggator
    
    +-+- DOCUMENTATION -+-+
    http://roryduncan.github.io/ClockEventAggreggator/

  */

var utils = require("./_utils");

var Clock = function(args) {

  /* Helpers */

  // Helper for merging objects
  extend = utils.extend;

  var isArray = function(thing){
    // assume 'thing' is not undefined or null as it will throw a TypeError.
    if (typeof thing === "string") return false;
    if ( (thing).length === undefined) return false;
    else return true; 
  }


  /*  Timeline related variables  */

  var defaults = {useRAF: true, tickInterval: 16, autostart: false},
      options = extend(defaults, args),
      ticks = 0,
      lastTick = 0,
      startTime = 0,

      // the 'clock' time, calculated with delta and clockSpeed variables.
      elapsedTime = 0,

      // id for requestAnimationFrame
      rAFID = null,

      // whether this is every other tick
      tick_n = false,

      // the amount of real-time that has passed between ticks
      delta = 0,
      actualElapsedTime = 0;

      // fallback time for setTimeout
      this.tickInterval = options.tickInterval,

      running = false,

      // speed at which the clock runs
      clockspeed = 1,

      // reference
      self = this,

      // wether or not to use request Animation Frame
      useRAF = options.useRAF,

      // dynamic function for rAF or setTimeout functionality,
      tickCallee = function() {
        // set to start() initially in case called before start somehow.
        this.start();
      };

      
      


  /*  Event Aggregator related variables  */

  var events = {};
      events.nominal = {};
      events.ordinal = {};
      events.loops = {};

  
  /*  Internal Functions */

  //  clock's tick mechanism
  var tick = function() {
    
    var now = new Date().getTime(); //cache
    if (!running) return;
    
    ticks += 1 * clockspeed;
    tick_n = !tick_n;
    if (this.debug && tick_n) this.log();

    
    this.delta = delta = (now - lastTick) * clockspeed;

    lastTick = now;

    elapsedTime += delta;

    actualElapsedTime = ( now - startTime );

    this.errorMargin = actualElapsedTime - elapsedTime; 


    // singular events take precedence over loop events.
    triggerCurrentEvents();
    triggerLoopEvents();

    this.trigger("tick");

    
    rAFID = tickCallee();

    return ticks;
  };
  
  var buildDefaultEvents = function() {

    var defaultEvents = ["tick", "start", "after:start", "pause", "resume"],
        addEvent = function(name){

          events.ordinal[name] = [];
        };

    defaultEvents.forEach(addEvent);

  };
  buildDefaultEvents();

  var triggerOrdinalEvents = function() {

    var now = ~~(elapsedTime / 100) * 100;

    if ( events.ordinal[ now ] === undefined ) {return false;}  // return false in case of checks

    
    var eot = events.ordinal[ now ];

    // events.ordinal will be an array, so loop over each function in it.
    for (var _x = 0, _xx = eot.length; _x < _xx; _x++) {

      var fn = eot[_x].fn,
          ctx = eot[_x].context,
          args = eot[_x].args;

      fn.apply(ctx, args);
    }

    // delete it, so that it won't trigger the next ticks that round down to this time.
    delete events.ordinal[ now ];

    return true; // return true in case of checks
  };

  var triggerLoopEvents = function() {

    var now = ~~elapsedTime;

    var expired = [];

    for (var key in events.loops) {

      var loop = events.loops[ key ]

      if (loop.start <= now &&          // Check if it is 'allowed' to start.
          loop.checkInterval( now ) &&  // Check whether the loop should fire at the current time
          loop.delete === false ) {      // Check if it is to be deleted
          
          // there is a reference to _this_ inside of loop,
          // so sending the loop itself as context is enough.
          loop.calledAt.push( now );
          loop.now = now;
          
          loop.fn.apply( loop.scope, loop.args );
          
          loop.lastCall = now;
          loop.calls++;
      }
      // check whether it has expired
      if (loop.stop === now || loop.calls === loop.maxIntervals || loop.delete === true) {
        // put it in the box where bad loops go.
        expired.push( key );
      }
    }

    // Delete any loops marked
    for (var i = 0, ii = expired.length; i < ii; i++) {
      var name = expired[i];
      delete events.loops[name];
    }
  };


  /*  Bindings  */

  this.tick = tick.bind(this);
  var triggerLoopEvents = triggerLoopEvents.bind(this);
  var  triggerCurrentEvents = triggerOrdinalEvents.bind(this);
  


  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
  /* * * * * * * * * * * * *   API   * * * * * * * * * * * * */
  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


  /*  Clock-related methods  */

  this.start = function() {

    if (running === true) { return this; } // simple tests to prevent multiple starts

    // tickLoop is a dynamically constructed function to remove an 'if' statement inside of tick() .
    var tickLoop;  

    if (useRAF === true) {
      tickLoop = new Function(" var id = window.requestAnimationFrame( this.tick ); return id;");
    }
    else {
      tickLoop = new Function(" var id = window.setTimeout(this.tick, this.tickInterval);return id;" );
    }
    // bind into this context
    tickCallee = tickLoop.bind(this);

    this.trigger("before:start");

    var now = new Date().getTime();
    this.startTime = startTime = now;
    running = true;
    lastTick = now;
    this.tick();

    this.enablePauseOnBlur();
    this.trigger("start");

    return this;
  }.bind(this);

  this.stop = function(){

    running = false;
    //reset event lists
    events.nominal = {};
    events.ordinal = [];
    events.loops = {};

    buildDefaultEvents();

    //reset counters
    ticks = 0;
    elapsedTime = 0;
    this.startTime = startTime = 0;

    return this;
  }.bind(this);

  this.reset = function(){

    this.reset();
    this.start();
    return this;
  }.bind(this);

  this.pause = function() {
    running = false;
    this.trigger("pause");
    return this;
  }.bind(this);

  this.resume = function() {
    if (running === true) return this;
    running = true;
    lastTick = new Date().getTime();
    this.tick();
    this.trigger("resume");
    return this;
  }.bind(this);

  this.clockScalar = function(multiplier) {
    // a relative way to affect the clock
    clockspeed *= multiplier || 1;
  };

  this.setClockSpeed = function(value) {
    // for manually entering a speed value
    clockspeed = value || clockspeed;
  };

  this.enablePauseOnBlur = function() {
    // called on start
    // requestAnimationFrame natively pauses onblur, but, this clock doesn't
    // so I've programmed the functionality into it. 

    window.onblur = function(){self.pause();}
    window.onfocus = function(){self.resume();};
  };

  this.disablePauseOnBlur = function(){
    window.onblur = function(){return null};
    window.onfocus = function(){return null};
  };
  
  this.ticks = function(){ return ticks; };

  this.milliseconds = function(){ return elapsedTime;};

  this.seconds = function(){ return elapsedTime / 1000 ; };

  this.minutes = function(){ return (this.seconds() / 60); };

  this.debug = options.debug || false;

  // if debug is true, log is automatically called each tick
  this.log = function() {

    console.clear();
    if (useRAF) console.log("<Using requestAnimationFrame>");
    else console.log("<Using setTimeout>");
    console.log("ticks:", ticks);
    console.log("delta:", delta);
    console.log("lastTick(should change)", ~~lastTick)
    console.log("elapsed time:", elapsedTime / 1000);
    console.log("elapsed seconds:", ~~(elapsedTime / 1000));
    console.log("actual elapsed time:", actualElapsedTime / 1000);
    console.warn("%cdifference (in seconds): " + (this.errorMargin / 1000), "color: #a00" );
    console.log("Ignore differences if you have called pause at any time.");
    console.log("Estimated FPS:", ~~(ticks / ( elapsedTime / 1000 )));
  };

  this.time = this.now = function(){ return elapsedTime; };



  /*  Event-related methods  */
  
  this.trigger = function(eventName) {

    if (events.nominal[eventName] === undefined) return this;

    var l = events.nominal[eventName].length

    for (var _x = 0, _xx = l; _x < _xx; _x++) {

      // wow, much length, many chars, such scary.
      var fn = events.nominal[eventName][_x].fn,
          ctx = events.nominal[eventName][_x].context,
          args = events.nominal[eventName][_x].args;

      fn.apply(ctx, args);

    }
    return this;
  };

  this.on = function( eventName, fn /* [, args, context ] */ ) {

    var context = arguments[3] || this, args = arguments[2] || [];

    // create an array for the event
    events.nominal[eventName] = events.nominal[eventName] || []

    var scope = this; // all events default to the scope of the Timeline object.

    events.nominal[eventName].push({
      'fn': fn,
      'args': args,
      'context': context
    });
    return this;
  };

  this.at = function( elapsedMS, fn /* [, args, context ] */ ) {
    if (elapsedMS === undefined) {throw new Error("at() method requires a clock-time passed in as first parameter."); return;}
    if (fn === undefined) {throw new Error("at() method requires a function passed in as second parameter."); return;}

    var context = arguments[3] || null, args = arguments[2] || this;

    var addTime = function( time ) {

      var t = time.toString();
      events.ordinal[ time ] = events.ordinal[ time ] || [];
      events.ordinal[ time ].push({
        "fn": fn,
        "context": context,
        "args": args
      });

    };

    if ( !isArray(elapsedMS) ) {
      addTime( elapsedMS );
      
      return this;

    }

      elapsedMS.forEach( addTime );


      return this;
  };

  this.after = function( milliseconds, fn /* [, args, context ] */ ) {
    var args = arguments[2], context = arguments[3];
    this.at( elapsedTime + milliseconds, fn, args, context );
  };

  this.loop = function( uniqueName, fn, args, scope ) {

    /*
        this.loop() returns a new loop object, which to alter timing-related options
        you call it's .for() method. 
        
        EX:
        var x = this.loop(*args).for(*args);
    */

    if (!uniqueName) return this;

    var self = this,
        defaults = {
          "autostart": true,
          "start": ~~elapsedTime,
          "stop": Infinity, 
          "interval": Infinity, 
          "maxIntervals": Infinity, 
          "duration": 0, 
          "calledAt": [],
          "startDelay": 0
        },
        required = {
          "name":uniqueName,
          "fn": fn,
          "scope": scope || self,
          "calls": 0,
          "parent": self,
          "args": args || []
        };

    // the loop object that will be returned
    var Loop = function(options) {


      extend(this, defaults, required);

      // the check to determine if the loop is called
      this.checkInterval = function(now) {
        var start = this.start,
            interval = this.interval,
            duration = this.duration,
            doesIntervalMatchNow = (now - (start + this.startDelay))  % (interval + duration),
            intervalHasPassed = now - (this.lastCall === undefined ? start : this.lastCall);
  
        /*
        console.clear();
        console.log("name:", this.name);
        console.log("Delta:", self.delta );
        console.log("-----");
        console.log("start:", start);
        console.log("doesIntervalMatchNow", doesIntervalMatchNow);
        console.log("interval:", interval);
        console.log("now:", now);
        console.log("lastCall'ed:", this.lastCall);
        */
        
        if ( doesIntervalMatchNow >= 0 && doesIntervalMatchNow <= delta && (now - this.lastCall) > (interval*0.99) ) return true;
        else return false;
      };

      this.for = function(options) {
        extend(this, options);
        this.lastCall = this.start - this.interval;
        return this;
      };

      this.delete = false;
      return this;
    };
    var l = new Loop();

    events.loops[ l.name ] = l;

    return l;
  };

  this.remove =  this.off = function(event) {

    if (typeof event === "number") {

      if (events.ordinal[event] === undefined) return {"removed":false, "ctx": this};

      delete events.ordinal[event];
      return {"removed":true, "ctx": this};
    }

    if (typeof event === "string") {

      // if it is a event set with on():
      if (events.nominal[eventName] === undefined) {

        //if it is a loop event 
        if (events.loops[eventName] === undefined) return {"removed":false, "ctx": this};

        // loops terminate themselves automatically when set to delete
        events.loops[eventName].delete = true;
        return {"removed":true, "ctx": this};
      }

      delete events.nominal[eventName];
      return {"removed":true, "ctx": this};
    } 
  };

  this.defer = function(fn){
    // waits for the current stack to clear
    window.setTimeout(0, fn)
  };

  this.getEvents = function() {
    // in case someone wants to view the internally set events
    return events;
  };

  /* * * * * * * * * * * * * *

    bindToFunction:

    Attach 'wait' method to the Function.prototype,
    delegating to the timeline's <this>.after() method.
    Useful? Could be. Invasive of global prototypes? Def.

  * * * * * * * * * * * * * */
  
  if (options.bindToFunction === true) {

      var _t = this; // reference, since wait is in the context of the callee

      var wait = function(seconds, args, context) {
        _t.after(seconds, this, args, context); 
      };
      
      Function.prototype.wait = wait;
  }

  if (options.autostart === true) this.start();
  else return this;
};
   

module.exports = Clock;

},{"./_utils":6}],3:[function(require,module,exports){

/*
# @InputInterface
#
*/


(function() {
  var utils;

  utils = require("./_utils");

  module.exports.Interface = function(canvas, parent, engine) {
    var $el, bound, handler, key, mousemoveHandler, scope;
    if (!$) {
      return;
    }
    if (arguments.length === 3) {
      $el = $(canvas);
      this.parent = parent;
      this.engine = engine;
      scope = engine;
    } else {
      $el = $(parent.renderer.domElement);
      this.parent = canvas;
      this.engine = parent;
      scope = parent;
    }
    key = {
      "leftClick": 1,
      "scrollwheel": 2,
      "rightClick": 3,
      'backspace': 8,
      'tab': 9,
      'enter': 13,
      'shift': 16,
      'ctrl': 17,
      'alt': 18,
      'pause': 19,
      'capslock': 20,
      'esc': 27,
      'pageup': 33,
      'pagedown': 34,
      'end': 35,
      'home': 36,
      'left': 37,
      'up': 38,
      'right': 39,
      'down': 40,
      'insert': 45,
      'delete': 46,
      '0': 48,
      '1': 49,
      '2': 50,
      '3': 51,
      '4': 52,
      '5': 53,
      '6': 54,
      '7': 55,
      '8': 56,
      '9': 57,
      'a': 65,
      'b': 66,
      'c': 67,
      'd': 68,
      'e': 69,
      'f': 70,
      'g': 71,
      'h': 72,
      'i': 73,
      'j': 74,
      'k': 75,
      'l': 76,
      'm': 77,
      'n': 78,
      'o': 79,
      'p': 80,
      'q': 81,
      'r': 82,
      's': 83,
      't': 84,
      'u': 85,
      'v': 86,
      'w': 87,
      'x': 88,
      'y': 89,
      'z': 90,
      'numpad0': 96,
      'numpad1': 97,
      'numpad2': 98,
      'numpad3': 99,
      'numpad4': 100,
      'numpad5': 101,
      'numpad6': 102,
      'numpad7': 103,
      'numpad8': 104,
      'numpad9': 105,
      'multiply': 106,
      'plus': 107,
      'minut': 109,
      'dot': 110,
      'slash1': 111,
      'F1': 112,
      'F2': 113,
      'F3': 114,
      'F4': 115,
      'F5': 116,
      'F6': 117,
      'F7': 118,
      'F8': 119,
      'F9': 120,
      'F10': 121,
      'F11': 122,
      'F12': 123,
      'equal': 187,
      'coma': 188,
      'slash': 191,
      'backslash': 220
    };
    bound = {};
    handler = function(e) {
      var b, keyname;
      e.preventDefault();
      e.position = utils.getMousePosition(e);
      b = bound[e.type];
      if (!b) {
        return;
      }
      for (keyname in b) {
        if (key[keyname] === e.which) {
          b[keyname].callback.call(b[keyname], e, b[keyname].data);
          return;
        }
      }
    };
    mousemoveHandler = function(e) {
      var b, data;
      e.preventDefault();
      e.position = utils.getMousePosition(e);
      b = bound["mousemove"];
      data = b.data || {};
      b.callback.call(parent, e, data);
    };
    this.bind = this.on = function(events, keyname, callback, data) {
      var b, eventType, _events, _i, _len;
      if (!(arguments.length >= 2)) {
        return;
      }
      _events = events.split(" ");
      if (_events[0] === "mousemove") {
        bound["mousemove"] = {
          "callback": keyname,
          "data": callback
        };
        $el.on("mousemove", mousemoveHandler);
      }
      for (_i = 0, _len = _events.length; _i < _len; _i++) {
        eventType = _events[_i];
        b = bound[eventType] = bound[eventType] || {};
        b[keyname] = {
          callback: callback,
          data: data
        };
        $el.on(eventType, handler);
      }
      return this;
    };
    this.unbind = this.off = function(events, keyname) {
      var eventType, _events, _i, _len;
      _events = events.split(" ");
      for (_i = 0, _len = _events.length; _i < _len; _i++) {
        eventType = _events[_i];
        $el.off(eventType, handler);
        delete bound[eventType][keyname];
      }
      return this;
    };
    this.trigger = function(event) {
      $el.trigger(event);
      return bound[event];
    };
    return this;
  };

  module.exports.MouseDetection = function(parent, engine, multiselect, clearAfterEmptySelection) {
    var camera, clickHandler, enabled, getIntersections, handler, input, lastClickIntersect, lastHoverIntersect, mousemoveHandler, projector, selectedObjects, stage, that;
    if (multiselect == null) {
      multiselect = true;
    }
    if (clearAfterEmptySelection == null) {
      clearAfterEmptySelection = true;
    }
    enabled = false;
    stage = parent;
    input = parent.Input;
    camera = parent.camera;
    projector = new THREE.Projector();
    this.intersections = null;
    lastHoverIntersect = null;
    lastClickIntersect = null;
    selectedObjects = [];
    that = this;
    this.mousemove = true;
    this.click = true;
    this.multiselect = multiselect;
    this.clearAfterEmptySelection = clearAfterEmptySelection;
    getIntersections = function(mouse, camera) {
      var direction, intersections, raycaster, vector;
      vector = new THREE.Vector3(mouse.normalized.x, mouse.normalized.y, 1);
      projector.unprojectVector(vector, camera);
      direction = vector.sub(camera.position).normalize();
      raycaster = new THREE.Raycaster(camera.position, direction);
      intersections = raycaster.intersectObjects(stage.meshes);
      return intersections;
    };
    handler = function(e, camera) {
      var intersections, mouse;
      mouse = e.position;
      intersections = getIntersections(mouse, camera);
      if (e.type === "mousemove") {
        if (that.mousemove !== true) {
          return;
        }
        mousemoveHandler(intersections, mouse, camera, e);
      } else if (e.type === "click") {
        if (that.click !== true) {
          return;
        }
        clickHandler(intersections, mouse, camera, e);
      }
      return e;
    };
    mousemoveHandler = function(intersections, mouse, camera, e) {
      var intersect;
      if (intersections.length === 0) {
        if (lastHoverIntersect === null) {
          return;
        }
        lastHoverIntersect.dispatchEvent({
          type: "leave"
        });
        lastHoverIntersect = null;
        return;
      }
      intersect = intersections[0].object;
      intersect.dispatchEvent({
        type: "hover"
      });
      if (lastHoverIntersect === null) {
        return lastHoverIntersect = intersect;
      } else if (lastHoverIntersect !== intersect) {
        lastHoverIntersect.dispatchEvent({
          type: "leave"
        });
        return lastHoverIntersect = intersect;
      }
    };
    clickHandler = function(intersections, mouse, camera, e) {
      /* deal with things that weren't selected
      */

      var intersect;
      if (intersections.length === 0) {
        if (lastClickIntersect === null) {
          return;
        }
        if (that.clearAfterEmptySelection !== true) {
          return;
        }
        if (that.multiselect !== true) {
          return;
        }
        selectedObjects.forEach(function(el) {
          return el.dispatchEvent({
            type: "clear"
          });
        });
        selectedObjects = [];
        return;
      }
      intersect = intersections[0].object;
      intersect.dispatchEvent({
        type: "click"
      });
      if (lastClickIntersect === null) {
        lastClickIntersect = intersect;
        if (that.multiselect !== true) {
          return;
        }
        selectedObjects.push(intersect);
      } else if (lastClickIntersect !== intersect) {
        lastClickIntersect.dispatchEvent({
          type: "leave"
        });
        lastClickIntersect = intersect;
        if (that.multiselect !== true) {
          return;
        }
        selectedObjects.push(intersect);
      }
    };
    this.toggle = function() {
      if (enabled) {
        return this.disable();
      } else {
        return this.enable();
      }
    };
    this.off = function() {
      if (enabled) {
        enabled = false;
        input.off("mousemove", handler, camera);
        input.off("click", handler, camera);
      }
    };
    this.on = function() {
      if (!enabled) {
        enabled = true;
        input.on("mousemove", handler, camera);
        input.on("click", "leftClick", handler, camera);
      }
    };
    this.on();
    return this;
  };

}).call(this);

// Generated by CoffeeScript 1.5.0-pre

},{"./_utils":6}],4:[function(require,module,exports){
(function() {
  var Selector, Skybox, _class;

  module.exports.Selector = Selector = (function() {

    function Selector(options, scene) {
      var number, that;
      this.scene = scene;
      if (!(options.size && options.position)) {
        return;
      }
      if (typeof options.size === "number") {
        number = options.size;
      }
      this.position = new THREE.Vector3(options.position.x, options.position.y, options.position.z);
      this.geometry = new THREE.BoxGeometry(options.size.x, options.size.y, options.size.z);
      this.isSelected = false;
      if (!options.material) {
        this.material = new THREE.MeshBasicMaterial({
          opacity: 0.01,
          transparent: true,
          color: 0xffffff,
          wireframe: true
        });
      } else if (options.material.id === void 0) {
        this.material = material || new THREE.MeshBasicMaterial({
          opacity: 0.0,
          transparent: true,
          color: 0x008888,
          wireframe: false
        });
      }
      this.mesh = new THREE.Mesh(this.geometry, this.material);
      this.mesh.position = this.position;
      this.mesh.wrapper = this;
      that = this;
      this.mesh.addEventListener("hover", that.hover);
      this.mesh.addEventListener("leave", that.leave);
      this.mesh.addEventListener("click", that.click);
      this.mesh.addEventListener("clear", that.clear);
      if (this.scene !== void 0) {
        this.addToScene(this.scene);
      }
    }

    Selector.prototype.addToScene = function(scene) {
      this.scene = scene;
      return scene.add(this.mesh);
    };

    Selector.prototype.hover = function() {
      if (this.isSelected === true) {
        return;
      }
      if (this.oldmaterial === void 0) {
        this.oldmaterial = this.material;
      }
      return this.material = this.hovermaterial || new THREE.MeshBasicMaterial({
        opacity: 0.45,
        transparent: true,
        color: 0x00aa88,
        wireframe: true
      });
    };

    Selector.prototype.leave = function() {
      if (this.isSelected) {

      } else {
        return this.material = this.oldmaterial || new THREE.MeshBasicMaterial({
          color: 0x00aa88
        });
      }
    };

    Selector.prototype.click = function() {
      this.isSelected = !this.isSelected;
      if (this.isSelected) {
        return this.material = this.selectedmaterial || new THREE.MeshBasicMaterial({
          color: 0xffffff,
          wireframe: true
        });
      } else {
        return this.material = this.oldmaterial;
      }
    };

    Selector.prototype.clear = function() {
      this.isSelected = false;
      return this.material = this.oldmaterial || new THREE.MeshBasicMaterial({
        color: 0x008888
      });
    };

    return Selector;

  })();

  module.exports.Skybox = Skybox = (function() {

    function Skybox() {
      _class.apply(this, arguments);
    }

    _class = console.log("wow");

    return Skybox;

  })();

}).call(this);

// Generated by CoffeeScript 1.5.0-pre

},{}],5:[function(require,module,exports){

/*

  Stages is an object to manage, well, stages.
  which a stage is the equivalent to the game concept of a 'level.'
  but someone could use multiple stages in one level, so I don't want to be pushy and call it a 'level' manager
*/


(function() {
  var Input, SelectionGrid, Selector, Stage, StageManager, utils,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  utils = require("./_utils");

  Input = require("./_input");

  Selector = require("./_objects").Selector;

  /*
      SelectionGrid Class
      Helper class for selecting objects / entities from a grid
      Should be automatically created when
  */


  SelectionGrid = (function() {

    function SelectionGrid(data, engine, stage) {
      var centerIndex, evenOffset, hm, isInt, o, x, x0, y, y0, _ref;
      this.meshes = [];
      this.engine = engine;
      this.stage = stage;
      this.width = data.width;
      this.height = data.length;
      this.padding = data.padding || 2;
      this.x = data.x;
      this.y = data.y;
      isInt = function(num) {
        if (num / Math.floor(num) === 1 || num / Math.floor(num) === -1) {
          return true;
        }
        return false;
      };
      /* Convert the data into a normalized grid data
      */

      evenOffset = (_ref = isInt(data.x / 2)) != null ? _ref : {
        0: 1
      };
      x0 = ~~(data.x / 2);
      y0 = ~~(data.y / 2);
      centerIndex = null;
      x = -1 * x0;
      y = -1 * y0;
      hm = utils.isArray(data.heightmap) ? data.heightmap : (function() {
        var _i, _ref1, _results;
        _results = [];
        for (o = _i = 0, _ref1 = data.x * data.y; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; o = 0 <= _ref1 ? ++_i : --_i) {
          _results.push(o - o);
        }
        return _results;
      })();
      data = hm.map(function(el, index, arr) {
        var node;
        node = {
          "z": el,
          "x": x,
          "y": y
        };
        if (x === 0 && y === 0) {
          node.center = true;
          centerIndex = index;
        }
        if (x === (x0 - evenOffset)) {
          x = -1 * x0;
          y++;
        } else {
          x++;
        }
        return node;
      });
      this.centerIndex = centerIndex;
      this.data = data;
      this.createGrid();
    }

    SelectionGrid.prototype.createGrid = function() {
      var cube, datum, h, material, padding, position, scene, size, w, x, y, _i, _len, _ref, _results;
      if (this.data === void 0) {
        return;
      }
      this.objects = [];
      x = 0;
      y = 0;
      w = this.width;
      h = this.height;
      padding = this.padding || 2;
      _ref = this.data;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        datum = _ref[_i];
        size = {
          x: w,
          y: w,
          z: 0
        };
        position = {
          x: datum.x * (w + padding),
          y: datum.y * (w + padding),
          z: datum.z * (h + padding)
        };
        material = this.material;
        scene = this.stage.scene;
        cube = new Selector({
          size: size,
          position: position,
          material: material
        }, scene);
        this.objects.push(cube);
        _results.push(this.stage.meshes.push(cube.mesh));
      }
      return _results;
    };

    SelectionGrid.prototype.filterData = function(vec3) {
      /*
        argument 'vec3' can be an object or a THREE.Vector3 instance
        ! Vector3 instances don't allow you to have 'undefined' as a value, so using '*' is used
        ie:   filterData( new THREE.Vector3(0, "*", "*") );
      
        Plain objects do allow undefined though, so you can pass in an object with all the values you want
        ie:   filterData({ x: 2});
      */
      if (!vec3) {
        return;
      }
      return this.data.filter(function(el, i, arr) {
        if (el.x === vec3.x || vec3.x === "*" || vec3.x === void 0) {
          if (el.y === vec3.y || vec3.y === "*" || vec3.y === void 0) {
            if (el.z === vec3.z || vec3.z === "*" || vec3.z === void 0) {
              return el;
            }
          }
        }
      });
    };

    return SelectionGrid;

  })();

  Stage = (function(_super) {

    __extends(Stage, _super);

    function Stage(parent, name, options) {
      var beforeLoaded, callbacks, camera, that;
      this.parent = parent;
      this.renderer = parent.renderer;
      this.name = name.toLowerCase();
      this.scene = options.scene;
      camera = options.camera;
      this.camera = camera;
      this.meshes = [];
      beforeLoaded = function() {
        this.render();
        this.Input = new Input.Interface(this, parent);
        this.MouseDetector = new Input.MouseDetection(this, parent);
        return this.onload.call(this);
      };
      that = this;
      that.on("load", beforeLoaded.bind(that));
      callbacks = {
        scope: that,
        success: function(responseText) {
          that.data = responseText;
          console.log("Engine :: '" + name + "' ajax'd. ");
          that.data.grid = that.grid = new SelectionGrid(that.data.grid, that.parent, that);
          return that.trigger("load");
        },
        error: function() {
          throw new Error("Error retrieving data for Stage");
        }
      };
      if (options.url !== void 0) {
        utils.getJSON(options.url, callbacks);
      }
    }

    Stage.prototype.load = function(urlToJson) {
      /*
        incase wasn't originally passed in
      */

      var callbacks, that;
      that = this;
      callbacks = {
        scope: that,
        success: function(responseText) {
          that.data = responseText;
          console.log("Engine :: '" + name + "' ajax'd. ");
          that.data.grid = that.grid = new SelectionGrid(that.data.grid, that.parent, that);
          return that.trigger("load");
        },
        error: function() {
          throw new Error("Error retrieving data for Stage");
        }
      };
      if (urlToJson !== void 0) {
        return utils.getJSON(urlToJson, callbacks);
      }
    };

    Stage.prototype.onload = function() {
      /*
        meant to be overwritten by the user
        alternative is: 
        | @on "load", fn
        which will be triggered on loading
      */
      return this;
    };

    Stage.prototype.lookAt = function(point) {
      this.camera.up = new THREE.Vector3(0, 0, 1);
      return this.camera.lookAt(point || this.scene);
    };

    Stage.prototype.setCameraToIsometric = function() {
      var distanceFromCenterofGridToEdge, h, w, x, xDistance, y, yDistance, zDistance;
      if (!this.grid) {
        return;
      }
      w = this.grid.width;
      h = this.grid.height;
      x = this.grid.x;
      y = this.grid.y;
      distanceFromCenterofGridToEdge = utils.pythag(w * x, h * y);
      zDistance = distanceFromCenterofGridToEdge / 2;
      yDistance = (w + (this.grid.padding || 2)) * x;
      xDistance = (w + (this.grid.padding || 2)) * x;
      this.camera.position.setZ(zDistance);
      this.camera.position.setY(yDistance);
      this.camera.position.setX(xDistance);
      this.camera.up = new THREE.Vector3(0, 0, 1);
      this.camera.lookAt(new THREE.Vector3(0, 0, 0));
      return this;
      /*
      
      
      @camera.rotation.z = 0.25
      */

    };

    Stage.prototype.render = function() {
      var L, extent, geometry, line, material;
      geometry = new THREE.Geometry();
      extent = 5000;
      geometry.vertices.push(new THREE.Vector3(0, 0, -extent));
      geometry.vertices.push(new THREE.Vector3(0, 0, extent));
      geometry.vertices.push(new THREE.Vector3(-extent, 0, 0));
      geometry.vertices.push(new THREE.Vector3(extent, 0, 0));
      geometry.vertices.push(new THREE.Vector3(0, -extent, 0));
      geometry.vertices.push(new THREE.Vector3(0, extent, 0));
      material = new THREE.LineBasicMaterial({
        color: 0x555555
      });
      line = new THREE.Line(geometry, material);
      this.scene.add(line);
      this.setCameraToIsometric();
      this.parent.renderer.render(this.scene, this.camera);
      L = this.parent.clock.loop("render", function() {
        return this.parent.renderer.render(this.scene, this.camera);
      }, null, this);
      L["for"]({
        interval: 17
      });
      return this.parent.clock.start();
    };

    Stage.prototype.destroy = function() {
      return this.parent.destroy(this.name);
    };

    return Stage;

  })(utils.EventEmitter);

  StageManager = function(engine) {
    /* @PRIVATES
    */

    var list, parent;
    parent = engine;
    /* @PUBLICS
    */

    list = {};
    this.list = [];
    this.create = function(name, options) {
      var o, stage;
      if (!name) {
        return;
      }
      o = options || {};
      stage = new Stage(parent, name, o);
      this.list.push(name);
      list[name.toLowerCase()] = stage;
      return list[name.toLowerCase()];
    };
    this.current = void 0;
    this.destroy = function(name) {
      return delete list[name];
    };
    this.load = function(name, transition) {};
    return this;
  };

  module.exports = StageManager;

}).call(this);

// Generated by CoffeeScript 1.5.0-pre

},{"./_input":3,"./_objects":4,"./_utils":6}],6:[function(require,module,exports){

/*
      utilities
*/


(function() {
  var EventEmitter,
    __slice = [].slice;

  module.exports.log = function(msg) {
    var prefix;
    this.logs.unshift(msg);
    if (!this.debug) {
      return;
    }
    prefix = "Engine :: ";
    if (typeof msg === "string") {
      console.log(prefix + msg);
    } else {
      console.log(msg);
    }
  };

  module.exports.extend = function() {
    var base, extended, key, obj, objs, _i, _len;
    objs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (objs.length < 2) {
      return objs[0];
    }
    extended = objs[0];
    for (_i = 0, _len = objs.length; _i < _len; _i++) {
      obj = objs[_i];
      base = obj;
      for (key in base) {
        extended[key] = base[key];
      }
    }
    return extended;
  };

  module.exports.isArray = Array.isArray || function(thing) {
    return Object.prototype.toString.call(thing === "[object Array]");
  };

  module.exports.pythag = function(A, B, hypotenuse) {
    var a2, b2, result;
    if (!(arguments.length >= 2)) {
      return;
    }
    if (B === null) {
      result = (Math.pow(hypotenuse, 2)) - Math.pow(A, 2);
      result = Math.sqrt(result);
      return result;
    } else {
      a2 = Math.pow(A, 2);
      b2 = Math.pow(B, 2);
      result = Math.sqrt(a2 + b2);
      return result;
    }
  };

  module.exports.getJSON = function(url, callbacks) {
    var ajax, data, options;
    options = callbacks || {};
    data = void 0;
    ajax = $.getJSON(url);
    return ajax.complete(function() {
      try {
        data = $.parseJSON(ajax.responseText);
      } catch (e) {
        options.error.call(options.scope || null, e, ajax);
        return;
      }
      options.success.call(options.scope || null, data, ajax);
    });
  };

  module.exports.getMousePosition = function($e) {
    var normalized, x, y;
    if (!($e.type === "click" || $e.type === "mousemove")) {
      return;
    }
    x = $e.clientX;
    y = $e.clientY;
    normalized = {
      "x": (x / window.innerWidth) * 2 - 1,
      "y": -(y / window.innerHeight) * 2 + 1
    };
    return {
      x: x,
      y: y,
      normalized: normalized
    };
  };

  module.exports.EventEmitter = EventEmitter = (function() {

    function EventEmitter() {}

    EventEmitter.prototype.events = {};

    EventEmitter.prototype.on = function(name, fn) {
      this.events[name] = fn;
      return this;
    };

    EventEmitter.prototype.off = function(name) {
      delete this.events[name];
      return this;
    };

    EventEmitter.prototype.get = function(name) {
      return this.events[name];
    };

    EventEmitter.prototype.trigger = function(name) {
      var fn;
      fn = this.get(name);
      if (fn === void 0) {
        return;
      }
      fn.call();
      return this;
    };

    return EventEmitter;

  })();

}).call(this);

// Generated by CoffeeScript 1.5.0-pre

},{}],7:[function(require,module,exports){
(function() {

  require("./_base");

  require("./main");

}).call(this);

// Generated by CoffeeScript 1.5.0-pre

},{"./_base":1,"./main":8}],8:[function(require,module,exports){
(function() {



}).call(this);

// Generated by CoffeeScript 1.5.0-pre

},{}]},{},[7])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyJjOlxcVXNlcnNcXFJvYXItWWF3blxcc2FuZGJveFxcdGhyZWVqcy10YWN0aWNzLWVuZ2luZVxcbm9kZV9tb2R1bGVzXFxicm93c2VyaWZ5XFxub2RlX21vZHVsZXNcXGJyb3dzZXItcGFja1xcX3ByZWx1ZGUuanMiLCJjOi9Vc2Vycy9Sb2FyLVlhd24vc2FuZGJveC90aHJlZWpzLXRhY3RpY3MtZW5naW5lL3B1YmxpYy9qYXZhc2NyaXB0L3NyYy9fYmFzZS5qcyIsImM6L1VzZXJzL1JvYXItWWF3bi9zYW5kYm94L3RocmVlanMtdGFjdGljcy1lbmdpbmUvcHVibGljL2phdmFzY3JpcHQvc3JjL19jbG9jay5qcyIsImM6L1VzZXJzL1JvYXItWWF3bi9zYW5kYm94L3RocmVlanMtdGFjdGljcy1lbmdpbmUvcHVibGljL2phdmFzY3JpcHQvc3JjL19pbnB1dC5qcyIsImM6L1VzZXJzL1JvYXItWWF3bi9zYW5kYm94L3RocmVlanMtdGFjdGljcy1lbmdpbmUvcHVibGljL2phdmFzY3JpcHQvc3JjL19vYmplY3RzLmpzIiwiYzovVXNlcnMvUm9hci1ZYXduL3NhbmRib3gvdGhyZWVqcy10YWN0aWNzLWVuZ2luZS9wdWJsaWMvamF2YXNjcmlwdC9zcmMvX3N0YWdlLmpzIiwiYzovVXNlcnMvUm9hci1ZYXduL3NhbmRib3gvdGhyZWVqcy10YWN0aWNzLWVuZ2luZS9wdWJsaWMvamF2YXNjcmlwdC9zcmMvX3V0aWxzLmpzIiwiYzovVXNlcnMvUm9hci1ZYXduL3NhbmRib3gvdGhyZWVqcy10YWN0aWNzLWVuZ2luZS9wdWJsaWMvamF2YXNjcmlwdC9zcmMvYnJvd3Nlci5qcyIsImM6L1VzZXJzL1JvYXItWWF3bi9zYW5kYm94L3RocmVlanMtdGFjdGljcy1lbmdpbmUvcHVibGljL2phdmFzY3JpcHQvc3JjL21haW4uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDemlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpfXZhciBmPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChmLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGYsZi5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJcbi8qXG4gICAgdGhyZWUtanMgVGFjdGljcyBFbmdpbmVcbiovXG5cblxuKGZ1bmN0aW9uKCkge1xuICB2YXIgQ2xvY2ssIFN0YWdlLCBUaHJlZVRhY3RpY3NFbmdpbmUsIHV0aWxzO1xuXG4gIGNvbnNvbGUubG9nKFwiX2Jhc2VcIik7XG5cbiAgdXRpbHMgPSByZXF1aXJlKFwiLi9fdXRpbHNcIik7XG5cbiAgU3RhZ2UgPSByZXF1aXJlKFwiLi9fc3RhZ2VcIik7XG5cbiAgQ2xvY2sgPSByZXF1aXJlKFwiLi9fY2xvY2tcIik7XG5cbiAgVGhyZWVUYWN0aWNzRW5naW5lID0gZnVuY3Rpb24oKSB7XG4gICAgLypcbiAgICAgIEBQUklWQVRFU1xuICAgICovXG5cbiAgICB2YXIgVEhSRUUsIGNvbmZpZ0xvYWRlZCwgZXZlbnRNZXRob2RzLCBsb2csIG5hbWUsIHNjZW5lLCB0aGF0LCBfaSwgX2xlbjtcbiAgICBpZiAoc2VsZi5USFJFRSA9PT0gdm9pZCAwIHx8IHNlbGYuJCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZW5naW5lIGlzIGRlcGVuZGVudCBvbiBUSFJFRS5qcyBhbmQgalF1ZXJ5LCB3aGljaCBvbmUgb2Ygd2FzIG5vdCBmb3VuZCwgb3Igbm90IGluIHRoZSBnbG9iYWwgc2NvcGUuXCIpO1xuICAgIH1cbiAgICBUSFJFRSA9IHNlbGYuVEhSRUU7XG4gICAgY29uZmlnTG9hZGVkID0gZmFsc2U7XG4gICAgc2NlbmUgPSBmYWxzZTtcbiAgICB0aGF0ID0gdGhpcztcbiAgICB0aGlzLmRlYnVnID0gdHJ1ZTtcbiAgICB0aGlzLmxvZ3MgPSBbXTtcbiAgICBsb2cgPSAoZnVuY3Rpb24obXNnKSB7XG4gICAgICByZXR1cm4gdXRpbHMubG9nLmNhbGwodGhpcywgbXNnLCB0aGlzLmxvZ3MpO1xuICAgIH0pLmJpbmQodGhpcyk7XG4gICAgdGhpcy5sb2cgPSBsb2c7XG4gICAgLypcbiAgICAgIEBQVUJMSUNTXG4gICAgKi9cblxuICAgIHRoaXMubG9hZCA9IGZ1bmN0aW9uKCkge307XG4gICAgdGhpcy5yZW5kZXJRdWV1ZSA9IFtdO1xuICAgIHRoaXMuc3RhZ2UgPSBuZXcgU3RhZ2UodGhpcyk7XG4gICAgdGhpcy5jbG9jayA9IG5ldyBDbG9jaygpO1xuICAgIC8qIFxuICAgICAgRHluYW1pY2FsbHkgYWRkIGV2ZW50IG1ldGhvZHMgZnJvbSB0aGUgY2xvY2sgb2JqZWN0ICh3aGljaCBoYXMgYW4gZXZlbnQgZW1pdHRlciBidWlsdCBpbnRvIGl0LilcbiAgICAgIHRoaXMgYXJyYXkgaXMgdGhlIG5hbWVzIG9mIHRoZSBtZXRob2RzIHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgZXZlbnRzIG9iamVjdFxuICAgICovXG5cbiAgICBldmVudE1ldGhvZHMgPSBbXCJvblwiLCBcIm9mZlwiLCBcImRlZmVyXCIsIFwiZ2V0RXZlbnRzXCIsIFwidHJpZ2dlclwiLCBcInJlbW92ZVwiXTtcbiAgICB0aGlzLmV2ZW50cyA9IHt9O1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gZXZlbnRNZXRob2RzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICBuYW1lID0gZXZlbnRNZXRob2RzW19pXTtcbiAgICAgIHRoaXMuZXZlbnRzW25hbWVdID0gdGhpcy5jbG9ja1tuYW1lXTtcbiAgICB9XG4gICAgdGhpcy5pbml0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIGNvbmZpZztcbiAgICAgIGNvbmZpZyA9ICQuZ2V0SlNPTigob3B0aW9ucyB8fCB7fSkuY29uZmlnKTtcbiAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhhdCA9IHRoaXM7XG4gICAgICByZXR1cm4gY29uZmlnLmNvbXBsZXRlKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVuZGVyZXI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhhdC5jb25maWcgPSAkLnBhcnNlSlNPTihjb25maWcucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGxvZyhlKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJKU09OIHdhcyBub3QgcGFyc2VkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25maWdMb2FkZWQgPSB0cnVlO1xuICAgICAgICBsb2coXCJDb25maWd1cmF0aW9uIExvYWRlZC5cIik7XG4gICAgICAgIHJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoe1xuICAgICAgICAgIGFudGlhbGlhczogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmVuZGVyZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChyZW5kZXJlci5kb21FbGVtZW50KTtcbiAgICAgICAgdGhhdC5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICBsb2coXCJJbml0aWFsaXplZC5cIik7XG4gICAgICAgIGlmICgob3B0aW9ucyB8fCB7fSkuYXV0b3N0YXJ0ID09PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoYXQuc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc3RhZ2U7XG4gICAgICBpZiAoIWNvbmZpZ0xvYWRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhZ2UgPSB0aGlzLnN0YWdlLmNyZWF0ZShcInRlc3RcIiwge1xuICAgICAgICBcInVybFwiOiBcImpzb24vdGVzdC5qc29uXCIsXG4gICAgICAgIFwiY2FtZXJhXCI6IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSg0NSwgd2luZG93LmlubmVyV2lkdGggLyB3aW5kb3cuaW5uZXJIZWlnaHQsIDAuMSwgMTAwMDAwKSxcbiAgICAgICAgXCJzY2VuZVwiOiBuZXcgVEhSRUUuU2NlbmUoKVxuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBzZWxmLkVuZ2luZSA9IG5ldyBUaHJlZVRhY3RpY3NFbmdpbmUoKTtcblxuICBFbmdpbmUuaW5pdCh7XG4gICAgXCJjb25maWdcIjogXCJqc29uL2NvbmZpZy5qc29uXCIsXG4gICAgXCJhdXRvc3RhcnRcIjogdHJ1ZVxuICB9KTtcblxuICBjb25zb2xlLmxvZyhFbmdpbmUpO1xuXG59KS5jYWxsKHRoaXMpO1xuXG4vLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNS4wLXByZVxuIiwiXG4gIC8qXG4gICAgTW9kaWZpZWQgdmVyc2lvbiBmcm9tXG5cbiAgICArLSstIEdJVEhVQiAtKy0rXG4gIHVubW9kaWZpZWQgdmVyc2lvbiBsb2NhdGVkIGF0OlxuICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9Sb3J5RHVuY2FuL0Nsb2NrRXZlbnRBZ2dyZWdnYXRvclxuICAgIFxuICAgICstKy0gRE9DVU1FTlRBVElPTiAtKy0rXG4gICAgaHR0cDovL3JvcnlkdW5jYW4uZ2l0aHViLmlvL0Nsb2NrRXZlbnRBZ2dyZWdnYXRvci9cblxuICAqL1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKFwiLi9fdXRpbHNcIik7XG5cbnZhciBDbG9jayA9IGZ1bmN0aW9uKGFyZ3MpIHtcblxuICAvKiBIZWxwZXJzICovXG5cbiAgLy8gSGVscGVyIGZvciBtZXJnaW5nIG9iamVjdHNcbiAgZXh0ZW5kID0gdXRpbHMuZXh0ZW5kO1xuXG4gIHZhciBpc0FycmF5ID0gZnVuY3Rpb24odGhpbmcpe1xuICAgIC8vIGFzc3VtZSAndGhpbmcnIGlzIG5vdCB1bmRlZmluZWQgb3IgbnVsbCBhcyBpdCB3aWxsIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmICh0eXBlb2YgdGhpbmcgPT09IFwic3RyaW5nXCIpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoICh0aGluZykubGVuZ3RoID09PSB1bmRlZmluZWQpIHJldHVybiBmYWxzZTtcbiAgICBlbHNlIHJldHVybiB0cnVlOyBcbiAgfVxuXG5cbiAgLyogIFRpbWVsaW5lIHJlbGF0ZWQgdmFyaWFibGVzICAqL1xuXG4gIHZhciBkZWZhdWx0cyA9IHt1c2VSQUY6IHRydWUsIHRpY2tJbnRlcnZhbDogMTYsIGF1dG9zdGFydDogZmFsc2V9LFxuICAgICAgb3B0aW9ucyA9IGV4dGVuZChkZWZhdWx0cywgYXJncyksXG4gICAgICB0aWNrcyA9IDAsXG4gICAgICBsYXN0VGljayA9IDAsXG4gICAgICBzdGFydFRpbWUgPSAwLFxuXG4gICAgICAvLyB0aGUgJ2Nsb2NrJyB0aW1lLCBjYWxjdWxhdGVkIHdpdGggZGVsdGEgYW5kIGNsb2NrU3BlZWQgdmFyaWFibGVzLlxuICAgICAgZWxhcHNlZFRpbWUgPSAwLFxuXG4gICAgICAvLyBpZCBmb3IgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICByQUZJRCA9IG51bGwsXG5cbiAgICAgIC8vIHdoZXRoZXIgdGhpcyBpcyBldmVyeSBvdGhlciB0aWNrXG4gICAgICB0aWNrX24gPSBmYWxzZSxcblxuICAgICAgLy8gdGhlIGFtb3VudCBvZiByZWFsLXRpbWUgdGhhdCBoYXMgcGFzc2VkIGJldHdlZW4gdGlja3NcbiAgICAgIGRlbHRhID0gMCxcbiAgICAgIGFjdHVhbEVsYXBzZWRUaW1lID0gMDtcblxuICAgICAgLy8gZmFsbGJhY2sgdGltZSBmb3Igc2V0VGltZW91dFxuICAgICAgdGhpcy50aWNrSW50ZXJ2YWwgPSBvcHRpb25zLnRpY2tJbnRlcnZhbCxcblxuICAgICAgcnVubmluZyA9IGZhbHNlLFxuXG4gICAgICAvLyBzcGVlZCBhdCB3aGljaCB0aGUgY2xvY2sgcnVuc1xuICAgICAgY2xvY2tzcGVlZCA9IDEsXG5cbiAgICAgIC8vIHJlZmVyZW5jZVxuICAgICAgc2VsZiA9IHRoaXMsXG5cbiAgICAgIC8vIHdldGhlciBvciBub3QgdG8gdXNlIHJlcXVlc3QgQW5pbWF0aW9uIEZyYW1lXG4gICAgICB1c2VSQUYgPSBvcHRpb25zLnVzZVJBRixcblxuICAgICAgLy8gZHluYW1pYyBmdW5jdGlvbiBmb3IgckFGIG9yIHNldFRpbWVvdXQgZnVuY3Rpb25hbGl0eSxcbiAgICAgIHRpY2tDYWxsZWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gc2V0IHRvIHN0YXJ0KCkgaW5pdGlhbGx5IGluIGNhc2UgY2FsbGVkIGJlZm9yZSBzdGFydCBzb21laG93LlxuICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICB9O1xuXG4gICAgICBcbiAgICAgIFxuXG5cbiAgLyogIEV2ZW50IEFnZ3JlZ2F0b3IgcmVsYXRlZCB2YXJpYWJsZXMgICovXG5cbiAgdmFyIGV2ZW50cyA9IHt9O1xuICAgICAgZXZlbnRzLm5vbWluYWwgPSB7fTtcbiAgICAgIGV2ZW50cy5vcmRpbmFsID0ge307XG4gICAgICBldmVudHMubG9vcHMgPSB7fTtcblxuICBcbiAgLyogIEludGVybmFsIEZ1bmN0aW9ucyAqL1xuXG4gIC8vICBjbG9jaydzIHRpY2sgbWVjaGFuaXNtXG4gIHZhciB0aWNrID0gZnVuY3Rpb24oKSB7XG4gICAgXG4gICAgdmFyIG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpOyAvL2NhY2hlXG4gICAgaWYgKCFydW5uaW5nKSByZXR1cm47XG4gICAgXG4gICAgdGlja3MgKz0gMSAqIGNsb2Nrc3BlZWQ7XG4gICAgdGlja19uID0gIXRpY2tfbjtcbiAgICBpZiAodGhpcy5kZWJ1ZyAmJiB0aWNrX24pIHRoaXMubG9nKCk7XG5cbiAgICBcbiAgICB0aGlzLmRlbHRhID0gZGVsdGEgPSAobm93IC0gbGFzdFRpY2spICogY2xvY2tzcGVlZDtcblxuICAgIGxhc3RUaWNrID0gbm93O1xuXG4gICAgZWxhcHNlZFRpbWUgKz0gZGVsdGE7XG5cbiAgICBhY3R1YWxFbGFwc2VkVGltZSA9ICggbm93IC0gc3RhcnRUaW1lICk7XG5cbiAgICB0aGlzLmVycm9yTWFyZ2luID0gYWN0dWFsRWxhcHNlZFRpbWUgLSBlbGFwc2VkVGltZTsgXG5cblxuICAgIC8vIHNpbmd1bGFyIGV2ZW50cyB0YWtlIHByZWNlZGVuY2Ugb3ZlciBsb29wIGV2ZW50cy5cbiAgICB0cmlnZ2VyQ3VycmVudEV2ZW50cygpO1xuICAgIHRyaWdnZXJMb29wRXZlbnRzKCk7XG5cbiAgICB0aGlzLnRyaWdnZXIoXCJ0aWNrXCIpO1xuXG4gICAgXG4gICAgckFGSUQgPSB0aWNrQ2FsbGVlKCk7XG5cbiAgICByZXR1cm4gdGlja3M7XG4gIH07XG4gIFxuICB2YXIgYnVpbGREZWZhdWx0RXZlbnRzID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgZGVmYXVsdEV2ZW50cyA9IFtcInRpY2tcIiwgXCJzdGFydFwiLCBcImFmdGVyOnN0YXJ0XCIsIFwicGF1c2VcIiwgXCJyZXN1bWVcIl0sXG4gICAgICAgIGFkZEV2ZW50ID0gZnVuY3Rpb24obmFtZSl7XG5cbiAgICAgICAgICBldmVudHMub3JkaW5hbFtuYW1lXSA9IFtdO1xuICAgICAgICB9O1xuXG4gICAgZGVmYXVsdEV2ZW50cy5mb3JFYWNoKGFkZEV2ZW50KTtcblxuICB9O1xuICBidWlsZERlZmF1bHRFdmVudHMoKTtcblxuICB2YXIgdHJpZ2dlck9yZGluYWxFdmVudHMgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBub3cgPSB+fihlbGFwc2VkVGltZSAvIDEwMCkgKiAxMDA7XG5cbiAgICBpZiAoIGV2ZW50cy5vcmRpbmFsWyBub3cgXSA9PT0gdW5kZWZpbmVkICkge3JldHVybiBmYWxzZTt9ICAvLyByZXR1cm4gZmFsc2UgaW4gY2FzZSBvZiBjaGVja3NcblxuICAgIFxuICAgIHZhciBlb3QgPSBldmVudHMub3JkaW5hbFsgbm93IF07XG5cbiAgICAvLyBldmVudHMub3JkaW5hbCB3aWxsIGJlIGFuIGFycmF5LCBzbyBsb29wIG92ZXIgZWFjaCBmdW5jdGlvbiBpbiBpdC5cbiAgICBmb3IgKHZhciBfeCA9IDAsIF94eCA9IGVvdC5sZW5ndGg7IF94IDwgX3h4OyBfeCsrKSB7XG5cbiAgICAgIHZhciBmbiA9IGVvdFtfeF0uZm4sXG4gICAgICAgICAgY3R4ID0gZW90W194XS5jb250ZXh0LFxuICAgICAgICAgIGFyZ3MgPSBlb3RbX3hdLmFyZ3M7XG5cbiAgICAgIGZuLmFwcGx5KGN0eCwgYXJncyk7XG4gICAgfVxuXG4gICAgLy8gZGVsZXRlIGl0LCBzbyB0aGF0IGl0IHdvbid0IHRyaWdnZXIgdGhlIG5leHQgdGlja3MgdGhhdCByb3VuZCBkb3duIHRvIHRoaXMgdGltZS5cbiAgICBkZWxldGUgZXZlbnRzLm9yZGluYWxbIG5vdyBdO1xuXG4gICAgcmV0dXJuIHRydWU7IC8vIHJldHVybiB0cnVlIGluIGNhc2Ugb2YgY2hlY2tzXG4gIH07XG5cbiAgdmFyIHRyaWdnZXJMb29wRXZlbnRzID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgbm93ID0gfn5lbGFwc2VkVGltZTtcblxuICAgIHZhciBleHBpcmVkID0gW107XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gZXZlbnRzLmxvb3BzKSB7XG5cbiAgICAgIHZhciBsb29wID0gZXZlbnRzLmxvb3BzWyBrZXkgXVxuXG4gICAgICBpZiAobG9vcC5zdGFydCA8PSBub3cgJiYgICAgICAgICAgLy8gQ2hlY2sgaWYgaXQgaXMgJ2FsbG93ZWQnIHRvIHN0YXJ0LlxuICAgICAgICAgIGxvb3AuY2hlY2tJbnRlcnZhbCggbm93ICkgJiYgIC8vIENoZWNrIHdoZXRoZXIgdGhlIGxvb3Agc2hvdWxkIGZpcmUgYXQgdGhlIGN1cnJlbnQgdGltZVxuICAgICAgICAgIGxvb3AuZGVsZXRlID09PSBmYWxzZSApIHsgICAgICAvLyBDaGVjayBpZiBpdCBpcyB0byBiZSBkZWxldGVkXG4gICAgICAgICAgXG4gICAgICAgICAgLy8gdGhlcmUgaXMgYSByZWZlcmVuY2UgdG8gX3RoaXNfIGluc2lkZSBvZiBsb29wLFxuICAgICAgICAgIC8vIHNvIHNlbmRpbmcgdGhlIGxvb3AgaXRzZWxmIGFzIGNvbnRleHQgaXMgZW5vdWdoLlxuICAgICAgICAgIGxvb3AuY2FsbGVkQXQucHVzaCggbm93ICk7XG4gICAgICAgICAgbG9vcC5ub3cgPSBub3c7XG4gICAgICAgICAgXG4gICAgICAgICAgbG9vcC5mbi5hcHBseSggbG9vcC5zY29wZSwgbG9vcC5hcmdzICk7XG4gICAgICAgICAgXG4gICAgICAgICAgbG9vcC5sYXN0Q2FsbCA9IG5vdztcbiAgICAgICAgICBsb29wLmNhbGxzKys7XG4gICAgICB9XG4gICAgICAvLyBjaGVjayB3aGV0aGVyIGl0IGhhcyBleHBpcmVkXG4gICAgICBpZiAobG9vcC5zdG9wID09PSBub3cgfHwgbG9vcC5jYWxscyA9PT0gbG9vcC5tYXhJbnRlcnZhbHMgfHwgbG9vcC5kZWxldGUgPT09IHRydWUpIHtcbiAgICAgICAgLy8gcHV0IGl0IGluIHRoZSBib3ggd2hlcmUgYmFkIGxvb3BzIGdvLlxuICAgICAgICBleHBpcmVkLnB1c2goIGtleSApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERlbGV0ZSBhbnkgbG9vcHMgbWFya2VkXG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZXhwaXJlZC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICB2YXIgbmFtZSA9IGV4cGlyZWRbaV07XG4gICAgICBkZWxldGUgZXZlbnRzLmxvb3BzW25hbWVdO1xuICAgIH1cbiAgfTtcblxuXG4gIC8qICBCaW5kaW5ncyAgKi9cblxuICB0aGlzLnRpY2sgPSB0aWNrLmJpbmQodGhpcyk7XG4gIHZhciB0cmlnZ2VyTG9vcEV2ZW50cyA9IHRyaWdnZXJMb29wRXZlbnRzLmJpbmQodGhpcyk7XG4gIHZhciAgdHJpZ2dlckN1cnJlbnRFdmVudHMgPSB0cmlnZ2VyT3JkaW5hbEV2ZW50cy5iaW5kKHRoaXMpO1xuICBcblxuXG4gIC8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKi9cbiAgLyogKiAqICogKiAqICogKiAqICogKiAqICogICBBUEkgICAqICogKiAqICogKiAqICogKiAqICogKiAqL1xuICAvKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICovXG5cblxuICAvKiAgQ2xvY2stcmVsYXRlZCBtZXRob2RzICAqL1xuXG4gIHRoaXMuc3RhcnQgPSBmdW5jdGlvbigpIHtcblxuICAgIGlmIChydW5uaW5nID09PSB0cnVlKSB7IHJldHVybiB0aGlzOyB9IC8vIHNpbXBsZSB0ZXN0cyB0byBwcmV2ZW50IG11bHRpcGxlIHN0YXJ0c1xuXG4gICAgLy8gdGlja0xvb3AgaXMgYSBkeW5hbWljYWxseSBjb25zdHJ1Y3RlZCBmdW5jdGlvbiB0byByZW1vdmUgYW4gJ2lmJyBzdGF0ZW1lbnQgaW5zaWRlIG9mIHRpY2soKSAuXG4gICAgdmFyIHRpY2tMb29wOyAgXG5cbiAgICBpZiAodXNlUkFGID09PSB0cnVlKSB7XG4gICAgICB0aWNrTG9vcCA9IG5ldyBGdW5jdGlvbihcIiB2YXIgaWQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCB0aGlzLnRpY2sgKTsgcmV0dXJuIGlkO1wiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aWNrTG9vcCA9IG5ldyBGdW5jdGlvbihcIiB2YXIgaWQgPSB3aW5kb3cuc2V0VGltZW91dCh0aGlzLnRpY2ssIHRoaXMudGlja0ludGVydmFsKTtyZXR1cm4gaWQ7XCIgKTtcbiAgICB9XG4gICAgLy8gYmluZCBpbnRvIHRoaXMgY29udGV4dFxuICAgIHRpY2tDYWxsZWUgPSB0aWNrTG9vcC5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy50cmlnZ2VyKFwiYmVmb3JlOnN0YXJ0XCIpO1xuXG4gICAgdmFyIG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIHRoaXMuc3RhcnRUaW1lID0gc3RhcnRUaW1lID0gbm93O1xuICAgIHJ1bm5pbmcgPSB0cnVlO1xuICAgIGxhc3RUaWNrID0gbm93O1xuICAgIHRoaXMudGljaygpO1xuXG4gICAgdGhpcy5lbmFibGVQYXVzZU9uQmx1cigpO1xuICAgIHRoaXMudHJpZ2dlcihcInN0YXJ0XCIpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0uYmluZCh0aGlzKTtcblxuICB0aGlzLnN0b3AgPSBmdW5jdGlvbigpe1xuXG4gICAgcnVubmluZyA9IGZhbHNlO1xuICAgIC8vcmVzZXQgZXZlbnQgbGlzdHNcbiAgICBldmVudHMubm9taW5hbCA9IHt9O1xuICAgIGV2ZW50cy5vcmRpbmFsID0gW107XG4gICAgZXZlbnRzLmxvb3BzID0ge307XG5cbiAgICBidWlsZERlZmF1bHRFdmVudHMoKTtcblxuICAgIC8vcmVzZXQgY291bnRlcnNcbiAgICB0aWNrcyA9IDA7XG4gICAgZWxhcHNlZFRpbWUgPSAwO1xuICAgIHRoaXMuc3RhcnRUaW1lID0gc3RhcnRUaW1lID0gMDtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LmJpbmQodGhpcyk7XG5cbiAgdGhpcy5yZXNldCA9IGZ1bmN0aW9uKCl7XG5cbiAgICB0aGlzLnJlc2V0KCk7XG4gICAgdGhpcy5zdGFydCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LmJpbmQodGhpcyk7XG5cbiAgdGhpcy5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJ1bm5pbmcgPSBmYWxzZTtcbiAgICB0aGlzLnRyaWdnZXIoXCJwYXVzZVwiKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfS5iaW5kKHRoaXMpO1xuXG4gIHRoaXMucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHJ1bm5pbmcgPT09IHRydWUpIHJldHVybiB0aGlzO1xuICAgIHJ1bm5pbmcgPSB0cnVlO1xuICAgIGxhc3RUaWNrID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgdGhpcy50aWNrKCk7XG4gICAgdGhpcy50cmlnZ2VyKFwicmVzdW1lXCIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LmJpbmQodGhpcyk7XG5cbiAgdGhpcy5jbG9ja1NjYWxhciA9IGZ1bmN0aW9uKG11bHRpcGxpZXIpIHtcbiAgICAvLyBhIHJlbGF0aXZlIHdheSB0byBhZmZlY3QgdGhlIGNsb2NrXG4gICAgY2xvY2tzcGVlZCAqPSBtdWx0aXBsaWVyIHx8IDE7XG4gIH07XG5cbiAgdGhpcy5zZXRDbG9ja1NwZWVkID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAvLyBmb3IgbWFudWFsbHkgZW50ZXJpbmcgYSBzcGVlZCB2YWx1ZVxuICAgIGNsb2Nrc3BlZWQgPSB2YWx1ZSB8fCBjbG9ja3NwZWVkO1xuICB9O1xuXG4gIHRoaXMuZW5hYmxlUGF1c2VPbkJsdXIgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBjYWxsZWQgb24gc3RhcnRcbiAgICAvLyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgbmF0aXZlbHkgcGF1c2VzIG9uYmx1ciwgYnV0LCB0aGlzIGNsb2NrIGRvZXNuJ3RcbiAgICAvLyBzbyBJJ3ZlIHByb2dyYW1tZWQgdGhlIGZ1bmN0aW9uYWxpdHkgaW50byBpdC4gXG5cbiAgICB3aW5kb3cub25ibHVyID0gZnVuY3Rpb24oKXtzZWxmLnBhdXNlKCk7fVxuICAgIHdpbmRvdy5vbmZvY3VzID0gZnVuY3Rpb24oKXtzZWxmLnJlc3VtZSgpO307XG4gIH07XG5cbiAgdGhpcy5kaXNhYmxlUGF1c2VPbkJsdXIgPSBmdW5jdGlvbigpe1xuICAgIHdpbmRvdy5vbmJsdXIgPSBmdW5jdGlvbigpe3JldHVybiBudWxsfTtcbiAgICB3aW5kb3cub25mb2N1cyA9IGZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9O1xuICB9O1xuICBcbiAgdGhpcy50aWNrcyA9IGZ1bmN0aW9uKCl7IHJldHVybiB0aWNrczsgfTtcblxuICB0aGlzLm1pbGxpc2Vjb25kcyA9IGZ1bmN0aW9uKCl7IHJldHVybiBlbGFwc2VkVGltZTt9O1xuXG4gIHRoaXMuc2Vjb25kcyA9IGZ1bmN0aW9uKCl7IHJldHVybiBlbGFwc2VkVGltZSAvIDEwMDAgOyB9O1xuXG4gIHRoaXMubWludXRlcyA9IGZ1bmN0aW9uKCl7IHJldHVybiAodGhpcy5zZWNvbmRzKCkgLyA2MCk7IH07XG5cbiAgdGhpcy5kZWJ1ZyA9IG9wdGlvbnMuZGVidWcgfHwgZmFsc2U7XG5cbiAgLy8gaWYgZGVidWcgaXMgdHJ1ZSwgbG9nIGlzIGF1dG9tYXRpY2FsbHkgY2FsbGVkIGVhY2ggdGlja1xuICB0aGlzLmxvZyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgY29uc29sZS5jbGVhcigpO1xuICAgIGlmICh1c2VSQUYpIGNvbnNvbGUubG9nKFwiPFVzaW5nIHJlcXVlc3RBbmltYXRpb25GcmFtZT5cIik7XG4gICAgZWxzZSBjb25zb2xlLmxvZyhcIjxVc2luZyBzZXRUaW1lb3V0PlwiKTtcbiAgICBjb25zb2xlLmxvZyhcInRpY2tzOlwiLCB0aWNrcyk7XG4gICAgY29uc29sZS5sb2coXCJkZWx0YTpcIiwgZGVsdGEpO1xuICAgIGNvbnNvbGUubG9nKFwibGFzdFRpY2soc2hvdWxkIGNoYW5nZSlcIiwgfn5sYXN0VGljaylcbiAgICBjb25zb2xlLmxvZyhcImVsYXBzZWQgdGltZTpcIiwgZWxhcHNlZFRpbWUgLyAxMDAwKTtcbiAgICBjb25zb2xlLmxvZyhcImVsYXBzZWQgc2Vjb25kczpcIiwgfn4oZWxhcHNlZFRpbWUgLyAxMDAwKSk7XG4gICAgY29uc29sZS5sb2coXCJhY3R1YWwgZWxhcHNlZCB0aW1lOlwiLCBhY3R1YWxFbGFwc2VkVGltZSAvIDEwMDApO1xuICAgIGNvbnNvbGUud2FybihcIiVjZGlmZmVyZW5jZSAoaW4gc2Vjb25kcyk6IFwiICsgKHRoaXMuZXJyb3JNYXJnaW4gLyAxMDAwKSwgXCJjb2xvcjogI2EwMFwiICk7XG4gICAgY29uc29sZS5sb2coXCJJZ25vcmUgZGlmZmVyZW5jZXMgaWYgeW91IGhhdmUgY2FsbGVkIHBhdXNlIGF0IGFueSB0aW1lLlwiKTtcbiAgICBjb25zb2xlLmxvZyhcIkVzdGltYXRlZCBGUFM6XCIsIH5+KHRpY2tzIC8gKCBlbGFwc2VkVGltZSAvIDEwMDAgKSkpO1xuICB9O1xuXG4gIHRoaXMudGltZSA9IHRoaXMubm93ID0gZnVuY3Rpb24oKXsgcmV0dXJuIGVsYXBzZWRUaW1lOyB9O1xuXG5cblxuICAvKiAgRXZlbnQtcmVsYXRlZCBtZXRob2RzICAqL1xuICBcbiAgdGhpcy50cmlnZ2VyID0gZnVuY3Rpb24oZXZlbnROYW1lKSB7XG5cbiAgICBpZiAoZXZlbnRzLm5vbWluYWxbZXZlbnROYW1lXSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcztcblxuICAgIHZhciBsID0gZXZlbnRzLm5vbWluYWxbZXZlbnROYW1lXS5sZW5ndGhcblxuICAgIGZvciAodmFyIF94ID0gMCwgX3h4ID0gbDsgX3ggPCBfeHg7IF94KyspIHtcblxuICAgICAgLy8gd293LCBtdWNoIGxlbmd0aCwgbWFueSBjaGFycywgc3VjaCBzY2FyeS5cbiAgICAgIHZhciBmbiA9IGV2ZW50cy5ub21pbmFsW2V2ZW50TmFtZV1bX3hdLmZuLFxuICAgICAgICAgIGN0eCA9IGV2ZW50cy5ub21pbmFsW2V2ZW50TmFtZV1bX3hdLmNvbnRleHQsXG4gICAgICAgICAgYXJncyA9IGV2ZW50cy5ub21pbmFsW2V2ZW50TmFtZV1bX3hdLmFyZ3M7XG5cbiAgICAgIGZuLmFwcGx5KGN0eCwgYXJncyk7XG5cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdGhpcy5vbiA9IGZ1bmN0aW9uKCBldmVudE5hbWUsIGZuIC8qIFssIGFyZ3MsIGNvbnRleHQgXSAqLyApIHtcblxuICAgIHZhciBjb250ZXh0ID0gYXJndW1lbnRzWzNdIHx8IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHNbMl0gfHwgW107XG5cbiAgICAvLyBjcmVhdGUgYW4gYXJyYXkgZm9yIHRoZSBldmVudFxuICAgIGV2ZW50cy5ub21pbmFsW2V2ZW50TmFtZV0gPSBldmVudHMubm9taW5hbFtldmVudE5hbWVdIHx8IFtdXG5cbiAgICB2YXIgc2NvcGUgPSB0aGlzOyAvLyBhbGwgZXZlbnRzIGRlZmF1bHQgdG8gdGhlIHNjb3BlIG9mIHRoZSBUaW1lbGluZSBvYmplY3QuXG5cbiAgICBldmVudHMubm9taW5hbFtldmVudE5hbWVdLnB1c2goe1xuICAgICAgJ2ZuJzogZm4sXG4gICAgICAnYXJncyc6IGFyZ3MsXG4gICAgICAnY29udGV4dCc6IGNvbnRleHRcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB0aGlzLmF0ID0gZnVuY3Rpb24oIGVsYXBzZWRNUywgZm4gLyogWywgYXJncywgY29udGV4dCBdICovICkge1xuICAgIGlmIChlbGFwc2VkTVMgPT09IHVuZGVmaW5lZCkge3Rocm93IG5ldyBFcnJvcihcImF0KCkgbWV0aG9kIHJlcXVpcmVzIGEgY2xvY2stdGltZSBwYXNzZWQgaW4gYXMgZmlyc3QgcGFyYW1ldGVyLlwiKTsgcmV0dXJuO31cbiAgICBpZiAoZm4gPT09IHVuZGVmaW5lZCkge3Rocm93IG5ldyBFcnJvcihcImF0KCkgbWV0aG9kIHJlcXVpcmVzIGEgZnVuY3Rpb24gcGFzc2VkIGluIGFzIHNlY29uZCBwYXJhbWV0ZXIuXCIpOyByZXR1cm47fVxuXG4gICAgdmFyIGNvbnRleHQgPSBhcmd1bWVudHNbM10gfHwgbnVsbCwgYXJncyA9IGFyZ3VtZW50c1syXSB8fCB0aGlzO1xuXG4gICAgdmFyIGFkZFRpbWUgPSBmdW5jdGlvbiggdGltZSApIHtcblxuICAgICAgdmFyIHQgPSB0aW1lLnRvU3RyaW5nKCk7XG4gICAgICBldmVudHMub3JkaW5hbFsgdGltZSBdID0gZXZlbnRzLm9yZGluYWxbIHRpbWUgXSB8fCBbXTtcbiAgICAgIGV2ZW50cy5vcmRpbmFsWyB0aW1lIF0ucHVzaCh7XG4gICAgICAgIFwiZm5cIjogZm4sXG4gICAgICAgIFwiY29udGV4dFwiOiBjb250ZXh0LFxuICAgICAgICBcImFyZ3NcIjogYXJnc1xuICAgICAgfSk7XG5cbiAgICB9O1xuXG4gICAgaWYgKCAhaXNBcnJheShlbGFwc2VkTVMpICkge1xuICAgICAgYWRkVGltZSggZWxhcHNlZE1TICk7XG4gICAgICBcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfVxuXG4gICAgICBlbGFwc2VkTVMuZm9yRWFjaCggYWRkVGltZSApO1xuXG5cbiAgICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHRoaXMuYWZ0ZXIgPSBmdW5jdGlvbiggbWlsbGlzZWNvbmRzLCBmbiAvKiBbLCBhcmdzLCBjb250ZXh0IF0gKi8gKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHNbMl0sIGNvbnRleHQgPSBhcmd1bWVudHNbM107XG4gICAgdGhpcy5hdCggZWxhcHNlZFRpbWUgKyBtaWxsaXNlY29uZHMsIGZuLCBhcmdzLCBjb250ZXh0ICk7XG4gIH07XG5cbiAgdGhpcy5sb29wID0gZnVuY3Rpb24oIHVuaXF1ZU5hbWUsIGZuLCBhcmdzLCBzY29wZSApIHtcblxuICAgIC8qXG4gICAgICAgIHRoaXMubG9vcCgpIHJldHVybnMgYSBuZXcgbG9vcCBvYmplY3QsIHdoaWNoIHRvIGFsdGVyIHRpbWluZy1yZWxhdGVkIG9wdGlvbnNcbiAgICAgICAgeW91IGNhbGwgaXQncyAuZm9yKCkgbWV0aG9kLiBcbiAgICAgICAgXG4gICAgICAgIEVYOlxuICAgICAgICB2YXIgeCA9IHRoaXMubG9vcCgqYXJncykuZm9yKCphcmdzKTtcbiAgICAqL1xuXG4gICAgaWYgKCF1bmlxdWVOYW1lKSByZXR1cm4gdGhpcztcblxuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgZGVmYXVsdHMgPSB7XG4gICAgICAgICAgXCJhdXRvc3RhcnRcIjogdHJ1ZSxcbiAgICAgICAgICBcInN0YXJ0XCI6IH5+ZWxhcHNlZFRpbWUsXG4gICAgICAgICAgXCJzdG9wXCI6IEluZmluaXR5LCBcbiAgICAgICAgICBcImludGVydmFsXCI6IEluZmluaXR5LCBcbiAgICAgICAgICBcIm1heEludGVydmFsc1wiOiBJbmZpbml0eSwgXG4gICAgICAgICAgXCJkdXJhdGlvblwiOiAwLCBcbiAgICAgICAgICBcImNhbGxlZEF0XCI6IFtdLFxuICAgICAgICAgIFwic3RhcnREZWxheVwiOiAwXG4gICAgICAgIH0sXG4gICAgICAgIHJlcXVpcmVkID0ge1xuICAgICAgICAgIFwibmFtZVwiOnVuaXF1ZU5hbWUsXG4gICAgICAgICAgXCJmblwiOiBmbixcbiAgICAgICAgICBcInNjb3BlXCI6IHNjb3BlIHx8IHNlbGYsXG4gICAgICAgICAgXCJjYWxsc1wiOiAwLFxuICAgICAgICAgIFwicGFyZW50XCI6IHNlbGYsXG4gICAgICAgICAgXCJhcmdzXCI6IGFyZ3MgfHwgW11cbiAgICAgICAgfTtcblxuICAgIC8vIHRoZSBsb29wIG9iamVjdCB0aGF0IHdpbGwgYmUgcmV0dXJuZWRcbiAgICB2YXIgTG9vcCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblxuXG4gICAgICBleHRlbmQodGhpcywgZGVmYXVsdHMsIHJlcXVpcmVkKTtcblxuICAgICAgLy8gdGhlIGNoZWNrIHRvIGRldGVybWluZSBpZiB0aGUgbG9vcCBpcyBjYWxsZWRcbiAgICAgIHRoaXMuY2hlY2tJbnRlcnZhbCA9IGZ1bmN0aW9uKG5vdykge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnN0YXJ0LFxuICAgICAgICAgICAgaW50ZXJ2YWwgPSB0aGlzLmludGVydmFsLFxuICAgICAgICAgICAgZHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgZG9lc0ludGVydmFsTWF0Y2hOb3cgPSAobm93IC0gKHN0YXJ0ICsgdGhpcy5zdGFydERlbGF5KSkgICUgKGludGVydmFsICsgZHVyYXRpb24pLFxuICAgICAgICAgICAgaW50ZXJ2YWxIYXNQYXNzZWQgPSBub3cgLSAodGhpcy5sYXN0Q2FsbCA9PT0gdW5kZWZpbmVkID8gc3RhcnQgOiB0aGlzLmxhc3RDYWxsKTtcbiAgXG4gICAgICAgIC8qXG4gICAgICAgIGNvbnNvbGUuY2xlYXIoKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJuYW1lOlwiLCB0aGlzLm5hbWUpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIkRlbHRhOlwiLCBzZWxmLmRlbHRhICk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiLS0tLS1cIik7XG4gICAgICAgIGNvbnNvbGUubG9nKFwic3RhcnQ6XCIsIHN0YXJ0KTtcbiAgICAgICAgY29uc29sZS5sb2coXCJkb2VzSW50ZXJ2YWxNYXRjaE5vd1wiLCBkb2VzSW50ZXJ2YWxNYXRjaE5vdyk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiaW50ZXJ2YWw6XCIsIGludGVydmFsKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJub3c6XCIsIG5vdyk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwibGFzdENhbGwnZWQ6XCIsIHRoaXMubGFzdENhbGwpO1xuICAgICAgICAqL1xuICAgICAgICBcbiAgICAgICAgaWYgKCBkb2VzSW50ZXJ2YWxNYXRjaE5vdyA+PSAwICYmIGRvZXNJbnRlcnZhbE1hdGNoTm93IDw9IGRlbHRhICYmIChub3cgLSB0aGlzLmxhc3RDYWxsKSA+IChpbnRlcnZhbCowLjk5KSApIHJldHVybiB0cnVlO1xuICAgICAgICBlbHNlIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuZm9yID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBleHRlbmQodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMubGFzdENhbGwgPSB0aGlzLnN0YXJ0IC0gdGhpcy5pbnRlcnZhbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmRlbGV0ZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICB2YXIgbCA9IG5ldyBMb29wKCk7XG5cbiAgICBldmVudHMubG9vcHNbIGwubmFtZSBdID0gbDtcblxuICAgIHJldHVybiBsO1xuICB9O1xuXG4gIHRoaXMucmVtb3ZlID0gIHRoaXMub2ZmID0gZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgIGlmICh0eXBlb2YgZXZlbnQgPT09IFwibnVtYmVyXCIpIHtcblxuICAgICAgaWYgKGV2ZW50cy5vcmRpbmFsW2V2ZW50XSA9PT0gdW5kZWZpbmVkKSByZXR1cm4ge1wicmVtb3ZlZFwiOmZhbHNlLCBcImN0eFwiOiB0aGlzfTtcblxuICAgICAgZGVsZXRlIGV2ZW50cy5vcmRpbmFsW2V2ZW50XTtcbiAgICAgIHJldHVybiB7XCJyZW1vdmVkXCI6dHJ1ZSwgXCJjdHhcIjogdGhpc307XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBldmVudCA9PT0gXCJzdHJpbmdcIikge1xuXG4gICAgICAvLyBpZiBpdCBpcyBhIGV2ZW50IHNldCB3aXRoIG9uKCk6XG4gICAgICBpZiAoZXZlbnRzLm5vbWluYWxbZXZlbnROYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgLy9pZiBpdCBpcyBhIGxvb3AgZXZlbnQgXG4gICAgICAgIGlmIChldmVudHMubG9vcHNbZXZlbnROYW1lXSA9PT0gdW5kZWZpbmVkKSByZXR1cm4ge1wicmVtb3ZlZFwiOmZhbHNlLCBcImN0eFwiOiB0aGlzfTtcblxuICAgICAgICAvLyBsb29wcyB0ZXJtaW5hdGUgdGhlbXNlbHZlcyBhdXRvbWF0aWNhbGx5IHdoZW4gc2V0IHRvIGRlbGV0ZVxuICAgICAgICBldmVudHMubG9vcHNbZXZlbnROYW1lXS5kZWxldGUgPSB0cnVlO1xuICAgICAgICByZXR1cm4ge1wicmVtb3ZlZFwiOnRydWUsIFwiY3R4XCI6IHRoaXN9O1xuICAgICAgfVxuXG4gICAgICBkZWxldGUgZXZlbnRzLm5vbWluYWxbZXZlbnROYW1lXTtcbiAgICAgIHJldHVybiB7XCJyZW1vdmVkXCI6dHJ1ZSwgXCJjdHhcIjogdGhpc307XG4gICAgfSBcbiAgfTtcblxuICB0aGlzLmRlZmVyID0gZnVuY3Rpb24oZm4pe1xuICAgIC8vIHdhaXRzIGZvciB0aGUgY3VycmVudCBzdGFjayB0byBjbGVhclxuICAgIHdpbmRvdy5zZXRUaW1lb3V0KDAsIGZuKVxuICB9O1xuXG4gIHRoaXMuZ2V0RXZlbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gaW4gY2FzZSBzb21lb25lIHdhbnRzIHRvIHZpZXcgdGhlIGludGVybmFsbHkgc2V0IGV2ZW50c1xuICAgIHJldHVybiBldmVudHM7XG4gIH07XG5cbiAgLyogKiAqICogKiAqICogKiAqICogKiAqICogKlxuXG4gICAgYmluZFRvRnVuY3Rpb246XG5cbiAgICBBdHRhY2ggJ3dhaXQnIG1ldGhvZCB0byB0aGUgRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIGRlbGVnYXRpbmcgdG8gdGhlIHRpbWVsaW5lJ3MgPHRoaXM+LmFmdGVyKCkgbWV0aG9kLlxuICAgIFVzZWZ1bD8gQ291bGQgYmUuIEludmFzaXZlIG9mIGdsb2JhbCBwcm90b3R5cGVzPyBEZWYuXG5cbiAgKiAqICogKiAqICogKiAqICogKiAqICogKiAqL1xuICBcbiAgaWYgKG9wdGlvbnMuYmluZFRvRnVuY3Rpb24gPT09IHRydWUpIHtcblxuICAgICAgdmFyIF90ID0gdGhpczsgLy8gcmVmZXJlbmNlLCBzaW5jZSB3YWl0IGlzIGluIHRoZSBjb250ZXh0IG9mIHRoZSBjYWxsZWVcblxuICAgICAgdmFyIHdhaXQgPSBmdW5jdGlvbihzZWNvbmRzLCBhcmdzLCBjb250ZXh0KSB7XG4gICAgICAgIF90LmFmdGVyKHNlY29uZHMsIHRoaXMsIGFyZ3MsIGNvbnRleHQpOyBcbiAgICAgIH07XG4gICAgICBcbiAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZS53YWl0ID0gd2FpdDtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmF1dG9zdGFydCA9PT0gdHJ1ZSkgdGhpcy5zdGFydCgpO1xuICBlbHNlIHJldHVybiB0aGlzO1xufTtcbiAgIFxuXG5tb2R1bGUuZXhwb3J0cyA9IENsb2NrO1xuIiwiXG4vKlxuIyBASW5wdXRJbnRlcmZhY2VcbiNcbiovXG5cblxuKGZ1bmN0aW9uKCkge1xuICB2YXIgdXRpbHM7XG5cbiAgdXRpbHMgPSByZXF1aXJlKFwiLi9fdXRpbHNcIik7XG5cbiAgbW9kdWxlLmV4cG9ydHMuSW50ZXJmYWNlID0gZnVuY3Rpb24oY2FudmFzLCBwYXJlbnQsIGVuZ2luZSkge1xuICAgIHZhciAkZWwsIGJvdW5kLCBoYW5kbGVyLCBrZXksIG1vdXNlbW92ZUhhbmRsZXIsIHNjb3BlO1xuICAgIGlmICghJCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgJGVsID0gJChjYW52YXMpO1xuICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICB0aGlzLmVuZ2luZSA9IGVuZ2luZTtcbiAgICAgIHNjb3BlID0gZW5naW5lO1xuICAgIH0gZWxzZSB7XG4gICAgICAkZWwgPSAkKHBhcmVudC5yZW5kZXJlci5kb21FbGVtZW50KTtcbiAgICAgIHRoaXMucGFyZW50ID0gY2FudmFzO1xuICAgICAgdGhpcy5lbmdpbmUgPSBwYXJlbnQ7XG4gICAgICBzY29wZSA9IHBhcmVudDtcbiAgICB9XG4gICAga2V5ID0ge1xuICAgICAgXCJsZWZ0Q2xpY2tcIjogMSxcbiAgICAgIFwic2Nyb2xsd2hlZWxcIjogMixcbiAgICAgIFwicmlnaHRDbGlja1wiOiAzLFxuICAgICAgJ2JhY2tzcGFjZSc6IDgsXG4gICAgICAndGFiJzogOSxcbiAgICAgICdlbnRlcic6IDEzLFxuICAgICAgJ3NoaWZ0JzogMTYsXG4gICAgICAnY3RybCc6IDE3LFxuICAgICAgJ2FsdCc6IDE4LFxuICAgICAgJ3BhdXNlJzogMTksXG4gICAgICAnY2Fwc2xvY2snOiAyMCxcbiAgICAgICdlc2MnOiAyNyxcbiAgICAgICdwYWdldXAnOiAzMyxcbiAgICAgICdwYWdlZG93bic6IDM0LFxuICAgICAgJ2VuZCc6IDM1LFxuICAgICAgJ2hvbWUnOiAzNixcbiAgICAgICdsZWZ0JzogMzcsXG4gICAgICAndXAnOiAzOCxcbiAgICAgICdyaWdodCc6IDM5LFxuICAgICAgJ2Rvd24nOiA0MCxcbiAgICAgICdpbnNlcnQnOiA0NSxcbiAgICAgICdkZWxldGUnOiA0NixcbiAgICAgICcwJzogNDgsXG4gICAgICAnMSc6IDQ5LFxuICAgICAgJzInOiA1MCxcbiAgICAgICczJzogNTEsXG4gICAgICAnNCc6IDUyLFxuICAgICAgJzUnOiA1MyxcbiAgICAgICc2JzogNTQsXG4gICAgICAnNyc6IDU1LFxuICAgICAgJzgnOiA1NixcbiAgICAgICc5JzogNTcsXG4gICAgICAnYSc6IDY1LFxuICAgICAgJ2InOiA2NixcbiAgICAgICdjJzogNjcsXG4gICAgICAnZCc6IDY4LFxuICAgICAgJ2UnOiA2OSxcbiAgICAgICdmJzogNzAsXG4gICAgICAnZyc6IDcxLFxuICAgICAgJ2gnOiA3MixcbiAgICAgICdpJzogNzMsXG4gICAgICAnaic6IDc0LFxuICAgICAgJ2snOiA3NSxcbiAgICAgICdsJzogNzYsXG4gICAgICAnbSc6IDc3LFxuICAgICAgJ24nOiA3OCxcbiAgICAgICdvJzogNzksXG4gICAgICAncCc6IDgwLFxuICAgICAgJ3EnOiA4MSxcbiAgICAgICdyJzogODIsXG4gICAgICAncyc6IDgzLFxuICAgICAgJ3QnOiA4NCxcbiAgICAgICd1JzogODUsXG4gICAgICAndic6IDg2LFxuICAgICAgJ3cnOiA4NyxcbiAgICAgICd4JzogODgsXG4gICAgICAneSc6IDg5LFxuICAgICAgJ3onOiA5MCxcbiAgICAgICdudW1wYWQwJzogOTYsXG4gICAgICAnbnVtcGFkMSc6IDk3LFxuICAgICAgJ251bXBhZDInOiA5OCxcbiAgICAgICdudW1wYWQzJzogOTksXG4gICAgICAnbnVtcGFkNCc6IDEwMCxcbiAgICAgICdudW1wYWQ1JzogMTAxLFxuICAgICAgJ251bXBhZDYnOiAxMDIsXG4gICAgICAnbnVtcGFkNyc6IDEwMyxcbiAgICAgICdudW1wYWQ4JzogMTA0LFxuICAgICAgJ251bXBhZDknOiAxMDUsXG4gICAgICAnbXVsdGlwbHknOiAxMDYsXG4gICAgICAncGx1cyc6IDEwNyxcbiAgICAgICdtaW51dCc6IDEwOSxcbiAgICAgICdkb3QnOiAxMTAsXG4gICAgICAnc2xhc2gxJzogMTExLFxuICAgICAgJ0YxJzogMTEyLFxuICAgICAgJ0YyJzogMTEzLFxuICAgICAgJ0YzJzogMTE0LFxuICAgICAgJ0Y0JzogMTE1LFxuICAgICAgJ0Y1JzogMTE2LFxuICAgICAgJ0Y2JzogMTE3LFxuICAgICAgJ0Y3JzogMTE4LFxuICAgICAgJ0Y4JzogMTE5LFxuICAgICAgJ0Y5JzogMTIwLFxuICAgICAgJ0YxMCc6IDEyMSxcbiAgICAgICdGMTEnOiAxMjIsXG4gICAgICAnRjEyJzogMTIzLFxuICAgICAgJ2VxdWFsJzogMTg3LFxuICAgICAgJ2NvbWEnOiAxODgsXG4gICAgICAnc2xhc2gnOiAxOTEsXG4gICAgICAnYmFja3NsYXNoJzogMjIwXG4gICAgfTtcbiAgICBib3VuZCA9IHt9O1xuICAgIGhhbmRsZXIgPSBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgYiwga2V5bmFtZTtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGUucG9zaXRpb24gPSB1dGlscy5nZXRNb3VzZVBvc2l0aW9uKGUpO1xuICAgICAgYiA9IGJvdW5kW2UudHlwZV07XG4gICAgICBpZiAoIWIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yIChrZXluYW1lIGluIGIpIHtcbiAgICAgICAgaWYgKGtleVtrZXluYW1lXSA9PT0gZS53aGljaCkge1xuICAgICAgICAgIGJba2V5bmFtZV0uY2FsbGJhY2suY2FsbChiW2tleW5hbWVdLCBlLCBiW2tleW5hbWVdLmRhdGEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgbW91c2Vtb3ZlSGFuZGxlciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciBiLCBkYXRhO1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZS5wb3NpdGlvbiA9IHV0aWxzLmdldE1vdXNlUG9zaXRpb24oZSk7XG4gICAgICBiID0gYm91bmRbXCJtb3VzZW1vdmVcIl07XG4gICAgICBkYXRhID0gYi5kYXRhIHx8IHt9O1xuICAgICAgYi5jYWxsYmFjay5jYWxsKHBhcmVudCwgZSwgZGF0YSk7XG4gICAgfTtcbiAgICB0aGlzLmJpbmQgPSB0aGlzLm9uID0gZnVuY3Rpb24oZXZlbnRzLCBrZXluYW1lLCBjYWxsYmFjaywgZGF0YSkge1xuICAgICAgdmFyIGIsIGV2ZW50VHlwZSwgX2V2ZW50cywgX2ksIF9sZW47XG4gICAgICBpZiAoIShhcmd1bWVudHMubGVuZ3RoID49IDIpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIF9ldmVudHMgPSBldmVudHMuc3BsaXQoXCIgXCIpO1xuICAgICAgaWYgKF9ldmVudHNbMF0gPT09IFwibW91c2Vtb3ZlXCIpIHtcbiAgICAgICAgYm91bmRbXCJtb3VzZW1vdmVcIl0gPSB7XG4gICAgICAgICAgXCJjYWxsYmFja1wiOiBrZXluYW1lLFxuICAgICAgICAgIFwiZGF0YVwiOiBjYWxsYmFja1xuICAgICAgICB9O1xuICAgICAgICAkZWwub24oXCJtb3VzZW1vdmVcIiwgbW91c2Vtb3ZlSGFuZGxlcik7XG4gICAgICB9XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9ldmVudHMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgZXZlbnRUeXBlID0gX2V2ZW50c1tfaV07XG4gICAgICAgIGIgPSBib3VuZFtldmVudFR5cGVdID0gYm91bmRbZXZlbnRUeXBlXSB8fCB7fTtcbiAgICAgICAgYltrZXluYW1lXSA9IHtcbiAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICB9O1xuICAgICAgICAkZWwub24oZXZlbnRUeXBlLCBoYW5kbGVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgdGhpcy51bmJpbmQgPSB0aGlzLm9mZiA9IGZ1bmN0aW9uKGV2ZW50cywga2V5bmFtZSkge1xuICAgICAgdmFyIGV2ZW50VHlwZSwgX2V2ZW50cywgX2ksIF9sZW47XG4gICAgICBfZXZlbnRzID0gZXZlbnRzLnNwbGl0KFwiIFwiKTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX2V2ZW50cy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBldmVudFR5cGUgPSBfZXZlbnRzW19pXTtcbiAgICAgICAgJGVsLm9mZihldmVudFR5cGUsIGhhbmRsZXIpO1xuICAgICAgICBkZWxldGUgYm91bmRbZXZlbnRUeXBlXVtrZXluYW1lXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgdGhpcy50cmlnZ2VyID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICRlbC50cmlnZ2VyKGV2ZW50KTtcbiAgICAgIHJldHVybiBib3VuZFtldmVudF07XG4gICAgfTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cy5Nb3VzZURldGVjdGlvbiA9IGZ1bmN0aW9uKHBhcmVudCwgZW5naW5lLCBtdWx0aXNlbGVjdCwgY2xlYXJBZnRlckVtcHR5U2VsZWN0aW9uKSB7XG4gICAgdmFyIGNhbWVyYSwgY2xpY2tIYW5kbGVyLCBlbmFibGVkLCBnZXRJbnRlcnNlY3Rpb25zLCBoYW5kbGVyLCBpbnB1dCwgbGFzdENsaWNrSW50ZXJzZWN0LCBsYXN0SG92ZXJJbnRlcnNlY3QsIG1vdXNlbW92ZUhhbmRsZXIsIHByb2plY3Rvciwgc2VsZWN0ZWRPYmplY3RzLCBzdGFnZSwgdGhhdDtcbiAgICBpZiAobXVsdGlzZWxlY3QgPT0gbnVsbCkge1xuICAgICAgbXVsdGlzZWxlY3QgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoY2xlYXJBZnRlckVtcHR5U2VsZWN0aW9uID09IG51bGwpIHtcbiAgICAgIGNsZWFyQWZ0ZXJFbXB0eVNlbGVjdGlvbiA9IHRydWU7XG4gICAgfVxuICAgIGVuYWJsZWQgPSBmYWxzZTtcbiAgICBzdGFnZSA9IHBhcmVudDtcbiAgICBpbnB1dCA9IHBhcmVudC5JbnB1dDtcbiAgICBjYW1lcmEgPSBwYXJlbnQuY2FtZXJhO1xuICAgIHByb2plY3RvciA9IG5ldyBUSFJFRS5Qcm9qZWN0b3IoKTtcbiAgICB0aGlzLmludGVyc2VjdGlvbnMgPSBudWxsO1xuICAgIGxhc3RIb3ZlckludGVyc2VjdCA9IG51bGw7XG4gICAgbGFzdENsaWNrSW50ZXJzZWN0ID0gbnVsbDtcbiAgICBzZWxlY3RlZE9iamVjdHMgPSBbXTtcbiAgICB0aGF0ID0gdGhpcztcbiAgICB0aGlzLm1vdXNlbW92ZSA9IHRydWU7XG4gICAgdGhpcy5jbGljayA9IHRydWU7XG4gICAgdGhpcy5tdWx0aXNlbGVjdCA9IG11bHRpc2VsZWN0O1xuICAgIHRoaXMuY2xlYXJBZnRlckVtcHR5U2VsZWN0aW9uID0gY2xlYXJBZnRlckVtcHR5U2VsZWN0aW9uO1xuICAgIGdldEludGVyc2VjdGlvbnMgPSBmdW5jdGlvbihtb3VzZSwgY2FtZXJhKSB7XG4gICAgICB2YXIgZGlyZWN0aW9uLCBpbnRlcnNlY3Rpb25zLCByYXljYXN0ZXIsIHZlY3RvcjtcbiAgICAgIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKG1vdXNlLm5vcm1hbGl6ZWQueCwgbW91c2Uubm9ybWFsaXplZC55LCAxKTtcbiAgICAgIHByb2plY3Rvci51bnByb2plY3RWZWN0b3IodmVjdG9yLCBjYW1lcmEpO1xuICAgICAgZGlyZWN0aW9uID0gdmVjdG9yLnN1YihjYW1lcmEucG9zaXRpb24pLm5vcm1hbGl6ZSgpO1xuICAgICAgcmF5Y2FzdGVyID0gbmV3IFRIUkVFLlJheWNhc3RlcihjYW1lcmEucG9zaXRpb24sIGRpcmVjdGlvbik7XG4gICAgICBpbnRlcnNlY3Rpb25zID0gcmF5Y2FzdGVyLmludGVyc2VjdE9iamVjdHMoc3RhZ2UubWVzaGVzKTtcbiAgICAgIHJldHVybiBpbnRlcnNlY3Rpb25zO1xuICAgIH07XG4gICAgaGFuZGxlciA9IGZ1bmN0aW9uKGUsIGNhbWVyYSkge1xuICAgICAgdmFyIGludGVyc2VjdGlvbnMsIG1vdXNlO1xuICAgICAgbW91c2UgPSBlLnBvc2l0aW9uO1xuICAgICAgaW50ZXJzZWN0aW9ucyA9IGdldEludGVyc2VjdGlvbnMobW91c2UsIGNhbWVyYSk7XG4gICAgICBpZiAoZS50eXBlID09PSBcIm1vdXNlbW92ZVwiKSB7XG4gICAgICAgIGlmICh0aGF0Lm1vdXNlbW92ZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBtb3VzZW1vdmVIYW5kbGVyKGludGVyc2VjdGlvbnMsIG1vdXNlLCBjYW1lcmEsIGUpO1xuICAgICAgfSBlbHNlIGlmIChlLnR5cGUgPT09IFwiY2xpY2tcIikge1xuICAgICAgICBpZiAodGhhdC5jbGljayAhPT0gdHJ1ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjbGlja0hhbmRsZXIoaW50ZXJzZWN0aW9ucywgbW91c2UsIGNhbWVyYSwgZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIG1vdXNlbW92ZUhhbmRsZXIgPSBmdW5jdGlvbihpbnRlcnNlY3Rpb25zLCBtb3VzZSwgY2FtZXJhLCBlKSB7XG4gICAgICB2YXIgaW50ZXJzZWN0O1xuICAgICAgaWYgKGludGVyc2VjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlmIChsYXN0SG92ZXJJbnRlcnNlY3QgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGFzdEhvdmVySW50ZXJzZWN0LmRpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgIHR5cGU6IFwibGVhdmVcIlxuICAgICAgICB9KTtcbiAgICAgICAgbGFzdEhvdmVySW50ZXJzZWN0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaW50ZXJzZWN0ID0gaW50ZXJzZWN0aW9uc1swXS5vYmplY3Q7XG4gICAgICBpbnRlcnNlY3QuZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgIHR5cGU6IFwiaG92ZXJcIlxuICAgICAgfSk7XG4gICAgICBpZiAobGFzdEhvdmVySW50ZXJzZWN0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBsYXN0SG92ZXJJbnRlcnNlY3QgPSBpbnRlcnNlY3Q7XG4gICAgICB9IGVsc2UgaWYgKGxhc3RIb3ZlckludGVyc2VjdCAhPT0gaW50ZXJzZWN0KSB7XG4gICAgICAgIGxhc3RIb3ZlckludGVyc2VjdC5kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICB0eXBlOiBcImxlYXZlXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBsYXN0SG92ZXJJbnRlcnNlY3QgPSBpbnRlcnNlY3Q7XG4gICAgICB9XG4gICAgfTtcbiAgICBjbGlja0hhbmRsZXIgPSBmdW5jdGlvbihpbnRlcnNlY3Rpb25zLCBtb3VzZSwgY2FtZXJhLCBlKSB7XG4gICAgICAvKiBkZWFsIHdpdGggdGhpbmdzIHRoYXQgd2VyZW4ndCBzZWxlY3RlZFxuICAgICAgKi9cblxuICAgICAgdmFyIGludGVyc2VjdDtcbiAgICAgIGlmIChpbnRlcnNlY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZiAobGFzdENsaWNrSW50ZXJzZWN0ID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGF0LmNsZWFyQWZ0ZXJFbXB0eVNlbGVjdGlvbiAhPT0gdHJ1ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhhdC5tdWx0aXNlbGVjdCAhPT0gdHJ1ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZWxlY3RlZE9iamVjdHMuZm9yRWFjaChmdW5jdGlvbihlbCkge1xuICAgICAgICAgIHJldHVybiBlbC5kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgIHR5cGU6IFwiY2xlYXJcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgc2VsZWN0ZWRPYmplY3RzID0gW107XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGludGVyc2VjdCA9IGludGVyc2VjdGlvbnNbMF0ub2JqZWN0O1xuICAgICAgaW50ZXJzZWN0LmRpc3BhdGNoRXZlbnQoe1xuICAgICAgICB0eXBlOiBcImNsaWNrXCJcbiAgICAgIH0pO1xuICAgICAgaWYgKGxhc3RDbGlja0ludGVyc2VjdCA9PT0gbnVsbCkge1xuICAgICAgICBsYXN0Q2xpY2tJbnRlcnNlY3QgPSBpbnRlcnNlY3Q7XG4gICAgICAgIGlmICh0aGF0Lm11bHRpc2VsZWN0ICE9PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNlbGVjdGVkT2JqZWN0cy5wdXNoKGludGVyc2VjdCk7XG4gICAgICB9IGVsc2UgaWYgKGxhc3RDbGlja0ludGVyc2VjdCAhPT0gaW50ZXJzZWN0KSB7XG4gICAgICAgIGxhc3RDbGlja0ludGVyc2VjdC5kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICB0eXBlOiBcImxlYXZlXCJcbiAgICAgICAgfSk7XG4gICAgICAgIGxhc3RDbGlja0ludGVyc2VjdCA9IGludGVyc2VjdDtcbiAgICAgICAgaWYgKHRoYXQubXVsdGlzZWxlY3QgIT09IHRydWUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2VsZWN0ZWRPYmplY3RzLnB1c2goaW50ZXJzZWN0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMudG9nZ2xlID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmFibGUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMub2ZmID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgICBlbmFibGVkID0gZmFsc2U7XG4gICAgICAgIGlucHV0Lm9mZihcIm1vdXNlbW92ZVwiLCBoYW5kbGVyLCBjYW1lcmEpO1xuICAgICAgICBpbnB1dC5vZmYoXCJjbGlja1wiLCBoYW5kbGVyLCBjYW1lcmEpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5vbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICAgIGVuYWJsZWQgPSB0cnVlO1xuICAgICAgICBpbnB1dC5vbihcIm1vdXNlbW92ZVwiLCBoYW5kbGVyLCBjYW1lcmEpO1xuICAgICAgICBpbnB1dC5vbihcImNsaWNrXCIsIFwibGVmdENsaWNrXCIsIGhhbmRsZXIsIGNhbWVyYSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLm9uKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbn0pLmNhbGwodGhpcyk7XG5cbi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS41LjAtcHJlXG4iLCIoZnVuY3Rpb24oKSB7XG4gIHZhciBTZWxlY3RvciwgU2t5Ym94LCBfY2xhc3M7XG5cbiAgbW9kdWxlLmV4cG9ydHMuU2VsZWN0b3IgPSBTZWxlY3RvciA9IChmdW5jdGlvbigpIHtcblxuICAgIGZ1bmN0aW9uIFNlbGVjdG9yKG9wdGlvbnMsIHNjZW5lKSB7XG4gICAgICB2YXIgbnVtYmVyLCB0aGF0O1xuICAgICAgdGhpcy5zY2VuZSA9IHNjZW5lO1xuICAgICAgaWYgKCEob3B0aW9ucy5zaXplICYmIG9wdGlvbnMucG9zaXRpb24pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5zaXplID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIG51bWJlciA9IG9wdGlvbnMuc2l6ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMucG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMyhvcHRpb25zLnBvc2l0aW9uLngsIG9wdGlvbnMucG9zaXRpb24ueSwgb3B0aW9ucy5wb3NpdGlvbi56KTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQm94R2VvbWV0cnkob3B0aW9ucy5zaXplLngsIG9wdGlvbnMuc2l6ZS55LCBvcHRpb25zLnNpemUueik7XG4gICAgICB0aGlzLmlzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIGlmICghb3B0aW9ucy5tYXRlcmlhbCkge1xuICAgICAgICB0aGlzLm1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAgICAgICAgICBvcGFjaXR5OiAwLjAxLFxuICAgICAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgICAgIGNvbG9yOiAweGZmZmZmZixcbiAgICAgICAgICB3aXJlZnJhbWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMubWF0ZXJpYWwuaWQgPT09IHZvaWQgMCkge1xuICAgICAgICB0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWwgfHwgbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAgICAgICAgICBvcGFjaXR5OiAwLjAsXG4gICAgICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsXG4gICAgICAgICAgY29sb3I6IDB4MDA4ODg4LFxuICAgICAgICAgIHdpcmVmcmFtZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLm1lc2ggPSBuZXcgVEhSRUUuTWVzaCh0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsKTtcbiAgICAgIHRoaXMubWVzaC5wb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgICB0aGlzLm1lc2gud3JhcHBlciA9IHRoaXM7XG4gICAgICB0aGF0ID0gdGhpcztcbiAgICAgIHRoaXMubWVzaC5hZGRFdmVudExpc3RlbmVyKFwiaG92ZXJcIiwgdGhhdC5ob3Zlcik7XG4gICAgICB0aGlzLm1lc2guYWRkRXZlbnRMaXN0ZW5lcihcImxlYXZlXCIsIHRoYXQubGVhdmUpO1xuICAgICAgdGhpcy5tZXNoLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGF0LmNsaWNrKTtcbiAgICAgIHRoaXMubWVzaC5hZGRFdmVudExpc3RlbmVyKFwiY2xlYXJcIiwgdGhhdC5jbGVhcik7XG4gICAgICBpZiAodGhpcy5zY2VuZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXMuYWRkVG9TY2VuZSh0aGlzLnNjZW5lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBTZWxlY3Rvci5wcm90b3R5cGUuYWRkVG9TY2VuZSA9IGZ1bmN0aW9uKHNjZW5lKSB7XG4gICAgICB0aGlzLnNjZW5lID0gc2NlbmU7XG4gICAgICByZXR1cm4gc2NlbmUuYWRkKHRoaXMubWVzaCk7XG4gICAgfTtcblxuICAgIFNlbGVjdG9yLnByb3RvdHlwZS5ob3ZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuaXNTZWxlY3RlZCA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vbGRtYXRlcmlhbCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXMub2xkbWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMubWF0ZXJpYWwgPSB0aGlzLmhvdmVybWF0ZXJpYWwgfHwgbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAgICAgICAgb3BhY2l0eTogMC40NSxcbiAgICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsXG4gICAgICAgIGNvbG9yOiAweDAwYWE4OCxcbiAgICAgICAgd2lyZWZyYW1lOiB0cnVlXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgU2VsZWN0b3IucHJvdG90eXBlLmxlYXZlID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5pc1NlbGVjdGVkKSB7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hdGVyaWFsID0gdGhpcy5vbGRtYXRlcmlhbCB8fCBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICAgICAgICAgIGNvbG9yOiAweDAwYWE4OFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgU2VsZWN0b3IucHJvdG90eXBlLmNsaWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmlzU2VsZWN0ZWQgPSAhdGhpcy5pc1NlbGVjdGVkO1xuICAgICAgaWYgKHRoaXMuaXNTZWxlY3RlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXRlcmlhbCA9IHRoaXMuc2VsZWN0ZWRtYXRlcmlhbCB8fCBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICAgICAgICAgIGNvbG9yOiAweGZmZmZmZixcbiAgICAgICAgICB3aXJlZnJhbWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXRlcmlhbCA9IHRoaXMub2xkbWF0ZXJpYWw7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFNlbGVjdG9yLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5pc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcy5tYXRlcmlhbCA9IHRoaXMub2xkbWF0ZXJpYWwgfHwgbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAgICAgICAgY29sb3I6IDB4MDA4ODg4XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNlbGVjdG9yO1xuXG4gIH0pKCk7XG5cbiAgbW9kdWxlLmV4cG9ydHMuU2t5Ym94ID0gU2t5Ym94ID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgZnVuY3Rpb24gU2t5Ym94KCkge1xuICAgICAgX2NsYXNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgX2NsYXNzID0gY29uc29sZS5sb2coXCJ3b3dcIik7XG5cbiAgICByZXR1cm4gU2t5Ym94O1xuXG4gIH0pKCk7XG5cbn0pLmNhbGwodGhpcyk7XG5cbi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS41LjAtcHJlXG4iLCJcbi8qXG5cbiAgU3RhZ2VzIGlzIGFuIG9iamVjdCB0byBtYW5hZ2UsIHdlbGwsIHN0YWdlcy5cbiAgd2hpY2ggYSBzdGFnZSBpcyB0aGUgZXF1aXZhbGVudCB0byB0aGUgZ2FtZSBjb25jZXB0IG9mIGEgJ2xldmVsLidcbiAgYnV0IHNvbWVvbmUgY291bGQgdXNlIG11bHRpcGxlIHN0YWdlcyBpbiBvbmUgbGV2ZWwsIHNvIEkgZG9uJ3Qgd2FudCB0byBiZSBwdXNoeSBhbmQgY2FsbCBpdCBhICdsZXZlbCcgbWFuYWdlclxuKi9cblxuXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBJbnB1dCwgU2VsZWN0aW9uR3JpZCwgU2VsZWN0b3IsIFN0YWdlLCBTdGFnZU1hbmFnZXIsIHV0aWxzLFxuICAgIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LFxuICAgIF9fZXh0ZW5kcyA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoX19oYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9O1xuXG4gIHV0aWxzID0gcmVxdWlyZShcIi4vX3V0aWxzXCIpO1xuXG4gIElucHV0ID0gcmVxdWlyZShcIi4vX2lucHV0XCIpO1xuXG4gIFNlbGVjdG9yID0gcmVxdWlyZShcIi4vX29iamVjdHNcIikuU2VsZWN0b3I7XG5cbiAgLypcbiAgICAgIFNlbGVjdGlvbkdyaWQgQ2xhc3NcbiAgICAgIEhlbHBlciBjbGFzcyBmb3Igc2VsZWN0aW5nIG9iamVjdHMgLyBlbnRpdGllcyBmcm9tIGEgZ3JpZFxuICAgICAgU2hvdWxkIGJlIGF1dG9tYXRpY2FsbHkgY3JlYXRlZCB3aGVuXG4gICovXG5cblxuICBTZWxlY3Rpb25HcmlkID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgZnVuY3Rpb24gU2VsZWN0aW9uR3JpZChkYXRhLCBlbmdpbmUsIHN0YWdlKSB7XG4gICAgICB2YXIgY2VudGVySW5kZXgsIGV2ZW5PZmZzZXQsIGhtLCBpc0ludCwgbywgeCwgeDAsIHksIHkwLCBfcmVmO1xuICAgICAgdGhpcy5tZXNoZXMgPSBbXTtcbiAgICAgIHRoaXMuZW5naW5lID0gZW5naW5lO1xuICAgICAgdGhpcy5zdGFnZSA9IHN0YWdlO1xuICAgICAgdGhpcy53aWR0aCA9IGRhdGEud2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IGRhdGEubGVuZ3RoO1xuICAgICAgdGhpcy5wYWRkaW5nID0gZGF0YS5wYWRkaW5nIHx8IDI7XG4gICAgICB0aGlzLnggPSBkYXRhLng7XG4gICAgICB0aGlzLnkgPSBkYXRhLnk7XG4gICAgICBpc0ludCA9IGZ1bmN0aW9uKG51bSkge1xuICAgICAgICBpZiAobnVtIC8gTWF0aC5mbG9vcihudW0pID09PSAxIHx8IG51bSAvIE1hdGguZmxvb3IobnVtKSA9PT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgICAgLyogQ29udmVydCB0aGUgZGF0YSBpbnRvIGEgbm9ybWFsaXplZCBncmlkIGRhdGFcbiAgICAgICovXG5cbiAgICAgIGV2ZW5PZmZzZXQgPSAoX3JlZiA9IGlzSW50KGRhdGEueCAvIDIpKSAhPSBudWxsID8gX3JlZiA6IHtcbiAgICAgICAgMDogMVxuICAgICAgfTtcbiAgICAgIHgwID0gfn4oZGF0YS54IC8gMik7XG4gICAgICB5MCA9IH5+KGRhdGEueSAvIDIpO1xuICAgICAgY2VudGVySW5kZXggPSBudWxsO1xuICAgICAgeCA9IC0xICogeDA7XG4gICAgICB5ID0gLTEgKiB5MDtcbiAgICAgIGhtID0gdXRpbHMuaXNBcnJheShkYXRhLmhlaWdodG1hcCkgPyBkYXRhLmhlaWdodG1hcCA6IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9pLCBfcmVmMSwgX3Jlc3VsdHM7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAobyA9IF9pID0gMCwgX3JlZjEgPSBkYXRhLnggKiBkYXRhLnk7IDAgPD0gX3JlZjEgPyBfaSA8IF9yZWYxIDogX2kgPiBfcmVmMTsgbyA9IDAgPD0gX3JlZjEgPyArK19pIDogLS1faSkge1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2gobyAtIG8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH0pKCk7XG4gICAgICBkYXRhID0gaG0ubWFwKGZ1bmN0aW9uKGVsLCBpbmRleCwgYXJyKSB7XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICBub2RlID0ge1xuICAgICAgICAgIFwielwiOiBlbCxcbiAgICAgICAgICBcInhcIjogeCxcbiAgICAgICAgICBcInlcIjogeVxuICAgICAgICB9O1xuICAgICAgICBpZiAoeCA9PT0gMCAmJiB5ID09PSAwKSB7XG4gICAgICAgICAgbm9kZS5jZW50ZXIgPSB0cnVlO1xuICAgICAgICAgIGNlbnRlckluZGV4ID0gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHggPT09ICh4MCAtIGV2ZW5PZmZzZXQpKSB7XG4gICAgICAgICAgeCA9IC0xICogeDA7XG4gICAgICAgICAgeSsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHgrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jZW50ZXJJbmRleCA9IGNlbnRlckluZGV4O1xuICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgIHRoaXMuY3JlYXRlR3JpZCgpO1xuICAgIH1cblxuICAgIFNlbGVjdGlvbkdyaWQucHJvdG90eXBlLmNyZWF0ZUdyaWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjdWJlLCBkYXR1bSwgaCwgbWF0ZXJpYWwsIHBhZGRpbmcsIHBvc2l0aW9uLCBzY2VuZSwgc2l6ZSwgdywgeCwgeSwgX2ksIF9sZW4sIF9yZWYsIF9yZXN1bHRzO1xuICAgICAgaWYgKHRoaXMuZGF0YSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMub2JqZWN0cyA9IFtdO1xuICAgICAgeCA9IDA7XG4gICAgICB5ID0gMDtcbiAgICAgIHcgPSB0aGlzLndpZHRoO1xuICAgICAgaCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgcGFkZGluZyA9IHRoaXMucGFkZGluZyB8fCAyO1xuICAgICAgX3JlZiA9IHRoaXMuZGF0YTtcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgZGF0dW0gPSBfcmVmW19pXTtcbiAgICAgICAgc2l6ZSA9IHtcbiAgICAgICAgICB4OiB3LFxuICAgICAgICAgIHk6IHcsXG4gICAgICAgICAgejogMFxuICAgICAgICB9O1xuICAgICAgICBwb3NpdGlvbiA9IHtcbiAgICAgICAgICB4OiBkYXR1bS54ICogKHcgKyBwYWRkaW5nKSxcbiAgICAgICAgICB5OiBkYXR1bS55ICogKHcgKyBwYWRkaW5nKSxcbiAgICAgICAgICB6OiBkYXR1bS56ICogKGggKyBwYWRkaW5nKVxuICAgICAgICB9O1xuICAgICAgICBtYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWw7XG4gICAgICAgIHNjZW5lID0gdGhpcy5zdGFnZS5zY2VuZTtcbiAgICAgICAgY3ViZSA9IG5ldyBTZWxlY3Rvcih7XG4gICAgICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgICAgICAgbWF0ZXJpYWw6IG1hdGVyaWFsXG4gICAgICAgIH0sIHNjZW5lKTtcbiAgICAgICAgdGhpcy5vYmplY3RzLnB1c2goY3ViZSk7XG4gICAgICAgIF9yZXN1bHRzLnB1c2godGhpcy5zdGFnZS5tZXNoZXMucHVzaChjdWJlLm1lc2gpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgU2VsZWN0aW9uR3JpZC5wcm90b3R5cGUuZmlsdGVyRGF0YSA9IGZ1bmN0aW9uKHZlYzMpIHtcbiAgICAgIC8qXG4gICAgICAgIGFyZ3VtZW50ICd2ZWMzJyBjYW4gYmUgYW4gb2JqZWN0IG9yIGEgVEhSRUUuVmVjdG9yMyBpbnN0YW5jZVxuICAgICAgICAhIFZlY3RvcjMgaW5zdGFuY2VzIGRvbid0IGFsbG93IHlvdSB0byBoYXZlICd1bmRlZmluZWQnIGFzIGEgdmFsdWUsIHNvIHVzaW5nICcqJyBpcyB1c2VkXG4gICAgICAgIGllOiAgIGZpbHRlckRhdGEoIG5ldyBUSFJFRS5WZWN0b3IzKDAsIFwiKlwiLCBcIipcIikgKTtcbiAgICAgIFxuICAgICAgICBQbGFpbiBvYmplY3RzIGRvIGFsbG93IHVuZGVmaW5lZCB0aG91Z2gsIHNvIHlvdSBjYW4gcGFzcyBpbiBhbiBvYmplY3Qgd2l0aCBhbGwgdGhlIHZhbHVlcyB5b3Ugd2FudFxuICAgICAgICBpZTogICBmaWx0ZXJEYXRhKHsgeDogMn0pO1xuICAgICAgKi9cbiAgICAgIGlmICghdmVjMykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5kYXRhLmZpbHRlcihmdW5jdGlvbihlbCwgaSwgYXJyKSB7XG4gICAgICAgIGlmIChlbC54ID09PSB2ZWMzLnggfHwgdmVjMy54ID09PSBcIipcIiB8fCB2ZWMzLnggPT09IHZvaWQgMCkge1xuICAgICAgICAgIGlmIChlbC55ID09PSB2ZWMzLnkgfHwgdmVjMy55ID09PSBcIipcIiB8fCB2ZWMzLnkgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgaWYgKGVsLnogPT09IHZlYzMueiB8fCB2ZWMzLnogPT09IFwiKlwiIHx8IHZlYzMueiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2VsZWN0aW9uR3JpZDtcblxuICB9KSgpO1xuXG4gIFN0YWdlID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuXG4gICAgX19leHRlbmRzKFN0YWdlLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gU3RhZ2UocGFyZW50LCBuYW1lLCBvcHRpb25zKSB7XG4gICAgICB2YXIgYmVmb3JlTG9hZGVkLCBjYWxsYmFja3MsIGNhbWVyYSwgdGhhdDtcbiAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgdGhpcy5yZW5kZXJlciA9IHBhcmVudC5yZW5kZXJlcjtcbiAgICAgIHRoaXMubmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHRoaXMuc2NlbmUgPSBvcHRpb25zLnNjZW5lO1xuICAgICAgY2FtZXJhID0gb3B0aW9ucy5jYW1lcmE7XG4gICAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcbiAgICAgIHRoaXMubWVzaGVzID0gW107XG4gICAgICBiZWZvcmVMb2FkZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgdGhpcy5JbnB1dCA9IG5ldyBJbnB1dC5JbnRlcmZhY2UodGhpcywgcGFyZW50KTtcbiAgICAgICAgdGhpcy5Nb3VzZURldGVjdG9yID0gbmV3IElucHV0Lk1vdXNlRGV0ZWN0aW9uKHRoaXMsIHBhcmVudCk7XG4gICAgICAgIHJldHVybiB0aGlzLm9ubG9hZC5jYWxsKHRoaXMpO1xuICAgICAgfTtcbiAgICAgIHRoYXQgPSB0aGlzO1xuICAgICAgdGhhdC5vbihcImxvYWRcIiwgYmVmb3JlTG9hZGVkLmJpbmQodGhhdCkpO1xuICAgICAgY2FsbGJhY2tzID0ge1xuICAgICAgICBzY29wZTogdGhhdCxcbiAgICAgICAgc3VjY2VzczogZnVuY3Rpb24ocmVzcG9uc2VUZXh0KSB7XG4gICAgICAgICAgdGhhdC5kYXRhID0gcmVzcG9uc2VUZXh0O1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiRW5naW5lIDo6ICdcIiArIG5hbWUgKyBcIicgYWpheCdkLiBcIik7XG4gICAgICAgICAgdGhhdC5kYXRhLmdyaWQgPSB0aGF0LmdyaWQgPSBuZXcgU2VsZWN0aW9uR3JpZCh0aGF0LmRhdGEuZ3JpZCwgdGhhdC5wYXJlbnQsIHRoYXQpO1xuICAgICAgICAgIHJldHVybiB0aGF0LnRyaWdnZXIoXCJsb2FkXCIpO1xuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgcmV0cmlldmluZyBkYXRhIGZvciBTdGFnZVwiKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChvcHRpb25zLnVybCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHV0aWxzLmdldEpTT04ob3B0aW9ucy51cmwsIGNhbGxiYWNrcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgU3RhZ2UucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbih1cmxUb0pzb24pIHtcbiAgICAgIC8qXG4gICAgICAgIGluY2FzZSB3YXNuJ3Qgb3JpZ2luYWxseSBwYXNzZWQgaW5cbiAgICAgICovXG5cbiAgICAgIHZhciBjYWxsYmFja3MsIHRoYXQ7XG4gICAgICB0aGF0ID0gdGhpcztcbiAgICAgIGNhbGxiYWNrcyA9IHtcbiAgICAgICAgc2NvcGU6IHRoYXQsXG4gICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKHJlc3BvbnNlVGV4dCkge1xuICAgICAgICAgIHRoYXQuZGF0YSA9IHJlc3BvbnNlVGV4dDtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIkVuZ2luZSA6OiAnXCIgKyBuYW1lICsgXCInIGFqYXgnZC4gXCIpO1xuICAgICAgICAgIHRoYXQuZGF0YS5ncmlkID0gdGhhdC5ncmlkID0gbmV3IFNlbGVjdGlvbkdyaWQodGhhdC5kYXRhLmdyaWQsIHRoYXQucGFyZW50LCB0aGF0KTtcbiAgICAgICAgICByZXR1cm4gdGhhdC50cmlnZ2VyKFwibG9hZFwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIHJldHJpZXZpbmcgZGF0YSBmb3IgU3RhZ2VcIik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAodXJsVG9Kc29uICE9PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIHV0aWxzLmdldEpTT04odXJsVG9Kc29uLCBjYWxsYmFja3MpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBTdGFnZS5wcm90b3R5cGUub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAvKlxuICAgICAgICBtZWFudCB0byBiZSBvdmVyd3JpdHRlbiBieSB0aGUgdXNlclxuICAgICAgICBhbHRlcm5hdGl2ZSBpczogXG4gICAgICAgIHwgQG9uIFwibG9hZFwiLCBmblxuICAgICAgICB3aGljaCB3aWxsIGJlIHRyaWdnZXJlZCBvbiBsb2FkaW5nXG4gICAgICAqL1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFN0YWdlLnByb3RvdHlwZS5sb29rQXQgPSBmdW5jdGlvbihwb2ludCkge1xuICAgICAgdGhpcy5jYW1lcmEudXAgPSBuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAxKTtcbiAgICAgIHJldHVybiB0aGlzLmNhbWVyYS5sb29rQXQocG9pbnQgfHwgdGhpcy5zY2VuZSk7XG4gICAgfTtcblxuICAgIFN0YWdlLnByb3RvdHlwZS5zZXRDYW1lcmFUb0lzb21ldHJpYyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGRpc3RhbmNlRnJvbUNlbnRlcm9mR3JpZFRvRWRnZSwgaCwgdywgeCwgeERpc3RhbmNlLCB5LCB5RGlzdGFuY2UsIHpEaXN0YW5jZTtcbiAgICAgIGlmICghdGhpcy5ncmlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHcgPSB0aGlzLmdyaWQud2lkdGg7XG4gICAgICBoID0gdGhpcy5ncmlkLmhlaWdodDtcbiAgICAgIHggPSB0aGlzLmdyaWQueDtcbiAgICAgIHkgPSB0aGlzLmdyaWQueTtcbiAgICAgIGRpc3RhbmNlRnJvbUNlbnRlcm9mR3JpZFRvRWRnZSA9IHV0aWxzLnB5dGhhZyh3ICogeCwgaCAqIHkpO1xuICAgICAgekRpc3RhbmNlID0gZGlzdGFuY2VGcm9tQ2VudGVyb2ZHcmlkVG9FZGdlIC8gMjtcbiAgICAgIHlEaXN0YW5jZSA9ICh3ICsgKHRoaXMuZ3JpZC5wYWRkaW5nIHx8IDIpKSAqIHg7XG4gICAgICB4RGlzdGFuY2UgPSAodyArICh0aGlzLmdyaWQucGFkZGluZyB8fCAyKSkgKiB4O1xuICAgICAgdGhpcy5jYW1lcmEucG9zaXRpb24uc2V0Wih6RGlzdGFuY2UpO1xuICAgICAgdGhpcy5jYW1lcmEucG9zaXRpb24uc2V0WSh5RGlzdGFuY2UpO1xuICAgICAgdGhpcy5jYW1lcmEucG9zaXRpb24uc2V0WCh4RGlzdGFuY2UpO1xuICAgICAgdGhpcy5jYW1lcmEudXAgPSBuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAxKTtcbiAgICAgIHRoaXMuY2FtZXJhLmxvb2tBdChuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAwKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICAgIC8qXG4gICAgICBcbiAgICAgIFxuICAgICAgQGNhbWVyYS5yb3RhdGlvbi56ID0gMC4yNVxuICAgICAgKi9cblxuICAgIH07XG5cbiAgICBTdGFnZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgTCwgZXh0ZW50LCBnZW9tZXRyeSwgbGluZSwgbWF0ZXJpYWw7XG4gICAgICBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuICAgICAgZXh0ZW50ID0gNTAwMDtcbiAgICAgIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2gobmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgLWV4dGVudCkpO1xuICAgICAgZ2VvbWV0cnkudmVydGljZXMucHVzaChuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCBleHRlbnQpKTtcbiAgICAgIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2gobmV3IFRIUkVFLlZlY3RvcjMoLWV4dGVudCwgMCwgMCkpO1xuICAgICAgZ2VvbWV0cnkudmVydGljZXMucHVzaChuZXcgVEhSRUUuVmVjdG9yMyhleHRlbnQsIDAsIDApKTtcbiAgICAgIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2gobmV3IFRIUkVFLlZlY3RvcjMoMCwgLWV4dGVudCwgMCkpO1xuICAgICAgZ2VvbWV0cnkudmVydGljZXMucHVzaChuZXcgVEhSRUUuVmVjdG9yMygwLCBleHRlbnQsIDApKTtcbiAgICAgIG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKHtcbiAgICAgICAgY29sb3I6IDB4NTU1NTU1XG4gICAgICB9KTtcbiAgICAgIGxpbmUgPSBuZXcgVEhSRUUuTGluZShnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICAgICAgdGhpcy5zY2VuZS5hZGQobGluZSk7XG4gICAgICB0aGlzLnNldENhbWVyYVRvSXNvbWV0cmljKCk7XG4gICAgICB0aGlzLnBhcmVudC5yZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpO1xuICAgICAgTCA9IHRoaXMucGFyZW50LmNsb2NrLmxvb3AoXCJyZW5kZXJcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5yZW5kZXJlci5yZW5kZXIodGhpcy5zY2VuZSwgdGhpcy5jYW1lcmEpO1xuICAgICAgfSwgbnVsbCwgdGhpcyk7XG4gICAgICBMW1wiZm9yXCJdKHtcbiAgICAgICAgaW50ZXJ2YWw6IDE3XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5jbG9jay5zdGFydCgpO1xuICAgIH07XG5cbiAgICBTdGFnZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmRlc3Ryb3kodGhpcy5uYW1lKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFN0YWdlO1xuXG4gIH0pKHV0aWxzLkV2ZW50RW1pdHRlcik7XG5cbiAgU3RhZ2VNYW5hZ2VyID0gZnVuY3Rpb24oZW5naW5lKSB7XG4gICAgLyogQFBSSVZBVEVTXG4gICAgKi9cblxuICAgIHZhciBsaXN0LCBwYXJlbnQ7XG4gICAgcGFyZW50ID0gZW5naW5lO1xuICAgIC8qIEBQVUJMSUNTXG4gICAgKi9cblxuICAgIGxpc3QgPSB7fTtcbiAgICB0aGlzLmxpc3QgPSBbXTtcbiAgICB0aGlzLmNyZWF0ZSA9IGZ1bmN0aW9uKG5hbWUsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBvLCBzdGFnZTtcbiAgICAgIGlmICghbmFtZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBvID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIHN0YWdlID0gbmV3IFN0YWdlKHBhcmVudCwgbmFtZSwgbyk7XG4gICAgICB0aGlzLmxpc3QucHVzaChuYW1lKTtcbiAgICAgIGxpc3RbbmFtZS50b0xvd2VyQ2FzZSgpXSA9IHN0YWdlO1xuICAgICAgcmV0dXJuIGxpc3RbbmFtZS50b0xvd2VyQ2FzZSgpXTtcbiAgICB9O1xuICAgIHRoaXMuY3VycmVudCA9IHZvaWQgMDtcbiAgICB0aGlzLmRlc3Ryb3kgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICByZXR1cm4gZGVsZXRlIGxpc3RbbmFtZV07XG4gICAgfTtcbiAgICB0aGlzLmxvYWQgPSBmdW5jdGlvbihuYW1lLCB0cmFuc2l0aW9uKSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFN0YWdlTWFuYWdlcjtcblxufSkuY2FsbCh0aGlzKTtcblxuLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjUuMC1wcmVcbiIsIlxuLypcbiAgICAgIHV0aWxpdGllc1xuKi9cblxuXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBFdmVudEVtaXR0ZXIsXG4gICAgX19zbGljZSA9IFtdLnNsaWNlO1xuXG4gIG1vZHVsZS5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKG1zZykge1xuICAgIHZhciBwcmVmaXg7XG4gICAgdGhpcy5sb2dzLnVuc2hpZnQobXNnKTtcbiAgICBpZiAoIXRoaXMuZGVidWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcHJlZml4ID0gXCJFbmdpbmUgOjogXCI7XG4gICAgaWYgKHR5cGVvZiBtc2cgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnNvbGUubG9nKHByZWZpeCArIG1zZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKG1zZyk7XG4gICAgfVxuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBiYXNlLCBleHRlbmRlZCwga2V5LCBvYmosIG9ianMsIF9pLCBfbGVuO1xuICAgIG9ianMgPSAxIDw9IGFyZ3VtZW50cy5sZW5ndGggPyBfX3NsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSA6IFtdO1xuICAgIGlmIChvYmpzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybiBvYmpzWzBdO1xuICAgIH1cbiAgICBleHRlbmRlZCA9IG9ianNbMF07XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBvYmpzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICBvYmogPSBvYmpzW19pXTtcbiAgICAgIGJhc2UgPSBvYmo7XG4gICAgICBmb3IgKGtleSBpbiBiYXNlKSB7XG4gICAgICAgIGV4dGVuZGVkW2tleV0gPSBiYXNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBleHRlbmRlZDtcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cy5pc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbih0aGluZykge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGhpbmcgPT09IFwiW29iamVjdCBBcnJheV1cIik7XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMucHl0aGFnID0gZnVuY3Rpb24oQSwgQiwgaHlwb3RlbnVzZSkge1xuICAgIHZhciBhMiwgYjIsIHJlc3VsdDtcbiAgICBpZiAoIShhcmd1bWVudHMubGVuZ3RoID49IDIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChCID09PSBudWxsKSB7XG4gICAgICByZXN1bHQgPSAoTWF0aC5wb3coaHlwb3RlbnVzZSwgMikpIC0gTWF0aC5wb3coQSwgMik7XG4gICAgICByZXN1bHQgPSBNYXRoLnNxcnQocmVzdWx0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGEyID0gTWF0aC5wb3coQSwgMik7XG4gICAgICBiMiA9IE1hdGgucG93KEIsIDIpO1xuICAgICAgcmVzdWx0ID0gTWF0aC5zcXJ0KGEyICsgYjIpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMuZ2V0SlNPTiA9IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2tzKSB7XG4gICAgdmFyIGFqYXgsIGRhdGEsIG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IGNhbGxiYWNrcyB8fCB7fTtcbiAgICBkYXRhID0gdm9pZCAwO1xuICAgIGFqYXggPSAkLmdldEpTT04odXJsKTtcbiAgICByZXR1cm4gYWpheC5jb21wbGV0ZShmdW5jdGlvbigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRhdGEgPSAkLnBhcnNlSlNPTihhamF4LnJlc3BvbnNlVGV4dCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIG9wdGlvbnMuZXJyb3IuY2FsbChvcHRpb25zLnNjb3BlIHx8IG51bGwsIGUsIGFqYXgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBvcHRpb25zLnN1Y2Nlc3MuY2FsbChvcHRpb25zLnNjb3BlIHx8IG51bGwsIGRhdGEsIGFqYXgpO1xuICAgIH0pO1xuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzLmdldE1vdXNlUG9zaXRpb24gPSBmdW5jdGlvbigkZSkge1xuICAgIHZhciBub3JtYWxpemVkLCB4LCB5O1xuICAgIGlmICghKCRlLnR5cGUgPT09IFwiY2xpY2tcIiB8fCAkZS50eXBlID09PSBcIm1vdXNlbW92ZVwiKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB4ID0gJGUuY2xpZW50WDtcbiAgICB5ID0gJGUuY2xpZW50WTtcbiAgICBub3JtYWxpemVkID0ge1xuICAgICAgXCJ4XCI6ICh4IC8gd2luZG93LmlubmVyV2lkdGgpICogMiAtIDEsXG4gICAgICBcInlcIjogLSh5IC8gd2luZG93LmlubmVySGVpZ2h0KSAqIDIgKyAxXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogeCxcbiAgICAgIHk6IHksXG4gICAgICBub3JtYWxpemVkOiBub3JtYWxpemVkXG4gICAgfTtcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXIgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICBmdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7fVxuXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudHMgPSB7fTtcblxuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbihuYW1lLCBmbikge1xuICAgICAgdGhpcy5ldmVudHNbbmFtZV0gPSBmbjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmV2ZW50c1tuYW1lXTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmV2ZW50c1tuYW1lXTtcbiAgICB9O1xuXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGZuO1xuICAgICAgZm4gPSB0aGlzLmdldChuYW1lKTtcbiAgICAgIGlmIChmbiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZuLmNhbGwoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyO1xuXG4gIH0pKCk7XG5cbn0pLmNhbGwodGhpcyk7XG5cbi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS41LjAtcHJlXG4iLCIoZnVuY3Rpb24oKSB7XG5cbiAgcmVxdWlyZShcIi4vX2Jhc2VcIik7XG5cbiAgcmVxdWlyZShcIi4vbWFpblwiKTtcblxufSkuY2FsbCh0aGlzKTtcblxuLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjUuMC1wcmVcbiIsIihmdW5jdGlvbigpIHtcblxuXG5cbn0pLmNhbGwodGhpcyk7XG5cbi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS41LjAtcHJlXG4iXX0=
